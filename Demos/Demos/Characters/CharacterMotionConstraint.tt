<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using BepuUtilities;
using BepuPhysics;
using System.Numerics;
using System;
using System.Runtime.CompilerServices;
using BepuPhysics.Constraints;
using BepuUtilities.Memory;
using static BepuUtilities.GatherScatter;

namespace Demos.Demos.Characters
{ 
    public struct CharacterMotionAccumulatedImpulse
    {
        public Vector2Wide Horizontal;
        public Vector<float> Vertical;
    }

    //IMPORTANT NOTE: The static and dynamic motion constraint variants were autogenerated from a text template. To modify the constraint, modify the text template instead.
    //Using code generators to generate these sorts of constraint variants can work around some of the limitations in compile time expressiveness-
    //here, we avoid creating a bunch of duplicate math for the one and two body constraint cases which would have to be separately maintained.
    //There are other cases where this is pushed even further. Within the engine, the dozens of contact constraint variants are generated by text templates.
    //This isn't the most wonderful solution in terms of development experience or tooling, 
    //but it maximizes performance and avoids the need for in-language turing complete metaprogramming, so I'm okay with it.

<#for (int i = 0; i < 2; ++i) 
{
    var dynamic = i == 1;
    var prefix = dynamic ? "Dynamic" : "Static";
#>
    //Constraint descriptions provide an explicit mapping from the array-of-structures format to the internal array-of-structures-of-arrays format used by the solver.
    //Note that there is a separate description for the one and two body case- constraint implementations take advantage of the lack of a second body to reduce data gathering requirements.
    /// <summary>
    /// Description of a character motion constraint where the support is <#=prefix.ToLower()#>.
    /// </summary>
    public struct <#=prefix#>CharacterMotionConstraint : I<#=dynamic ? "TwoBody" : "OneBody"#>ConstraintDescription<<#=prefix#>CharacterMotionConstraint>
    {
        /// <summary>
        /// Maximum force that the horizontal motion constraint can apply to reach the current velocity goal.
        /// </summary>
        public float MaximumHorizontalForce;
        /// <summary>
        /// Maximum force that the vertical motion constraint can apply to fight separation.
        /// </summary>
        public float MaximumVerticalForce;
        /// <summary>
        /// Target horizontal velocity in terms of the basis X and -Z axes.
        /// </summary>
        public Vector2 TargetVelocity;
        /// <summary>
        /// Depth of the supporting contact. The vertical motion constraint permits separating velocity if, after a frame, the objects will still be touching.
        /// </summary>
		public float Depth;
        /// <summary>
        /// Stores the quaternion-packed orthonormal basis for the motion constraint. When expanded into a matrix, X and Z will represent the Right and Backward directions respectively. Y will represent Up.
        /// In other words, a target tangential velocity of (4, 2) will result in a goal velocity of 4 along the (1, 0, 0) * Basis direction and a goal velocity of 2 along the (0, 0, -1) * Basis direction.
        /// All motion moving along the (0, 1, 0) * Basis axis will be fought against by the vertical motion constraint.
        /// </summary>
        public Quaternion SurfaceBasis;
        /// <summary>
        /// World space offset from the character's center to apply impulses at.
        /// </summary>
        public Vector3 OffsetFromCharacterToSupportPoint;
<#if(dynamic) {#>
        /// <summary>
        /// World space offset from the support's center to apply impulses at.
        /// </summary>
        public Vector3 OffsetFromSupportToSupportPoint;
<#}#>

        //It's possible to create multiple descriptions for the same underlying constraint type id which can update different parts of the constraint data.
        //This functionality isn't used very often, though- you'll notice that the engine has a 1:1 mapping (at least at the time of this writing).
        //But in principle, it doesn't have to be that way. So, the description must provide information about the type and type id.
        /// <summary>
        /// Gets the constraint type id that this description is associated with. 
        /// </summary>
        public static int ConstraintTypeId => <#=prefix#>CharacterMotionTypeProcessor.BatchTypeId;

        /// <summary>
        /// Gets the TypeProcessor type that is associated with this description.
        /// </summary>
        public static Type TypeProcessorType => typeof(<#=prefix#>CharacterMotionTypeProcessor);    
        /// <summary>
        /// Creates a type processor for this constraint type.
        /// </summary>
        public static TypeProcessor CreateTypeProcessor() => new <#=prefix#>CharacterMotionTypeProcessor();

        //Note that these mapping functions use a "GetOffsetInstance" function. Each CharacterMotionPrestep is a bundle of multiple constraints;
        //by grabbing an offset instance, we're selecting a specific slot in the bundle to modify. For simplicity and to guarantee consistency of field strides,
        //we refer to that slot using the same struct and then write only to the first slot.
        //(Note that accessing slots after the first may result in access violations; the 'offset instance' is not guaranteed to refer to valid data beyond the first slot!)
        public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex)
        {
            ref var target = ref GetOffsetInstance(ref Buffer<<#=prefix#>CharacterMotionPrestep>.Get(ref batch.PrestepData, bundleIndex), innerIndex);
            QuaternionWide.WriteFirst(SurfaceBasis, ref target.SurfaceBasis);
            GetFirst(ref target.MaximumHorizontalForce) = MaximumHorizontalForce;
            GetFirst(ref target.MaximumVerticalForce) = MaximumVerticalForce;
            Vector2Wide.WriteFirst(TargetVelocity, ref target.TargetVelocity);
			GetFirst(ref target.Depth) = Depth;
            Vector3Wide.WriteFirst(OffsetFromCharacterToSupportPoint, ref target.OffsetFromCharacter);
<#if(dynamic) {#>
            Vector3Wide.WriteFirst(OffsetFromSupportToSupportPoint, ref target.OffsetFromSupport);
<#}#>
        }

        public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out <#=prefix#>CharacterMotionConstraint description)
        {
            ref var source = ref GetOffsetInstance(ref Buffer<<#=prefix#>CharacterMotionPrestep>.Get(ref batch.PrestepData, bundleIndex), innerIndex);
            QuaternionWide.ReadFirst(source.SurfaceBasis, out description.SurfaceBasis);
            description.MaximumHorizontalForce = GetFirst(ref source.MaximumHorizontalForce);
            description.MaximumVerticalForce = GetFirst(ref source.MaximumVerticalForce);
            Vector2Wide.ReadFirst(source.TargetVelocity, out description.TargetVelocity);
			description.Depth = GetFirst(ref source.Depth);
            Vector3Wide.ReadFirst(source.OffsetFromCharacter, out description.OffsetFromCharacterToSupportPoint);
<#if(dynamic) {#>
            Vector3Wide.ReadFirst(source.OffsetFromSupport, out description.OffsetFromSupportToSupportPoint);
<#}#>
        }
    }

    //Note that all the solver-side data is in terms of 'Wide' data types- the solver never works on just one constraint at a time. Instead,
    //it executes them in bundles of width equal to the runtime/hardware exposed SIMD unit width. This lets the solver scale with wider compute units.
    //(This is important for machines that can perform 8 or more operations per instruction- there's no good way to map a single constraint instance's 
    //computation onto such a wide instruction, so if the solver tried to do such a thing, it would leave a huge amount of performance on the table.)

    //"Prestep" data can be thought of as the input to the solver. It describes everything the solver needs to know about.
    /// <summary>
    /// AOSOA formatted bundle of prestep data for multiple <#=prefix.ToLower()#>-supported character motion constraints.
    /// </summary>
    public struct <#=prefix#>CharacterMotionPrestep
    {
        //Note that the prestep data layout is important. The solver tends to be severely memory bandwidth bound, so using a minimal representation is valuable.
        //That's why the Basis is stored as a quaternion and not a full Matrix- the cost of the arithmetic operations to expand it back into the original matrix form is far less
        //than the cost of loading all the extra lanes of data when scaled up to many cores.
        public QuaternionWide SurfaceBasis;
        public Vector<float> MaximumHorizontalForce;
        public Vector<float> MaximumVerticalForce;
		public Vector<float> Depth;
        public Vector2Wide TargetVelocity;
        public Vector3Wide OffsetFromCharacter;
<#if(dynamic) {#>
        public Vector3Wide OffsetFromSupport;
<#}#>
    }

    public struct <#=prefix#>CharacterMotionFunctions : I<#if(dynamic) { Write("TwoBody"); } else { Write("OneBody"); }#>ConstraintFunctions<<#=prefix#>CharacterMotionPrestep, CharacterMotionAccumulatedImpulse>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static void ComputeJacobians(in Vector3Wide offsetA, <#if (dynamic) {#>in Vector3Wide offsetB, <#}#>in QuaternionWide basisQuaternion,
            out Matrix3x3Wide basis,
            out Matrix2x3Wide horizontalAngularJacobianA, <#if (dynamic) {#>out Matrix2x3Wide horizontalAngularJacobianB,<#}#>

            out Vector3Wide verticalAngularJacobianA<#if (dynamic) {#>, out Vector3Wide verticalAngularJacobianB<#}#>)
        {
            //Both of the motion constraints are velocity motors, like tangent friction. They don't actually have a position level goal.
            //But if we did want to make such a position level goal, it could be expressed as:
            //dot(basis.X, constrainedPointOnA - constrainedPointOnB) = 0
            //dot(basis.Y, constrainedPointOnA - constrainedPointOnB) <= 0 
            //dot(basis.Z, constrainedPointOnA - constrainedPointOnB) = 0
            //Note that the Y axis, corresponding to the vertical motion constraint, is an inequality. It pulls toward the surface, but never pushes away.
            //It also has a separate maximum force and acts on an independent axis; that's why we solve it as a separate constraint.
            //To get a velocity constraint out of these position goals, differentiate with respect to time:
            //d/dt(dot(basis.X, constrainedPointOnA - constrainedPointOnB)) = dot(basis.X, d/dt(constrainedPointOnA - constrainedPointOnB))
            //                                                              = dot(basis.X, a.LinearVelocity + a.AngularVelocity x offsetToConstrainedPointOnA - b.linearVelocity - b.AngularVelocity x offsetToConstrainedPointOnB)
            //Throwing some algebra and identities at it:
            //dot(basis.X, a.LinearVelocity) + dot(basis.X, a.AngularVelocity x offsetToConstrainedPointOnA) + dot(-basis.X, b.LinearVelocity) + dot(basis.X, offsetToConstrainedPointOnB x b.AngularVelocity)
            //dot(basis.X, a.LinearVelocity) + dot(a.AngularVelocity, offsetToConstrainedPointOnA x basis.X) + dot(-basis.X, b.LinearVelocity) + dot(b.AngularVelocity, basis.X x offsetToConstrainedPointOnB)
            //The (transpose) jacobian is the transform that pulls the body velocity into constraint space- 
            //and here, we can see that we have an axis being dotted with each component of the velocity. That's gives us the jacobian for that degree of freedom.
            //The same form applies to all three axes of the basis, since they're all doing the same thing (just on different directions and with different force bounds).
            //Note that we don't explicitly output linear jacobians- they are just the axes of the basis, and the linear jacobians of B are just the negated linear jacobians of A.
            Matrix3x3Wide.CreateFromQuaternion(basisQuaternion, out basis);
            Vector3Wide.CrossWithoutOverlap(offsetA, basis.X, out horizontalAngularJacobianA.X);
            Vector3Wide.CrossWithoutOverlap(offsetA, basis.Y, out verticalAngularJacobianA);
            Vector3Wide.CrossWithoutOverlap(offsetA, basis.Z, out horizontalAngularJacobianA.Y);
<#if(dynamic) {#>
            Vector3Wide.CrossWithoutOverlap(basis.X, offsetB, out horizontalAngularJacobianB.X);
            Vector3Wide.CrossWithoutOverlap(basis.Y, offsetB, out verticalAngularJacobianB);
            Vector3Wide.CrossWithoutOverlap(basis.Z, offsetB, out horizontalAngularJacobianB.Y);
<#}#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void ApplyHorizontalImpulse(in Matrix3x3Wide basis,
            in Matrix2x3Wide angularJacobianA, <#if (dynamic) {#>in Matrix2x3Wide angularJacobianB, <#}#>in Vector2Wide constraintSpaceImpulse,
            in BodyInertiaWide inertiaA, <#if (dynamic) {#>in BodyInertiaWide inertiaB,<#}#>

            ref BodyVelocityWide velocityA<#if (dynamic) {#>, ref BodyVelocityWide velocityB<#}#>)
        {
            //Transform the constraint space impulse into world space by using the jacobian and then apply each body's inverse inertia to get the velocity change.
            Vector3Wide.Scale(basis.X, constraintSpaceImpulse.X, out var linearImpulseAX);
            Vector3Wide.Scale(basis.Z, constraintSpaceImpulse.Y, out var linearImpulseAY);
            Vector3Wide.Add(linearImpulseAX, linearImpulseAY, out var linearImpulseA);
            Vector3Wide.Scale(linearImpulseA, inertiaA.InverseMass, out var linearChangeA);
            Vector3Wide.Add(velocityA.Linear, linearChangeA, out velocityA.Linear);
<#if (dynamic) {#>
            Vector3Wide.Scale(linearImpulseA, inertiaB.InverseMass, out var negatedLinearChangeB); //Linear jacobians for B are just A's negated linear jacobians.
            Vector3Wide.Subtract(velocityB.Linear, negatedLinearChangeB, out velocityB.Linear);
<#}#>

            Matrix2x3Wide.Transform(constraintSpaceImpulse, angularJacobianA, out var angularImpulseA);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseA, inertiaA.InverseInertiaTensor, out var angularChangeA);
            Vector3Wide.Add(velocityA.Angular, angularChangeA, out velocityA.Angular);
<#if (dynamic) {#>
            Matrix2x3Wide.Transform(constraintSpaceImpulse, angularJacobianB, out var angularImpulseB);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseB, inertiaB.InverseInertiaTensor, out var angularChangeB);
            Vector3Wide.Add(velocityB.Angular, angularChangeB, out velocityB.Angular);
<#}#>
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void ApplyVerticalImpulse(in Matrix3x3Wide basis,
            in Vector3Wide angularJacobianA, <#if (dynamic) {#>in Vector3Wide angularJacobianB, <#}#>in Vector<float> constraintSpaceImpulse,
            in BodyInertiaWide inertiaA, <#if (dynamic) {#>in BodyInertiaWide inertiaB,<#}#>

            ref BodyVelocityWide velocityA<#if (dynamic) {#>, ref BodyVelocityWide velocityB<#}#>)
        {
            Vector3Wide.Scale(basis.Y, constraintSpaceImpulse, out var linearImpulseA);
            Vector3Wide.Scale(linearImpulseA, inertiaA.InverseMass, out var linearChangeA);
            Vector3Wide.Add(velocityA.Linear, linearChangeA, out velocityA.Linear);
<#if (dynamic) {#>
            Vector3Wide.Scale(linearImpulseA, inertiaB.InverseMass, out var negatedLinearChangeB); //Linear jacobians for B are just A's negated linear jacobians.
            Vector3Wide.Subtract(velocityB.Linear, negatedLinearChangeB, out velocityB.Linear);
<#}#>

            Vector3Wide.Scale(angularJacobianA, constraintSpaceImpulse, out var angularImpulseA);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseA, inertiaA.InverseInertiaTensor, out var angularChangeA);
            Vector3Wide.Add(velocityA.Angular, angularChangeA, out velocityA.Angular);
<#if (dynamic) {#>
            Vector3Wide.Scale(angularJacobianB, constraintSpaceImpulse, out var angularImpulseB);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseB, inertiaB.InverseInertiaTensor, out var angularChangeB);
            Vector3Wide.Add(velocityB.Angular, angularChangeB, out velocityB.Angular);
<#}#>
        }
               

        public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, <#if(dynamic) {#>in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, <#}#>ref <#=prefix#>CharacterMotionPrestep prestep, ref CharacterMotionAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide velocityA<#if(dynamic) {#>, ref BodyVelocityWide velocityB<#}#>)
        {            
            ComputeJacobians(prestep.OffsetFromCharacter, <#if (dynamic) {#>prestep.OffsetFromSupport, <#}#>prestep.SurfaceBasis,
                out var basis, out var horizontalAngularJacobianA, <#if (dynamic) {#>out var horizontalAngularJacobianB, <#}#>out var verticalAngularJacobianA<#if (dynamic) {#>, out var verticalAngularJacobianB<#}#>);
            ApplyHorizontalImpulse(basis, horizontalAngularJacobianA, <#if (dynamic) {#>horizontalAngularJacobianB, <#}#>accumulatedImpulses.Horizontal, inertiaA, <#if (dynamic) {#>inertiaB, <#}#>ref velocityA<#if (dynamic) {#>, ref velocityB<#}#>);
            ApplyVerticalImpulse(basis, verticalAngularJacobianA, <#if (dynamic) {#>verticalAngularJacobianB, <#}#>accumulatedImpulses.Vertical, inertiaA, <#if (dynamic) {#>inertiaB, <#}#>ref velocityA<#if (dynamic) {#>, ref velocityB<#}#>);
        }
        
        public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, <#if(dynamic) {#>in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, <#}#>float dt, float inverseDt, ref <#=prefix#>CharacterMotionPrestep prestep, ref CharacterMotionAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide velocityA<#if(dynamic) {#>, ref BodyVelocityWide velocityB<#}#>)
        {            
            //The motion constraint is split into two parts: the horizontal constraint, and the vertical constraint.
            //The horizontal constraint acts almost exactly like the TangentFriction, but we'll duplicate some of the logic to keep this implementation self-contained.
            ComputeJacobians(prestep.OffsetFromCharacter, <#if (dynamic) {#>prestep.OffsetFromSupport, <#}#>prestep.SurfaceBasis,
                out var basis, out var horizontalAngularJacobianA, <#if (dynamic) {#>out var horizontalAngularJacobianB, <#}#>out var verticalAngularJacobianA<#if (dynamic) {#>, out var verticalAngularJacobianB<#}#>);

            //Compute the velocity error by projecting the body velocity into constraint space using the transposed jacobian.
            Vector2Wide horizontalLinearA;
            Vector3Wide.Dot(basis.X, velocityA.Linear, out horizontalLinearA.X);
            Vector3Wide.Dot(basis.Z, velocityA.Linear, out horizontalLinearA.Y);
            Matrix2x3Wide.TransformByTransposeWithoutOverlap(velocityA.Angular, horizontalAngularJacobianA, out var horizontalAngularA);
<#if (dynamic) {#>
            Vector2Wide negatedHorizontalLinearB;
            Vector3Wide.Dot(basis.X, velocityB.Linear, out negatedHorizontalLinearB.X);
            Vector3Wide.Dot(basis.Z, velocityB.Linear, out negatedHorizontalLinearB.Y);
            Matrix2x3Wide.TransformByTransposeWithoutOverlap(velocityB.Angular, horizontalAngularJacobianB, out var horizontalAngularB);
            Vector2Wide.Add(horizontalAngularA, horizontalAngularB, out var horizontalAngular);
            Vector2Wide.Subtract(horizontalLinearA, negatedHorizontalLinearB, out var horizontalLinear);
            Vector2Wide.Add(horizontalAngular, horizontalLinear, out var horizontalVelocity);
<#} else {#>
            Vector2Wide.Add(horizontalLinearA, horizontalAngularA, out var horizontalVelocity);
<#}#>

            //I'll omit the details of where this comes from, but you can check out the other constraints or the sorta-tutorial Inequality1DOF constraint to explain the details,
            //plus some other references. The idea is that we need a way to transform the constraint space velocity (that we get from transforming body velocities
            //by the transpose jacobian) into a corrective impulse for the solver iterations. That corrective impulse is then used to update the velocities on each iteration execution.
            //This transform is the 'effective mass', representing the mass felt by the constraint in its local space.
            //In concept, this constraint is actually two separate constraints solved iteratively, so we have two separate such effective mass transforms.
            Symmetric3x3Wide.MatrixSandwich(horizontalAngularJacobianA, inertiaA.InverseInertiaTensor, out var <#=dynamic ? "horizontalAngularContributionA" : "inverseHorizontalEffectiveMass"#>);
<#if (dynamic) {#>
            Symmetric3x3Wide.MatrixSandwich(horizontalAngularJacobianB, inertiaB.InverseInertiaTensor, out var horizontalAngularContributionB);
            Symmetric2x2Wide.Add(horizontalAngularContributionA, horizontalAngularContributionB, out var inverseHorizontalEffectiveMass);
<#}#>
            //The linear jacobians are unit length vectors, so J * M^-1 * JT is just M^-1.
<#if (dynamic) {#>
            var linearContribution = inertiaA.InverseMass + inertiaB.InverseMass;
<#}#>
            inverseHorizontalEffectiveMass.XX += <#=dynamic ? "linearContribution" : "inertiaA.InverseMass"#>;
            inverseHorizontalEffectiveMass.YY += <#=dynamic ? "linearContribution" : "inertiaA.InverseMass"#>;
            Symmetric2x2Wide.InvertWithoutOverlap(inverseHorizontalEffectiveMass, out var horizontalEffectiveMass);

            Vector2Wide horizontalConstraintSpaceVelocityChange;
            horizontalConstraintSpaceVelocityChange.X = prestep.TargetVelocity.X - horizontalVelocity.X;
            //The surface basis's Z axis points in the opposite direction to the view direction, so negate the target velocity along the Z axis to point it in the expected direction.
            horizontalConstraintSpaceVelocityChange.Y = -prestep.TargetVelocity.Y - horizontalVelocity.Y;
            Symmetric2x2Wide.TransformWithoutOverlap(horizontalConstraintSpaceVelocityChange, horizontalEffectiveMass, out var horizontalCorrectiveImpulse);

            //Limit the force applied by the horizontal motion constraint. Note that this clamps the *accumulated* impulse applied this time step, not just this one iterations' value.
            var previousHorizontalAccumulatedImpulse = accumulatedImpulses.Horizontal;
            Vector2Wide.Add(accumulatedImpulses.Horizontal, horizontalCorrectiveImpulse, out accumulatedImpulses.Horizontal);
            Vector2Wide.Length(accumulatedImpulses.Horizontal, out var horizontalImpulseMagnitude);
            //Note division by zero guard.
            var dtWide = new Vector<float>(dt);
            var maximumHorizontalImpulse = prestep.MaximumHorizontalForce * dtWide;
            var scale = Vector.Min(Vector<float>.One, maximumHorizontalImpulse / Vector.Max(new Vector<float>(1e-16f), horizontalImpulseMagnitude));
            Vector2Wide.Scale(accumulatedImpulses.Horizontal, scale, out accumulatedImpulses.Horizontal);
            Vector2Wide.Subtract(accumulatedImpulses.Horizontal, previousHorizontalAccumulatedImpulse, out horizontalCorrectiveImpulse);

            ApplyHorizontalImpulse(basis, horizontalAngularJacobianA, <#if (dynamic) {#>horizontalAngularJacobianB, <#}#>horizontalCorrectiveImpulse, inertiaA, <#if (dynamic) {#>inertiaB, <#}#>ref velocityA<#if (dynamic) {#>, ref velocityB<#}#>);

            //Same thing for the vertical constraint.
            Vector3Wide.Dot(basis.Y, velocityA.Linear, out var verticalLinearA);
            Vector3Wide.Dot(velocityA.Angular, verticalAngularJacobianA, out var verticalAngularA);
<#if (dynamic) {#>
            Vector3Wide.Dot(basis.Y, velocityB.Linear, out var negatedVerticalLinearB);
            Vector3Wide.Dot(velocityB.Angular, verticalAngularJacobianB, out var verticalAngularB);
<#}#>
			//If the character is deeply penetrating, the vertical motion constraint will allow some separating velocity- just enough for one frame of integration to reach zero depth.
			var verticalBiasVelocity = Vector.Max(Vector<float>.Zero, prestep.Depth * inverseDt);

            //The vertical constraint just targets zero velocity, but does not attempt to fight any velocity which would merely push the character out of penetration.
            //Note that many characters will just have zero inverse inertia tensors to prevent them from rotating, so this could be optimized.
            //We don't take advantage of this optimization for simplicity, and so that you could use this constraint unchanged in a simulation
            //where the orientation is instead controlled by some other constraint or torque- imagine a game with gravity that points in different directions.
            Symmetric3x3Wide.VectorSandwich(verticalAngularJacobianA, inertiaA.InverseInertiaTensor, out var verticalAngularContributionA);
<#if (dynamic) {#>
            Symmetric3x3Wide.VectorSandwich(verticalAngularJacobianB, inertiaB.InverseInertiaTensor, out var verticalAngularContributionB);
<#}#>
            var inverseVerticalEffectiveMass = verticalAngularContributionA + <#=dynamic ? "verticalAngularContributionB + linearContribution" : "inertiaA.InverseMass"#>;
            var verticalCorrectiveImpulse = (verticalBiasVelocity - verticalLinearA<#if (dynamic) {#> + negatedVerticalLinearB<#}#> - verticalAngularA<#if (dynamic) {#> - verticalAngularB<#}#>) / inverseVerticalEffectiveMass;

            //Clamp the vertical constraint's impulse, but note that this is a bit different than above- the vertical constraint is not allowed to *push*, so there's an extra bound at zero.
            var previousVerticalAccumulatedImpulse = accumulatedImpulses.Vertical;
            var maximumVerticalImpulse = prestep.MaximumVerticalForce * dtWide;
            accumulatedImpulses.Vertical = Vector.Min(Vector<float>.Zero, Vector.Max(accumulatedImpulses.Vertical + verticalCorrectiveImpulse, -maximumVerticalImpulse));
            verticalCorrectiveImpulse = accumulatedImpulses.Vertical - previousVerticalAccumulatedImpulse;

            ApplyVerticalImpulse(basis, verticalAngularJacobianA, <#if (dynamic) {#>verticalAngularJacobianB, <#}#>verticalCorrectiveImpulse, inertiaA, <#if (dynamic) {#>inertiaB, <#}#>ref velocityA<#if (dynamic) {#>, ref velocityB<#}#>);
        }

        
        public static bool RequiresIncrementalSubstepUpdates => true;
        public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocityA, <#if(dynamic){#>in BodyVelocityWide velocityB, <#}#>ref <#=prefix#>CharacterMotionPrestep prestep)
        {
            //Since collision detection doesn't run for every substep, we approximate the change in depth for the vertical motion constraint by integrating the velocity along the support normal.
            //This is pretty subtle. If you disable it entirely (return false from "RequiresIncrementalSubstepUpdates" above), you might not even notice.
            //If you disable the vertical motion constraint, then it can definitely be disabled.

            //Any movement of the character or its support along N results in a change in the vertical motion constraint's perception of depth.
            //estimatedPenetrationDepthChange = dot(normal, velocityDtA.Linear + velocityDtA.Angular x contactOffsetA) - dot(normal, velocityDtB.Linear + velocityDtB.Angular x contactOffsetB)
            Vector3Wide.CrossWithoutOverlap(velocityA.Angular, prestep.OffsetFromCharacter, out var wxra);
            Vector3Wide.Add(wxra, velocityA.Linear, out var contactVelocityA);

            var normal = QuaternionWide.TransformUnitY(prestep.SurfaceBasis);
<#if (dynamic) {#>
            Vector3Wide.CrossWithoutOverlap(velocityB.Angular, prestep.OffsetFromSupport, out var wxrb);
            Vector3Wide.Add(wxrb, velocityB.Linear, out var contactVelocityB);
            Vector3Wide.Subtract(contactVelocityA, contactVelocityB, out var contactVelocityDifference);
            Vector3Wide.Dot(normal, contactVelocityDifference, out var estimatedDepthChangeVelocity);
<#} else {#>
            Vector3Wide.Dot(normal, contactVelocityA, out var estimatedDepthChangeVelocity);
<#}#>
            prestep.Depth -= estimatedDepthChangeVelocity * dt;
        }
    }

    //Each constraint type has its own 'type processor'- it acts as the outer loop that handles all the common logic across batches of constraints and invokes
    //the per-constraint logic as needed. The CharacterMotionFunctions type provides the actual implementation.
    public class <#=prefix#>CharacterMotionTypeProcessor : <#=dynamic ? "Two" : "One"#>BodyTypeProcessor<<#=prefix#>CharacterMotionPrestep, CharacterMotionAccumulatedImpulse, <#=prefix#>CharacterMotionFunctions, AccessAll, AccessAll<#=dynamic ? (", AccessAll, AccessAll") : ""#>>
    {
        /// <summary>
        /// Simulation-wide unique id for the character motion constraint. Every type has needs a unique compile time id; this is a little bit annoying to guarantee given that there is no central
        /// registry of all types that can exist (custom ones, like this one, can always be created), but having it be constant helps simplify and optimize its internal usage.
        /// </summary>
        public const int BatchTypeId = <#=dynamic ? "51" : "50"#>;
    }
<#}#>
}