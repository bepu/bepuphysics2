<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>What is continuous collision detection? | Bepu Docs </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="What is continuous collision detection? | Bepu Docs ">
      
      
      <link rel="icon" href="favicon.ico">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="docs/toc.html">
      
      <meta name="docfx:rel" content="">
      
      
      <meta name="docfx:docurl" content="https://github.com/bepu/bepuphysics2/blob/master/Documentation/ContinuousCollisionDetection.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="images/bepuphysicslogo256.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="what-is-continuous-collision-detection">What is continuous collision detection?</h1>

<p>Continuous collision detection is a family of techniques that try to stop bodies from tunneling into (or through) each other at high velocities. Generating normal contact constraints at discrete points in time will tend to miss such fast moving collisions or respond to them too late.</p>
<p align="center"><img src="images/ContinuousCollisionDetection/ccd.png"></p>
<p>In bepuphysics2, continuous collision detection is handled mostly through speculative contacts. When those aren't sufficient, the library offers a mode that performs sweep testing to find a time of impact.</p>
<p>See the <a 
        $match = $args[0]
        $originalLink = $args[0].Groups[1].Value
        # Remove the "../" prefix for the GitHub URL
        $relativePath = $originalLink -replace '^\.\.\/', ''
        "href=`"$repoUrl/$relativePath`""
    >ContinuousCollisionDetectionDemo</a> for more information about the topics covered here.</p>
<h1 id="whats-a-speculative-contact">What's a speculative contact?</h1>
<p>Speculative contacts are contacts with negative depth. They're still solved, but they don't apply any forces unless the velocity is high enough that the involved collidables are expected to come into contact within the next frame.</p>
<p>The speculative <em>margin</em> is the maximum distance at which a collision pair will generate speculative contacts. Bodies have configurable minimum and maximum speculative margins. The speculative margin for a body is determined from the body's velocity magnitude clamped by the specified minimum and maximum bounds. The <em>effective</em> speculative margin for a pair of bodies is the sum of both bodies' margins. Statics do not contribute anything to a pair's effective margin; they cannot move.</p>
<p align="center"><img src="images/ContinuousCollisionDetection/speculativeContact.png"></p>
<p>The ball is heading towards the ground with a high enough velocity that the velocity expanded bounding box intersects the ground's bounding box. Similarly, since the collidables in this picture are configured to have an unlimited speculative margin, a speculative contact is created. The solver will detect and push back the part of velocity which would result in penetration. In the next frame, the ball and ground are in contact.</p>
<h1 id="do-i-need-to-care-about-speculative-margins">Do I need to care about speculative margins?</h1>
<p>Most of the time, you don't. Consider a body created by just specifying the collision shape like so:</p>
<pre><code class="lang-cs">var dynamicBoxShape = new Box(1, 1, 1);
Simulation.Bodies.Add(BodyDescription.CreateDynamic(
    new Vector3(10, 5, 0), dynamicBoxShape.ComputeInertia(1), Simulation.Shapes.Add(dynamicBoxShape), 0.01f));
</code></pre>
<p>This creates a <code>CollidableDescription</code> from the <code>TypedIndex</code> returned by <code>Simulation.Shapes.Add</code>. When no other information is specified, a <code>CollidableDescription</code> defaults to a <code>ContinuousDetection</code> mode of <code>ContinuousDetection.Passive</code>. See the later section for more details, but the short version is that:</p>
<ol>
<li>The bounding box is expanded by the whole velocity of the body, if the collidable is associated with a body.</li>
<li>The maximum speculative margin is <code>float.MaxValue</code>. In other words, there's no upper limit.</li>
<li>No sweep tests are used. Contacts are simply created from closest features.</li>
</ol>
<p>Taken together, this makes most stuff just work. Performance stays high since speculative contacts only get created if the velocity is high enough to warrant them, and high velocity collisions tend to have robust behavior since speculative contacts get generated. For most use cases, sticking with the default is a high performance and high quality option.</p>
<p>But there are cases where further tuning can be helpful. Including spooky ghost cases.</p>
<h1 id="what-are-ghost-collisions">What are ghost collisions?</h1>
<p>In the solver, a contact constraint (speculative or not) acts like a plane. As far as the solver is concerned, the contact surface has unlimited horizontal extent. This is a perfectly fine approximation when the contacts are created at a reasonable location, but it can fail when objects are moving very quickly past each other.</p>
<p align="center"><img src="images/ContinuousCollisionDetection/ghostCollision.png"></p>
<p>The ball smacks into the plane created by the speculative contact, sending the ball flying off to the side. That's a ghost collision.</p>
<p>You can mitigate ghost collisions by either using a higher <code>Simulation.Timestep</code> rate or by shrinking the maximum speculative margin on the involved bodies. To shrink the margin, instead of passing in just the shape index as your <code>CollidableDescription</code>, provide the <code>BodyDescription</code> a full <code>CollidableDescription</code> like so:</p>
<pre><code class="lang-cs">var dynamicBoxShape = new Box(1, 1, 1);
Simulation.Bodies.Add(BodyDescription.CreateDynamic(new Vector3(10, 5, 0), dynamicBoxShape.ComputeInertia(1), 
    new CollidableDescription(Simulation.Shapes.Add(dynamicBoxShape), 1, ContinuousDetection.Passive), 0.01f));
</code></pre>
<p>This still uses a 'passive' continuous collision detection mode (explained in a couple of sections) like the default, but limits the speculative margin for the body to between 0 and 1. Even if it's moving much faster than 1 unit per frame, no speculative contacts will be created at a greater distance than 1.</p>
<p align="center"><img src="images/ContinuousCollisionDetection/smallMarginNoGhostCollision.png"></p>
<p>Using a smaller maximum speculative margin means that you can miss high velocity non-ghost collisions, though:</p>
<p align="center"><img src="images/ContinuousCollisionDetection/smallMarginNoCollision.png"></p>
<h1 id="what-about-swept-continuous-collision-detection">What about swept continuous collision detection?</h1>
<p>Specifying <code>ContinuousDetection.Continuous</code> in the <code>CollidableDescription</code> means that pairs involving the collidable will use sweep-tested collision detection. That is, rather than computing contacts based on where the bodies are as of the last frame, a sweep test will determine where the bodies are likely to be <em>at the time of impact</em> during this frame. Contacts are then created at that time of impact.</p>
<p>This avoids almost all ghost collisions, since bodies passing each other at high speed will still be correctly detected as having no impact.</p>
<p>Swept testing can miss <em>secondary</em> contacts that large-margin speculative contacts wouldn't, though. But you can combine both! Speculative contacts work with sweep testing; they are not mutually exclusive. To demonstrate this, consider the configuration options for the <code>Continuous</code> mode.</p>
<p>The first parameter is a <code>minimumSweepTimestep</code>. While the sweep test uses a fancy algorithm that narrows the time of possible impact very rapidly with each step of execution, you can allow it to run faster by specifying a larger <code>minimumSweepTimestep</code>. It's effectively your maximum desired temporal resolution. If you don't care about collisions that last less than a millisecond (and your simulated units of time are seconds), then a <code>minimumSweepTimestep</code> of <code>1e-3f</code> ensures that the search always makes at least that much progress in a single step.</p>
<p>You can also speed up the search by increasing the <code>sweepConvergenceThreshold</code>. The search algorithm works by narrowing an interval of possible collision step by step; if that interval becomes smaller than the convergence threshold (again in units of time), the search will stop.</p>
<p>By default, both of these values are 1e-3f. Increasing them will make the search faster, but result in larger error in the final time of impact estimate. But that's fine, because speculative margins still exist!</p>
<p align="center"><img src="images/ContinuousCollisionDetection/smallMarginSweepCollision.png"></p>
<p>In the above picture, the sweep was configured such that it left a pretty noticable error in the time of impact, but it's still well within the speculative margin. While the speculative margin would have been too small to detect contacts had the test been performed at the T = 0 location, it finds appropriate contacts at T = 0.28. The goal is to find a rough time <em>close</em> to the time of impact such that the speculative contacts created by narrow phase testing won't cause ghost collisions. That's a pretty forgiving problem.</p>
<p>Overall, using <code>Continuous</code> will be pretty fast since it only uses sweeps when the velocity in a given pair is high enough to warrant it. If the relative velocity magnitude is below the pair's effective speculative margin, no sweep will be used. Of course, when the sweep test does run, it's not completely free, so prefer the simpler modes if they do what you want. Especially for really complicated compound shapes or meshes. (And preferably, don't have really complicated dynamic compounds or meshes.)</p>
<h1 id="what-other-configuration-options-exist">What other configuration options exist?</h1>
<p>There are three continuous collision detection modes:</p>
<ol>
<li><code>Discrete</code>: No sweep tests are performed. Default speculative contact generation will occur within the speculative margin. The collidable's bounding box will not be expanded by velocity beyond the speculative margin. This is the cheapest mode when the maximum speculative margin is small, since more potential collision pairs are filtered out by the smaller bounding box. If a <code>Discrete</code> mode collidable is moving quickly and the maximum speculative margin is limited, the fact that its bounding box is not expanded may cause it to miss a collision with another collidable even if that collidable is <code>Passive</code> or <code>Continuous</code>.</li>
<li><code>Passive</code>: No sweep tests are performed. Default speculative contact generation will occur within the speculative margin. The collidable's bounding box <em>will</em> be expanded by velocity without being limited by the speculative margin.This is useful when a collidable may move quickly and does not itself require continuous detection, but there exist other collidables with continuous modes that should avoid missing collisions.</li>
<li><code>Continuous</code>: Collision detection will start with a sweep test to identify a likely time of impact. Speculative contacts will be generated for the predicted collision. The collidable's bounding box <em>will</em> be expanded by velocity without being limited by the speculative margin. This mode can do well with high velocity motion and very few ghost collisions. With restricted maximum speculative margins, this mode can miss secondary collisions that would have occurred due to the primary impact's velocity change.</li>
</ol>
<p>Note that, if the maximum speculative margin is set to <code>float.MaxValue</code>, there's no difference between <code>Discrete</code> and <code>Passive</code> since the bounding box will get expanded either way.</p>
<p>You can also set the <em>minimum</em> speculative margin to a nonzero value, though this is rarely useful. The <em>effective</em> speculative margin used in a pair is based on sum of each involved body's speculative margin. If bodies aren't moving, the speculative margins will tend to be very small. Setting a nonzero minimum could make sense if you expect there to be a lot of velocity introduced in the middle of a timestep (perhaps by other constraints) that make the velocity-estimated effective speculative margin insufficient. Usually, though, just leave it at zero.</p>
<p>Sometimes, it can be useful to limit the maximum speculative margin to reduce the number of constraints that get generated. Perhaps you have a giant building that's collapsing and tens of thousands of bodies are moving rapidly in close proximity- that'll generate a lot of speculative contacts, and occasionally missing a collision won't matter much. You could probably get a noticeable speed boost by reducing the maximum margin on the building chunks to a small nonzero value with no noticeable impact on quality.</p>
<h1 id="do-speculative-margins-have-any-other-surprising-side-effects">Do speculative margins have any other surprising side effects?</h1>
<p>Speculative contacts are mostly incompatible with the traditional approach to bounciness- a coefficient of restitution which sets an opposing velocity goal along a contact normal proportional to the incoming velocity. That's why you won't find a 0 to 1 <code>CoefficientOfRestitution</code> anywhere in the library.</p>
<p>Instead, all contacts are springs. In <code>INarrowPhaseCallbacks.ConfigureContactManifold</code> you can customize a pair's  <code>PairMaterialProperties</code> which include a <code>SpringSettings</code> and <code>MaximumRecoveryVelocity</code>. Using a sufficiently high <code>MaximumRecoveryVelocity</code> and reducing the <code>SpringSettings.DampingRatio</code> to 0 will minimize the amount of energy damped out during a bounce. There is a bit complexity here- the <code>Frequency</code> must be low enough that the simulation can actually represent it. If the contact is trying to make a bounce happen at 240hz, but the integrator timestep is only 60hz, the unrepresentable motion will get damped out and the body won't bounce as much.</p>
<p>For more information, see the <a 
        $match = $args[0]
        $originalLink = $args[0].Groups[1].Value
        # Remove the "../" prefix for the GitHub URL
        $relativePath = $originalLink -replace '^\.\.\/', ''
        "href=`"$repoUrl/$relativePath`""
    >BouncinessDemo</a>.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/bepu/bepuphysics2/blob/master/Documentation/ContinuousCollisionDetection.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>

