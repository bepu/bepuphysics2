{
  "Building.html": {
    "href": "Building.html",
    "title": "Building | Bepu Docs",
    "keywords": "Building Library The easiest way to build the library is using the latest version of Visual Studio with the .NET desktop development workload installed to open and build the Library.sln. The library tends to use the latest C# language features. At the time of writing, it requires C# 9.0. BepuPhysics.csproj uses T4 templates for code generation in a few places. If changes are made to the templates, you'll need a build pipeline that can process them (like Visual Studio). The repository contains the original generated .cs files, so if no changes are made, the templates do not need to be evaluated. The libraries target .NET 6. Demos Demos.sln contains all the projects necessary to build and run the demos application. The default demo renderer uses DX11, and the content pipeline's shader compiler requires the Windows SDK. There is also a Demos.GL.sln that uses OpenGL and should run on other platforms. The demos can be run from the command line (in the repo root directory) with dotnet run --project Demos/Demos.csproj -c Release or dotnet run --project Demos.GL/Demos.csproj -c Release. The demos content pipeline uses freetype. On windows, the freetype.dll is included. When built elsewhere, the build will attempt to pull the dependency out of /usr/lib. If you try to build on windows and see an error that says: Content build failed: Unable to load DLL 'freetype6' or one of its dependencies: The specified module could not be found. (0x8007007E) then it's likely that freetype version used by the content builder needs the VC++ 2013 redistributable to be installed. The demos applications target .NET 6. Build Configurations The library has the usual Debug and Release build configurations, but also has ReleaseNoProfiling. ReleaseNoProfiling removes the library's profiling functionality; any attempt to request profiling data will just return zeroes. For production use, Release or ReleaseNoProfiling is recommended. Compilation Symbols Profiling features are enabled by including the PROFILE compilation symbol for BepuPhysics.csproj. Some extra checks for data validity can be enabled with the CHECKMATH compilation symbol for BepuPhysics.csproj and BepuUtilities.csproj. LEAKDEBUG forces the BufferPool to track extra data about allocations. It comes with extremely high overhead, but can be useful for narrowing down the source of memory leaks and other similar bugs. LEAKDEBUG will only work if DEBUG is also defined. Runtime The library makes heavy use of SIMD intrinsics through System.Numerics.Vectors and System.Runtime.Intrinsics. Good performance requires a IL to native assembly compiler which is aware of these intrinsics. Right now, that means something like CoreCLR's RyuJIT. Other runtimes may not support the intrinsics and may suffer massive slowdowns- sometimes 10 to 100 times slower, if they run at all. Performance scales up with higher SIMD machine widths. Machines with full rate AVX2 will tend to significantly outperform SSE-limited machines."
  },
  "ContinuousCollisionDetection.html": {
    "href": "ContinuousCollisionDetection.html",
    "title": "What is continuous collision detection? | Bepu Docs",
    "keywords": "What is continuous collision detection? Continuous collision detection is a family of techniques that try to stop bodies from tunneling into (or through) each other at high velocities. Generating normal contact constraints at discrete points in time will tend to miss such fast moving collisions or respond to them too late. In bepuphysics2, continuous collision detection is handled mostly through speculative contacts. When those aren't sufficient, the library offers a mode that performs sweep testing to find a time of impact. See the ContinuousCollisionDetectionDemo for more information about the topics covered here. What's a speculative contact? Speculative contacts are contacts with negative depth. They're still solved, but they don't apply any forces unless the velocity is high enough that the involved collidables are expected to come into contact within the next frame. The speculative margin is the maximum distance at which a collision pair will generate speculative contacts. Bodies have configurable minimum and maximum speculative margins. The speculative margin for a body is determined from the body's velocity magnitude clamped by the specified minimum and maximum bounds. The effective speculative margin for a pair of bodies is the sum of both bodies' margins. Statics do not contribute anything to a pair's effective margin; they cannot move. The ball is heading towards the ground with a high enough velocity that the velocity expanded bounding box intersects the ground's bounding box. Similarly, since the collidables in this picture are configured to have an unlimited speculative margin, a speculative contact is created. The solver will detect and push back the part of velocity which would result in penetration. In the next frame, the ball and ground are in contact. Do I need to care about speculative margins? Most of the time, you don't. Consider a body created by just specifying the collision shape like so: var dynamicBoxShape = new Box(1, 1, 1); Simulation.Bodies.Add(BodyDescription.CreateDynamic( new Vector3(10, 5, 0), dynamicBoxShape.ComputeInertia(1), Simulation.Shapes.Add(dynamicBoxShape), 0.01f)); This creates a CollidableDescription from the TypedIndex returned by Simulation.Shapes.Add. When no other information is specified, a CollidableDescription defaults to a ContinuousDetection mode of ContinuousDetection.Passive. See the later section for more details, but the short version is that: The bounding box is expanded by the whole velocity of the body, if the collidable is associated with a body. The maximum speculative margin is float.MaxValue. In other words, there's no upper limit. No sweep tests are used. Contacts are simply created from closest features. Taken together, this makes most stuff just work. Performance stays high since speculative contacts only get created if the velocity is high enough to warrant them, and high velocity collisions tend to have robust behavior since speculative contacts get generated. For most use cases, sticking with the default is a high performance and high quality option. But there are cases where further tuning can be helpful. Including spooky ghost cases. What are ghost collisions? In the solver, a contact constraint (speculative or not) acts like a plane. As far as the solver is concerned, the contact surface has unlimited horizontal extent. This is a perfectly fine approximation when the contacts are created at a reasonable location, but it can fail when objects are moving very quickly past each other. The ball smacks into the plane created by the speculative contact, sending the ball flying off to the side. That's a ghost collision. You can mitigate ghost collisions by either using a higher Simulation.Timestep rate or by shrinking the maximum speculative margin on the involved bodies. To shrink the margin, instead of passing in just the shape index as your CollidableDescription, provide the BodyDescription a full CollidableDescription like so: var dynamicBoxShape = new Box(1, 1, 1); Simulation.Bodies.Add(BodyDescription.CreateDynamic(new Vector3(10, 5, 0), dynamicBoxShape.ComputeInertia(1), new CollidableDescription(Simulation.Shapes.Add(dynamicBoxShape), 1, ContinuousDetection.Passive), 0.01f)); This still uses a 'passive' continuous collision detection mode (explained in a couple of sections) like the default, but limits the speculative margin for the body to between 0 and 1. Even if it's moving much faster than 1 unit per frame, no speculative contacts will be created at a greater distance than 1. Using a smaller maximum speculative margin means that you can miss high velocity non-ghost collisions, though: What about swept continuous collision detection? Specifying ContinuousDetection.Continuous in the CollidableDescription means that pairs involving the collidable will use sweep-tested collision detection. That is, rather than computing contacts based on where the bodies are as of the last frame, a sweep test will determine where the bodies are likely to be at the time of impact during this frame. Contacts are then created at that time of impact. This avoids almost all ghost collisions, since bodies passing each other at high speed will still be correctly detected as having no impact. Swept testing can miss secondary contacts that large-margin speculative contacts wouldn't, though. But you can combine both! Speculative contacts work with sweep testing; they are not mutually exclusive. To demonstrate this, consider the configuration options for the Continuous mode. The first parameter is a minimumSweepTimestep. While the sweep test uses a fancy algorithm that narrows the time of possible impact very rapidly with each step of execution, you can allow it to run faster by specifying a larger minimumSweepTimestep. It's effectively your maximum desired temporal resolution. If you don't care about collisions that last less than a millisecond (and your simulated units of time are seconds), then a minimumSweepTimestep of 1e-3f ensures that the search always makes at least that much progress in a single step. You can also speed up the search by increasing the sweepConvergenceThreshold. The search algorithm works by narrowing an interval of possible collision step by step; if that interval becomes smaller than the convergence threshold (again in units of time), the search will stop. By default, both of these values are 1e-3f. Increasing them will make the search faster, but result in larger error in the final time of impact estimate. But that's fine, because speculative margins still exist! In the above picture, the sweep was configured such that it left a pretty noticable error in the time of impact, but it's still well within the speculative margin. While the speculative margin would have been too small to detect contacts had the test been performed at the T = 0 location, it finds appropriate contacts at T = 0.28. The goal is to find a rough time close to the time of impact such that the speculative contacts created by narrow phase testing won't cause ghost collisions. That's a pretty forgiving problem. Overall, using Continuous will be pretty fast since it only uses sweeps when the velocity in a given pair is high enough to warrant it. If the relative velocity magnitude is below the pair's effective speculative margin, no sweep will be used. Of course, when the sweep test does run, it's not completely free, so prefer the simpler modes if they do what you want. Especially for really complicated compound shapes or meshes. (And preferably, don't have really complicated dynamic compounds or meshes.) What other configuration options exist? There are three continuous collision detection modes: Discrete: No sweep tests are performed. Default speculative contact generation will occur within the speculative margin. The collidable's bounding box will not be expanded by velocity beyond the speculative margin. This is the cheapest mode when the maximum speculative margin is small, since more potential collision pairs are filtered out by the smaller bounding box. If a Discrete mode collidable is moving quickly and the maximum speculative margin is limited, the fact that its bounding box is not expanded may cause it to miss a collision with another collidable even if that collidable is Passive or Continuous. Passive: No sweep tests are performed. Default speculative contact generation will occur within the speculative margin. The collidable's bounding box will be expanded by velocity without being limited by the speculative margin.This is useful when a collidable may move quickly and does not itself require continuous detection, but there exist other collidables with continuous modes that should avoid missing collisions. Continuous: Collision detection will start with a sweep test to identify a likely time of impact. Speculative contacts will be generated for the predicted collision. The collidable's bounding box will be expanded by velocity without being limited by the speculative margin. This mode can do well with high velocity motion and very few ghost collisions. With restricted maximum speculative margins, this mode can miss secondary collisions that would have occurred due to the primary impact's velocity change. Note that, if the maximum speculative margin is set to float.MaxValue, there's no difference between Discrete and Passive since the bounding box will get expanded either way. You can also set the minimum speculative margin to a nonzero value, though this is rarely useful. The effective speculative margin used in a pair is based on sum of each involved body's speculative margin. If bodies aren't moving, the speculative margins will tend to be very small. Setting a nonzero minimum could make sense if you expect there to be a lot of velocity introduced in the middle of a timestep (perhaps by other constraints) that make the velocity-estimated effective speculative margin insufficient. Usually, though, just leave it at zero. Sometimes, it can be useful to limit the maximum speculative margin to reduce the number of constraints that get generated. Perhaps you have a giant building that's collapsing and tens of thousands of bodies are moving rapidly in close proximity- that'll generate a lot of speculative contacts, and occasionally missing a collision won't matter much. You could probably get a noticeable speed boost by reducing the maximum margin on the building chunks to a small nonzero value with no noticeable impact on quality. Do speculative margins have any other surprising side effects? Speculative contacts are mostly incompatible with the traditional approach to bounciness- a coefficient of restitution which sets an opposing velocity goal along a contact normal proportional to the incoming velocity. That's why you won't find a 0 to 1 CoefficientOfRestitution anywhere in the library. Instead, all contacts are springs. In INarrowPhaseCallbacks.ConfigureContactManifold you can customize a pair's PairMaterialProperties which include a SpringSettings and MaximumRecoveryVelocity. Using a sufficiently high MaximumRecoveryVelocity and reducing the SpringSettings.DampingRatio to 0 will minimize the amount of energy damped out during a bounce. There is a bit complexity here- the Frequency must be low enough that the simulation can actually represent it. If the contact is trying to make a bounce happen at 240hz, but the integrator timestep is only 60hz, the unrepresentable motion will get damped out and the body won't bounce as much. For more information, see the BouncinessDemo."
  },
  "GettingStarted.html": {
    "href": "GettingStarted.html",
    "title": "Getting Started | Bepu Docs",
    "keywords": "Getting Started The best place to start is the demos in the Demos.sln solution. Jump into one in the Demos/Demos/ folder and start playing around. The Demo type is a very simple helper class that contains a few properties and functions used across all demos. It creates a BufferPool and ThreadDispatcher and provides a basic Update implementation that just calls Simulation.Timestep once with a fixed duration. A couple of alternative timestep examples are also provided in the comments. Each Demo implementation creates its own Simulation. Some Demo types have extra input or rendering logic; input and rendering are fully separate from the actual physics library. The SimpleSelfContainedDemo shows how to set up a simple simulation without relying on any of the Demos-provided infrastructure. Building a Simulation Simulation.Create builds a Simulation instance, but has some unusual callback parameters- they take the form of interface-implementing structs. The TNarrowPhaseCallbacks parameter handles collision-related callbacks, giving the user a way to control collision filtering, contact manifolds, materials, and a path to implementing things like collision events. TPoseIntegratorCallbacks provides control over per-body velocity integration behavior. It's typically used for implementing gravity or damping. Examples: DemoCallbacks shows the frequently used callbacks, including damping and unidirectional gravity and a basic passthrough INarrowPhaseCallbacks. PlanetDemo shows how to create a planet-like gravity source. RagdollDemo contains a slightly more advanced INarrowPhaseCallbacks collision filtering approach based on bitfields. Used to stop connected pieces of the ragdolls from colliding. ContactEventsDemo shows one possible way to collect contact data from the INarrowPhaseCallbacks and use it to generate contact events. Note that TNarrowPhaseCallbacks and TPoseIntegratorCallbacks are required to be structs and are provided with generic parameters rather than directly as interfaces. This is because the compiler has enough knowledge (and is forced) to avoid virtual dispatch and, when appropriate, inline the callbacks. Given that many of the callbacks are called with extremely high frequency, this can add up. A similar pattern is used in many places across the engine. You can think about these as compile time delegates or closures, just with nastier syntax. SolveDescription describes how the simulation should schedule updates. You can set the number of velocity iterations and substeps that occur in each simulation timestep. For simulations with difficult constraint configurations, using more substeps can help stabilize the simulation far more cheaply than increasing velocity iterations can. For advanced use cases, you can schedule the number of velocity iterations for each substep individually. There's also a fallback batch threshold, which you can safely leave at the default value almost always- it's the number of synchronized constraint batches that the simulation will create before falling back to a special case solve when individual bodies have excessive numbers of constraints connected to them. Simulation.Create also has a couple of optional parameters: initial allocation sizes to pull from the resource pool (to avoid unnecessary resizing later), and the ITimestepper which defines the order of stage execution within the engine. The engine includes only one ITimeStepper type out of the box, which gets used if no other ITimestepper is provided: the DefaultTimestepper. It checks candidates for sleeping, computes bounding boxes, performs collision detection, solves constraints (which includes any necessary body velocity/pose integration), then does some incremental optimization work on internal data structures. There are callbacks between stages that can be hooked into. A custom ITimestepper could be provided that changes what stages execute or their order. Timestepping/updating Simulation.Timestep pushes the simulation forward by the given amount of time. If a IThreadDispatcher is provided, it is used to multithread the simulation. The Simulation does not do anything fancy internally with temporal accumulation or anything else. Each Timestep simulates exactly the amount of time specified. Examples of other timestepping strategies, like accumulating time and simulating as many timesteps of a fixed duration as necessary, are shown in Demo.Update. It is recommended that the time step duration provided to Simulation.Timestep is always the same. Wildly varying timesteps can introduce instability. One-off changes or gradual changes can work well enough, but try to avoid jumping around constantly. For varying timestep durations, Solver.ScaleAccumulatedImpulses can be used to scale the cached constraint solution by the ratio of the previous duration to the current duration. It's not free and it won't guarantee stability, but it can help. Bodies In v2, 'body' refers to a basic collidable mobile object that can be connected to constraints. To create a body, pass a BodyDescription to Simulation.Bodies.Add. It returns a handle that uniquely identifies the body for as long as it belongs to the simulation. The BodyDescription specifies the initial pose, velocity, inertia, collidable, and activity state. The BodyDescription type offers static factory functions for convenience. Creating a body with zero inverse mass and inverse inertia will create a kinematic body, a body that will not change its velocity in response to any force. (BodyDescription.CreateKinematic only differs from BodyDescription.CreateDynamic in that it provides a zeroed out BodyInertia.) A dynamic body can be given a zeroed inverse inertia tensor to lock rotation only. Individual rows can also be zeroed out to lock rotation around the related local body axes. The CollidableDescription takes a reference to a shape allocated in the Simulation.Shapes set. Shapes are allocated independently from bodies. Multiple bodies can refer to the same allocated shape. Collidables are also allowed to refer to no shape at all which can be useful for creating some constraint systems. Note that there is no internal list of BodyDescription instances, nor a single \"Body\" type anywhere. Instead, body properties are split across different buffers depending on internal memory access patterns. Further, there are multiple BodySet instances, each with their own set of buffers. These buffers are set up for efficient internal access, with the first BodySet storing all active bodies and the later sets containing inactive body data. The BodyDescription is decomposed into these separate pieces upon being added. To access an existing body's data, the body's current memory location must be looked up using the handle returned by the Add call. The BodyReference convenience type can make this a little easier by hiding the lookup process. You can get a BodyReference by indexing: Simulation.Bodies[BodyHandle]. Bodies may move around in memory during execution or when other bodies are added, removed, awoken, or slept. Holding onto the raw memory location through one of these changes may result in the pointer pointing to undefined data. The BodyReference type performs lookups on demand, and remains valid so long as the wrapped BodyHandle does. Statics Statics are similar to bodies but don't have velocity, inertia, or activity states. They're just immobile collidable shapes, ideal for level geometry. Statics are computationally cheap. Feel free to have thousands of them. To create a static object, pass a StaticDescription to Simulation.Statics.Add. Constraints Constraints can be used to control the relative motion of bodies. There are a whole bunch of them. Like bodies and statics, constraints are created by building a description and passing it to Simulation.Solver.Add. Some examples of constraints in the demos include: RagdollDemo is a... demo of ragdolls. CarDemo shows how to build a simple constraint based car (and bad AI drivers). RopeStabilityDemo shows some constraint configuration failure modes and how to fix them. NewtDemo shows how to make a squishy newt. ClothDemo shows how to make sheets of cloth with different properties. Existing raw constraint data is more difficult to access than body data. There is a similar handle->memory location lookup, but the data itself is stored a few layers deep in array-of-structures-of-arrays format for performance. Pulling data out of this representation is not very convenient, so the Solver has ApplyDescription and GetDescription for accessing constraint data. Custom descriptions can be created to access only subsets of a constraint's full data. Queries The engine supports scene-wide queries through Simulation.RayCast and Simulation.Sweep. Sweeps support both linear and angular motion for convex shapes. Both functions make use of hit handlers- IRayHitHandler and ISweepHitHandler. The handlers can filter out objects and respond to found impacts. The Grabber, RayCastingDemo and SweepDemo have some examples of these queries, plus some other more advanced cases. The broad phase acceleration structures can be directly queried by ray casts, bounding boxes, and swept bounding boxes. Memory Almost all of the internally used memory is pulled from a custom allocator working with pinned memory. Almost all stages have some form of memory management API for preallocating, compacting, or disposing resources. The Simulation has a few top-level functions to help orchestrate all the different stage allocations, including Clear, EnsureCapacity, Resize, and Dispose. Most use cases get by with the default initial allocation sizes and then Disposing upon completion. Notably, the Simulation does not have its own allocator. It relies on BufferPool instances provided by the user. All of the resource management APIs on the Simulation and its stages operate on these pools. In other words, if you're okay with just clearing the BufferPool instances that a simulation relies on and letting the GC pick up the pieces, you don't technically have to Clear or Dispose the Simulation itself. (Of course, that Simulation instance should not be used after it has had the rug pulled out from under it.) Failure to return resources to a BufferPool or to clear an unused BufferPool can cause memory leaks. Asserts and debugging Many invalid inputs and error states are left unchecked in release mode. Most error checking is performed using Debug.Assert, requiring compilation with the DEBUG symbol. Including CHECKMATH (as the Debug configuration does by default) is also helpful for tracking down NaN-explosions sometimes. The LEAKDEBUG symbol can be added to help track down BufferPool related memory leaks. It is extremely expensive, but adds deep diagnostics for every allocation. A note on design intent As the above suggests, the engine uses a lot of idioms which are historically uncommon in C#. There are value types and refs everywhere, SIMD out the wazoo, object data is split and packed into performance-optimized storage formats, APIs directly expose the underlying data, language features are abused for metaprogramming, and the engine generally lets you break stuff. In summary, it's a very low level API. The intent is to maximize performance, then expose as much as possible to let application-specific convenient abstractions be built on top. All of this puts a heavier burden on users. They must be familiar with value type semantics, new performance minded language features, pointers, and all sorts of other unusual-for-C# stuff. If you've got questions, feel free to post them in the discussions."
  },
  "PackagingAndVersioning.html": {
    "href": "PackagingAndVersioning.html",
    "title": "Packaging and Versioning | Bepu Docs",
    "keywords": "Packaging and Versioning This project does not use semantic versioning. When upgrading to a newer version, expect breaking changes. Breaking changes should be obvious and appear as compile errors. \"Sneaky\" breaking changes that significantly change behavior without a compile error will be avoided if at all possible. One notable exception to this is determinism- do not expect different versions of the library to produce identical simulation results. NuGet packages will be made available, but they will not cover all possible features. Releases are published automatically on github and nuget. The main branch should be kept in a relatively stable state; cloning the source is often a good choice. The library has a variety of conditional compilation symbols. Rather than publishing a combinatorial mess to NuGet, the expectation is that users of any conditional logic will clone the source. Given the above and the general nature of the library's API, cloning the source and referencing the project is often the best way to include the library."
  },
  "PerformanceTips.html": {
    "href": "PerformanceTips.html",
    "title": "Performance Tips | Bepu Docs",
    "keywords": "Performance Tips General -Large spikes in the time it takes to complete a timestep soon after application launch may be related to just-in-time compilation. If they become a problem, consider running a small simulation that hits all the relevant codepaths (like collision pairs and constraints) at load time. Using an ahead-of-time compilation toolchain would also work. -If spikes keep happening, and especially if the spikes arise in the solver, the operating system may be having trouble with thread oversubscription and scheduling. If one of the physics worker threads gets idled by the OS while another task runs, it'll stall the whole engine. This can cause especially nasty problems on older operating systems. In these cases, it can be helpful to reduce the number of threads used by the engine to leave room for other processing. Shape Optimization -Use simple shapes whenever possible. Spheres and capsules are fastest followed by boxes, triangles, cylinders, and finally convex hulls. While cylinders and convex hulls are not slow in an absolute sense, they can be an order of magnitude slower than spheres and capsules. The following chart shows the differences in convex collision pairs for a couple of different processors. The 4790K uses 8-wide instructions under RyuJIT, while the 3770K only uses 4-wide SIMD operations; this affects the relative performance of some pairs that are able to more fully take advantage of the greater throughput. (Note that the times are measured relative to the processor's own sphere-sphere result. In absolute terms, the 4790K dramatically outperforms the 3770K, sometimes approaching twice as fast.) The convex hulls in this test had 23 points and 42 faces. While you shouldn't be too afraid of cylinders and convex hulls (they're still pretty fast), it's hard to beat the simpler shapes. Many of the simpler pairs take less than 100 nanoseconds to evaluate. Note that cylinders and convex hulls will likely become faster in the future. -If you need to use a convex hull, use the minimum number of vertices needed to approximate the shape. The cost of hull collision detection is proportional to their complexity. -For mobile concave shapes, first make sure they really need to be concave. Whenever you can get away with a simple convex shape, do so. If there's no choice, prefer using a compound of a minimum number of simple shapes like spheres and capsules rather than convex hulls (as per the earlier tip). -If you really, definitely need a mobile mesh, especially one that needs to collide with other meshes, spend a while confirming that you really, definitely, seriously need it and there is no other option, and then use a compound of simple shapes instead. -Okay, so maybe you actually truly really seriously need an actual mobile mesh. Keep the number of triangles to the minimum necessary to approximate the desired shape, and try to keep the triangles fairly uniform in size. Long sliver-like triangles can end up with large and inefficient bounding boxes. Static meshes follow the same optimization guidelines. Don't be surprised when you run into behavioral issues associated with infinitely thin one sided triangles not colliding with each other and relatively crappy performance. -Reuse shapes when convenient. In particular, avoid creating tons of duplicate convex hulls and meshes. They are much larger than the other types. Both the required memory bandwidth and cache size can become a bottleneck during the narrow phase. -Prefer using the same shape types when convenient. The narrow phase works on batches of same-type collision pairs at a time. By using a lot of the same types, the narrow phase can get better SIMD efficiency. (This is a fairly minor effect. If you kinda want to use a cylinder for something even though you haven't used them anywhere else, don't feel too bad about it.) Solver Optimization -Try using the minimum number of iterations sufficient to retain stability. The cost of the solver stage is linear with the number of iterations, and some simulations can get by with very few. -For some simulations with very complex constraint configurations, there may be no practical number of solver iterations that can stabilize the simulation. In these cases, you may need to instead use substepping or a shorter time step duration for the entire simulation. More frequent solver execution can massively improve simulation quality, allowing you to drop velocity iteration counts massively (even to just 1 per substep). See the SubsteppingDemo for an example of substepping in action, and the Substepping documentation for more details."
  },
  "QuestionsAndAnswers.html": {
    "href": "QuestionsAndAnswers.html",
    "title": "Q&A | Bepu Docs",
    "keywords": "Q&A I'm seeing spikes in the time it takes to simulate a timestep, what's going on? If it quits happening a little while after application startup, it's probably JIT compilation. You could consider warming up the simulation so all the relevant codepaths are seen by the JIT ahead of time. You may also want to look into ahead of time compilation like NativeAOT. If it keeps happening, and the spikes are in the range of a handful of milliseconds, the operating system might be struggling with a bunch of threads competing for timeslices, resulting in stalls. In that case, try using fewer threads for the physics- leaving one free might be all it takes. See the Performance Tips for more. How can I make a convex shape rotate around a point other than its volumetric center? Other than triangles, all convex shapes are centered on their volumetric center, and there is no property in the CollidableDescription to offset a body's shape. However, you can create a Compound with just one child and give that child an offset local pose. The overhead is pretty tiny. How do I make an object that can't be moved by outside influences, like other colliding dynamic bodies, but can still have a velocity? Use a kinematic body. To create one, use BodyDescription.CreateKinematic or set the inverse mass and all components of the inverse inertia to zero in the BodyDescription passed to Simulation.Bodies.Add. Kinematic bodies have effectively infinite mass and cannot be moved by any force. You can still change their velocity directly, though. Any nonzero component in the inverse mass or inverse inertia results in a dynamic body. Be careful when using kinematics- they are both unstoppable forces and immovable objects. If a dynamic body gets caught between a kinematic body and the static environment, there's a good chance the dynamic body will get pushed out of the level! Also, if two kinematic bodies collide, a constraint will not be generated. Kinematics cannot respond to collisions, not even with other infinitely massive objects. They will simply continue to move along the path defined by their velocity. The heck is a 'speculative margin'/'speculative contact'? A way of solving for predicted collisions to stop penetration and tunneling. See the continuous collision detection documentation for more details. I made a body with zero inverse mass and nonzero inverse inertia and the simulation exploded/crashed! Why? While dynamic bodies with zero inverse mass and nonzero inverse inertia tensors are technically allowed, they require extreme care. It is possible for constraints to be configured such that there is no solution, resulting in a division by zero. NaN values will propagate through the simulation and make everything explode. To avoid the NaN-explosion, any constraint involving two bodies must be able to compute some local solution. For example, if two bodies have zero inverse mass but nonzero inverse inertia, you could create a ball socket joint that avoids issues by ensuring that the anchor offsets are nonzero. This is harder to guarantee in the general case. Consider collision constraints created between the same two bodies. If a contact is created with zero offset from the object's center to the contact position, there will be no angular contribution to the constraint. Since the inverse masses are both zero, no local solution exists and a portal to NaNland will open. Generally, avoid creating dynamic bodies with zero inverse mass unless you can absolutely guarantee that the involved constraints will never become degenerate. For example, if collisions are disabled, you don't have to worry about the automatically generated contact constraints, and you can tightly control what other constraints exist. (You can also just use a constraint to keep an object positioned in one spot rather than setting its inverse mass to zero!) How can I ensure that the results of a simulation are deterministic (given the same inputs, the simulation produces the same physical result) on a single machine? Take great care to ensure that every interaction with the physics simulation is reproduced in exactly the same order on each execution. This even includes the order of adds and removes! Assuming that all external interactions with the engine are deterministic, the simulation is deterministic on a single machine when one of two conditions is met: The simulation runs with only a single thread (that is, no IThreadDispatcher is provided to the time step function). The simulation is provided multiple threads and the Simulation.Deterministic property is set to true. The Deterministic property defaults to false. Ensuring determinism has a slight performance impact. It should be trivial for most simulations, but large and extremely chaotic simulations may take a noticeable hit. What do I do if I want determinism across different computers? Hope that they happen to have exactly the same architecture so that every single instruction produces bitwise identical results. :( If the target hardware is known to be identical (maybe a networked console game where users only play against other users of the exact same hardware), you might be fine. Sometimes, you'll even get lucky and end up with two different desktop processors that produce identical results. But, in general, the only way to guarantee cross platform determinism is to avoid generating any instructions which may differ between hardware. A common solution here is to use software floating point or fixed point rather than native floating point math. At the moment, BEPUphysics v2 does not support software floats or fixed math out of the box, and it would be a pretty enormous undertaking to port it all over without destroying performance. I may try to get something working here in the future. I can't guarantee when or if I'll get around to it, though; don't wait for me! I updated to the latest version of the physics library and simulations are producing different results than before, even though I set the Simulation.Deterministic property to true! What do? Different versions of the library are not guaranteed to produce identical simulation results. Guaranteeing cross-version determinism would constrain development to an unacceptable degree. If you need determinism of results over long periods (for example, storing game replays for later viewing), it's typically easiest to just fall back to something like storing keyframed animation. You can still use the simulation to help fill out details if you'd like- similar to a networked game receiving sparse updates from a server and filling in the details with extrapolated local simulation. There just has to be a way to correct for the gradual drift. Such a drift correcting mechanism also compensates for the differences between processor architectures, so you'd gain the ability to share the replay across different hardware as a bonus. I was trying to simulate the behavior of a spinning multitool in zero gravity and noted a CLEAR lack of the Dzhanibekov effect! By default, angular momentum is not explicitly tracked; angular velocity will remain constant during rotation without outside impulses. Momentum-conserving angular integration can be chosen by returning a different value from the IPoseIntegratorCallbacks.AngularIntegrationMode property. Gyroscopes tend to work better with ConserveMomentum, while ConserveMomentumWithGyroscopicTorque is less prone to velocity drift toward lower inertia axes. Surprises Simulating real physics is slightly difficult, so corners are cut. Lots of corners. Sometimes this results in unexpected behavior. Sometimes different physics libraries cut different corners, so the unexpected behavior differs. Sometimes, to meet certain use cases or performance requirements, the API ends up looking a little unintuitive- especially from an object oriented background. This is a list of some things that might frustrate or raise an eyebrow (and what to do about them, where applicable). This list will probably change over time. ...Where is the bounciness/restitution material property? You're not crazy- it doesn't exist! Instead, at the time of writing, there is friction, frequency, damping ratio, and maximum recovery velocity. Frequency and damping ratio can achieve some of the same effects as restitution with a bit of configuration. Check out the BouncinessDemo for an example. The reason for the lack of a traditional coefficient of restitution is speculative contacts. v1 used them too, but v2 pushes their usage much further and uses them as the primary form of continuous collision detection. Most of the problems caused by speculative contacts (like ghost contacts) have been smoothed over, but the naive implementation of velocity-flip restitution simply doesn't work with speculative contacts. Swept shape tests against the backfaces of meshes don't go through, but collisions do. What's going on? While ray and collision testing against triangles is always one sided, swept shape tests are double sided. This is pretty strange, and there isn't a secret good reason for it. The not-great reason for it is that shape sweep tests use a root finder operating on top of a distance tester subroutine to support angular motion. One sided triangles make this much more complicated, and I haven't gotten around to building an efficient dedicated implementation. This isn't a top priority for now since sweeps against the back faces of meshes should be pretty rare in practice. If you've got a use case where this addressing this inconsistency is critical, open an issue- but I can't guarantee a fix."
  },
  "StabilityTips.html": {
    "href": "StabilityTips.html",
    "title": "Simulation Quality and Stability Tips | Bepu Docs",
    "keywords": "Simulation Quality and Stability Tips Constraint Stabilization If you are observing ununsual oscillations, bouncing, or outright explosions, constraints are likely related. Most constraint-related stability issues take one of two forms: Failure to completely propagate forces through the constraint graph. Excessive constraint stiffness. Incomplete force propagation usually manifests as bouncing or mild oscillation. This is often observed in tall stacks of bodies. With insufficient iterations or timesteps, stacks can start to bounce and wiggle a bit. Generally, if you zoom in, any local pair of bodies in the stack is behaving reasonably, but tiny errors accumulate and make the whole thing dance. In other words, the solver can't converge to a solution for all the constraints at once. In this case, increasing Simulation.Solver.IterationCount or setting it to a higher value in Simulation.Create usually helps. An example of what it looks like when the solver needs more iterations: One notable pathological case for the solver is high mass ratios. Very heavy objects rigidly depending on very light objects can make it nearly impossible for the solver to converge in a reasonable number of velocity iterations. One common example of this is a wrecking ball at the end of a rope composed of a bunch of linked bodies. With constraint stiffness configured high enough to hold the wrecking ball, it's unlikely that a 60hz solver update rate and 8 velocity iterations will be sufficient to keep things stable at a 100:1 mass ratio. There are ways around this issue, though. Reducing lever arms, adjusting inertias, and adding more paths for the solver to propagate impulses through are useful tricks that can stabilize even some fairly extreme cases. Check out the RopeStabilityDemo for details. The second class of failure, excessive stiffness, is more difficult to hack away. If you configure a constraint with a frequency of 120hz and your simulation is running at 60hz, the integrator is going to have trouble representing the resulting motion. It won't always explode, but if you throw a bunch of 240hz constraints together at a 60hz solver rate, bad things are likely. If you can, avoid using a constraint frequency greater than half of your solver update rate. That is, if the solver is running at 60hz, stick to 30hz or below for your constraints' spring settings. If using very low velocity iteration counts (like 1), you may need to be more conservative with the constraint frequencies relative to the solver rate. Sometimes, though, you can't use tricks or hacks to stabilize a simulation, or you just want very stiff and stable response. Sometimes you don't have enough control over the simulation to add specific countermeasures- user generated content is rarely simulation friendly. At this point, the solver just needs to run more frequently to compensate. The obvious way to increase the solver's execution rate is to call Simulation.Timestep more frequently with a smaller dt parameter. If you can afford it, this is the highest quality option since it also performs collision detection more frequently. If you're only concerned about solver stability, then you can instead use the solver's substepping feature. When calling Simulation.Create, pass a SolveDescription with the desired number of substeps. For example, if the solver uses 4 substeps and Simulation.Timestep is called at a rate of 60hz, then the solver and integrator will actually run at 240hz. Notably, because increasing the update rate is such a powerful stabilizer, you can usually drop the number of solver velocity iterations to save some simulation time. Using higher update rates can enable the simulation of otherwise impossible mass ratios, like 1000:1, even with fairly low velocity iterations. Here's a rope connected by 240hz frequency constraints with a 1000:1 mass ratio wrecking ball at the end, showing how the number of substeps affects quality: For more examples of substepping, check out the SubsteppingDemo. For more information about substepping, see the substepping documentation. So, if you're encountering constraint instability, here are some general guidelines for debugging: First, try increasing the Simulation.Timestep update rate to a really high value (600hz or more). If the problem goes away, then it's probably related to the difficulty of the simulation and a lack of convergence and not to a configuration error. Drop back down to a normal update rate and increase the solver iteration count. If going up to 10 or 15 solver iterations fixes it, then it was likely just a mild convergence failure. If you can't identify any issues in the configuration that would make convergence more difficult than it needs to be (and there aren't any tricks available like the rope stuff described above), then using more solver iterations might just be required. If you need way more solver iterations- 30, 50, 100, or even 10000 isn't fixing it- then a higher update is likely required. This is especially true if you are observing constraint 'explosions' where bodies start flying all over the place. Try using a SolveDescription with higher substep counts. Gradually increase the number of substeps until the simulation becomes stable. To preserve performance, try also dropping the number of solver velocity iterations as you increase the substeps. Using more than 4 velocity iterations with 4+ substeps is often pointless, and using only 1 velocity iteration with substepping is often the sweet spot. If using a substepping timestepper does not fix the problem but increasing full simulation update rate does, it's possible that collision detection requires the extra temporal resolution. This is pretty rare, but it can happen when the incremental contact update used by substepping is a poor match for the true contact manifold. Some general guidelines: While many simple simulations can work fine with only 1 solver iteration, using a minimum of 2 is recommended for most simulations if you're not using substepping. Simulations with greater degrees of complexity- articulated robots, ragdolls, stacks- will often need more (or just more substeps!). The \"mass ratios\" problem: avoid making heavy objects depend on light objects. A tiny box can sit on top of a tank without any issues at all, but a tank would squish a tiny box. Larger mass ratios yield larger stability problems. If constraints are taking too many iterations to converge and the design allows it, try softening the constraints. A little bit of softness can significantly stabilize a constraint system and avoid the need for higher update rates. Avoid configuring constraints to 'fight' each other. Opposing constraints tend to require more iterations to converge, and if they're extremely rigid, it can require shorter timesteps or substepping. When tuning the SpringSettings.Frequency of constraints with one substep and multiple solver iterations, prefer values smaller than 0.5 / timeStepDuration. Higher values increase the risk of instability. If using aggressive substepping with only one velocity iteration per substep, a good initial guess for the required number of substeps is substepCount = 6 * constraintFrequency * timeStepDuration. If your simulation requires a lot of solver velocity iterations to be stable, try using substepping with lower velocity iteration counts. It might end up more stable and faster! Contact Generation While nonzero speculative margins are required for stable contact, overly large margins can sometimes cause 'ghost' contacts when objects are moving quickly relative to each other. It might look like one object is bouncing off the air a foot away from the other shape. To avoid this, use a smaller maximum speculative margin and consider explicitly enabling continuous collision detection for the shape. Prefer simpler shapes. In particular, avoid highly complex convex hulls with a bunch of faces separated by only a few degrees. The solver likes temporally coherent contacts, and excess complexity can cause the set of generated contacts to vary significantly with small rotations. Also, complicated hulls are slower!"
  },
  "Substepping.html": {
    "href": "Substepping.html",
    "title": "What's substepping? | Bepu Docs",
    "keywords": "What's substepping? Substepping integrates body velocities and positions and solves constraints more than once per call to Simulation.Timestep. For some simulations with complex constraint configurations, high stiffness, or high mass ratios, substepping is the fastest way to find a stable solution. You can configure a simulation to use substepping by passing a SolveDescription to Simulation.Create that has more than one substep. For example, to create a simulation that uses 8 substeps and 1 velocity iteration per substep: var simulation = Simulation.Create( BufferPool, new YourNarrowPhaseCallbacks(), new YourPoseIntegratorCallbacks(), new SolveDescription(velocityIterationCount: 1, substepCount: 8)); See the SubsteppingDemo for an interactive example. The RopeTwistDemo, ChainFountainDemo and BouncinessDemo also all use substepping. The stability tips documentation contains some more information about tuning. Why use it? It makes difficult constraint configurations easy for the solver. The easier things are for the solver, the faster it can go. If you have a really complex constraint graph, especially one containing high mass ratios (heavy objects depending on light objects, like a wrecking ball hanging from a rope or a tank smashing a small box) and high constraint stiffnesses, a non-substepping solver can struggle to converge to an equilibrium in a low number of velocity iterations. Further, for constraints with high stiffness (SpringSettings with Frequency values approaching or exceeding the simulation timestep frequency), even a stable equilibrium will result in damping out unrepresentable motion. A constraint that wants to oscillate at 120 hertz simply can't in a 60 hertz simulation. Substepping means running the solver and integrator multiple times for each call to Simulation.Timestep. If you take 8 substeps and call Simulation.Timestep(1f / 60f), the solver sees 8 substeps each of length 1f / 480f. Since the solver and integrator are running at 480 hertz, that 120 hertz constraint would be able to wiggle to its heart's content. In the above example, you could get similar solver stability out of simply calling Simulation.Timestep(1f / 480f) 8 times for each frame, but that would re-run collision detection 8 times too. Further, by tightly bundling execution together, the substepping solver can avoid a large amount of synchronization and memory bandwidth overhead. Overall, when it is an appropriate solution, substepping will tend to be the fastest option. How substepping fits into a timestep Each call to Simulation.Timestep(dt, ...) simulates one frame with duration equal to dt. In the DefaultTimestepper (which, as the name implies, is the ITimestepper implementation used if no other is specified) executes a frame like so: simulation.Sleep(); simulation.PredictBoundingBoxes(dt, threadDispatcher); simulation.CollisionDetection(dt, threadDispatcher); simulation.Solve(dt, threadDispatcher); simulation.IncrementallyOptimizeDataStructures(threadDispatcher); There's only one execution of collision each stage per call to Timestep, each responsible for covering the specified dt. When configured to use more than one substep, Simulation.Solve will integrate bodies and solve constraints as if Simulation.Timestep was called Simulation.Solver.SubstepCount times, each time with a duration equal to dt / Simulation.Solver.SubstepCount. The difference between using substepping and explicitly calling Timestep more frequently is that none of the other stages run during substeps. For example, contact constraints are incrementally updated in an approximate way, but full collision detection is not run. This allows substeps to be much faster than full timesteps. Velocity iteration scheduling While the simplest approach is to use the same number of velocity iterations for all substeps, they are allowed to vary. You can provide a VelocityIterationScheduler callback in the SolveDescription to define how many velocity iterations each substep should take. There's also a helper that takes a span of integers defining the velocity iteration counts to use for each substep. var simulation = Simulation.Create(BufferPool, new NarrowPhaseCallbacks(), new PoseIntegratorCallbacks(), new SolveDescription(new[] {2, 1, 1})); The above snippet would use 3 substeps with 2 velocity iterations on the first substep, then 1 velocity iteration on the second and third substeps. This can be helpful when trying to find the absolute cheapest configuration that is still stable for a particular simulation. For example, a simulation with 1 velocity iteration per substep could be observed to be stable at 4 substeps but not at 3 substeps, and adding an extra velocity iteration to the first substep could make 3 substeps stable at a lower cost than 4 substeps. In other words, variable velocity iterations let you manage the simulation budget in a finer grained way. There are some cases where intentionally frontloading iterations could be useful as well. If you know the simulation has changed significantly since the last timestep- perhaps you've moved a bunch of bodies around such that the previous frame's guess at a constraint solution will be very wrong- then running a few more velocity iterations on the first timestep can avoid accumulating error. Dynamic changes to substep and velocity iteration counts The solver is sensitive to the effective timestep duration. It caches a best guess of the constraint solution which is sensitive to the amount of time passing between solves, so large changes can ruin the guess and harm stability. It's best to use the same timestep duration (dt passed into Simulation.Timestep) and the same number of substeps if possible, since the effective timestep duration seen by the solver is dt / substepCount. Incremental changes to the dt value can still work if they're reasonably small. 'Reasonably small' here has no precise definition; it will vary depending on the stability requirements of the simulation and how much error the application can tolerate. Changing dt by 1% per frame is probably okay for most simulations. Changing it by 50% per frame probably isn't. Changing the number of substeps is harder to do in a continuous way. Going from 4 to 3 substeps with a 60hz outer timestep rate means going from 240hz to 180hz effective solve rate instantly. That could be enough to cause problems for some simulations. You'd likely want to increase the number of velocity iterations in the first substep of the next frame to try to correct some of the induced error. It's also possible to update the cached guess in response to a timestep change using Solver.ScaleAccumulatedImpulses. The scale should be newEffectiveTimestepDuration / oldEffectiveTimestepDuration, or in other words (newDt / newSubstepCount) / (oldDt / oldSubstepCount). This operation is not very cheap: it touches all accumulated impulses memory. Changing the number of velocity iterations from frame to frame is safe. The more velocity iterations there are, the closer the solution will converge to an optimum during the substep. Callbacks The solver exposes events that fire at the beginning and end of each substep: SubstepStarted and SubstepEnded. These events are called from worker thread 0 in the solver's thread dispatch; the dispatch does not end in between substeps to keep overhead low. (Note that attempting to dispatch multithreaded work from the same IThreadDispatcher instance that dispatched the solver's workers requires that the IThreadDispatcher implementation is reentrant. The BepuUtilities.ThreadDispatcher is not.) Limitations Unfortunately, substepping isn't magic. The entire point is to avoid running other parts of the engine at the same rate as the solver, so contacts do not get fully updated for each substep. They do undergo an incremental update process that tries to fix up the most obvious issues (like penetration depth changes over time), but without a full collision test the contact manifolds can go out of date. This incremental update is usually fine, but out of date contacts can sometimes introduce energy. For example, an out of date contact lever arm can let a body 'fall' into another body ever so slightly, which over many substeps ends up sustaining oscillation. You can see an example of this behavior here. To mitigate this issue, you can try: damping the relevant bodies more heavily in the integrator, increasing the damping of contacts associated with the relevant bodies, increasing the sleeping velocity threshold (BodyActivityDescription.SleepThreshold passed into the BodyDescription) for the relevant bodies such that they take a nap instead of wiggling, increasing the inertia of the problematic bodies to increase the period of oscillation (possibly making it easier to mitigate with sleeping/damping) avoiding shapes or situations that are likely to cause the problem, or just don't use solver substepping. You can always resort to calling Simulation.Timestep more frequently. It'll cost more than solver-only substepping, but it'll keep all your contact data up to date, and the library's pretty dang fast anyway."
  },
  "UpgradingFromV1.html": {
    "href": "UpgradingFromV1.html",
    "title": "Upgrading from v1 | Bepu Docs",
    "keywords": "Upgrading from v1 v2 is a complete rewrite and is about as different from v1 as any unrelated physics engine. Reading the Getting Started documentation to get an overview is recommended. The following maps concepts and features in v1 to their equivalents in v2. Some of this might look way more complicated, and it might seem like features were removed for no reason, but trust me it's great! For some definitions of great! The API just avoids hiding performance-related things and punts responsibility for application-specific convenience features to the user. Stuff that looks the same as the v1 version can be created pretty easily, it's just not in the core library. Concept v1 v2 Top level type containing all execution stages and all existing objects Space Simulation Mobile dynamic and kinematic objects Entity Body, but there is no Body type- see Simulation.Bodies to allocate, access, and delete bodies. Creating a body using Simulation.Bodies.Add returns a handle that uniquely identifies the body for the duration of its existence, and Simulation.Bodies.HandleToLocation finds the current memory location of a body. BodyReference can be used to handle lookups for you. Mobile object properties Entity properties, like Position and LinearVelocity Create a BodyReference from the body handle, then access properties like Pose and Velocity. Can also manually perform the lookup into the Simulation.Bodies sets and their raw property buffers. Collision events entity.CollisionInformation.Events No out of the box events; ContactEventsDemo shows how to use narrow phase callbacks to create events. Enumerating existing collisions entity.CollisionInformation.Pairs Collision data is not explicitly cached anywhere. Narrow phase callbacks can be used to collect collision information. Collision-created contact constraints (and all other connected constraints) can be enumerated using the Constraints body property. See the SolverContactEnumerationDemo for an example of enumerating contact constraints. Collision filtering e.CollisionInformation.CollisionRules and CollisionRules static functions INarrowPhaseCallbacks has AllowContactGeneration and ConfigureContactManifold which return a boolean that controls whether narrow phase testing and constraint generation should proceed. See RagdollDemo for an example of collision filtering. Custom gravity entity.Gravity IPoseIntegratorCallbacks can be used to implement any form of gravity or other per-body velocity influence. See PlanetDemo for an example. Object velocity damping entity.LinearDamping and entity.AngularDamping IPoseIntegratorCallbacks again- damping is just a velocity influence. See DemoCallbacks for an example. Scene-wide ray casts Space.RayCast or s.BroadPhase.QueryAccelerator.RayCast for AABB-only testing Simulation.RayCast or Simulation.BroadPhase.RayCast for AABB-only testing Scene-wide sweep tests Space.ConvexCast Simulation.Sweep, which supports angular motion in the sweep as well, or Simulation.BroadPhase.Sweep for AABB-only testing Bounding box queries s.BroadPhase.QueryAccelerator.GetEntries Simulation.BroadPhase.GetOverlaps Collidable composed of a bunch of triangles StaticMesh or InstancedMesh Mesh Triangulated heightmap collidable Terrain There is no dedicated heightmap type at the moment, so just Mesh Sphere collision shape SphereShape Sphere Capsule collision shape CapsuleShape Capsule Box collision shape BoxShape Box Triangle collision shape TriangleShape You can probably guess, Triangle Cylinder collision shape CylinderShape Cylinder Convex hull collision shape ConvexHullShape ConvexHull Cone collision shape ConeShape N/A- consider a ConvexHull approximation Weird combination shape in minkowski space that no one ever used MinkowskiSumShape N/A- I'd say \"consider a ConvexHull approximation,\" but I'm pretty sure no one will ever want to do this Combination shape that acts like a convex hull around arbitrary subshapes WrappedShape N/A- consider a ConvexHull approximation. Not sure if anyone ever used this one either. Affinely transformable wrapper around any other convex shape TransformableShape N/A- consider a ConvexHull approximation Multiple convex shapes bundled into one shape supporting concavity CompoundShape Compound for shapes with only a few pieces; BigCompound for ones that have enough children to benefit from an acceleration structure Static-only optimization for a bunch of other convex shapes StaticGroup Doesn't exist because it's not necessary; just use Simulation.Statics.Add to toss them directly into the simulation. The broad phase can handle it just fine. Should you use really detailed concave triangle soup meshes for mobile objects? No Still no! v2 might be way faster than v1, but that doesn't mean you should just throw all those spare cycles right into the garbage can! Constraints Oof there's a lot of them Here's another bunch; main differences are the addition of a couple of simultaneously solved combos like Hinge and SwivelHinge which will be more stable than their old SolverGroup v1 versions, a couple of new cloth/deformable-helpful constraints, and the removal of questionable constraints like the EllipseSwingLimit. Constraint springiness (for those with position goals) constraint.SpringSettings.Stiffness and constraint.SpringSettings.Damping SpringSettings set in the constraint description, which contains Frequency and DampingRatio properties. Frequency is the undamped frequency of oscillation of the constraint, and DampingRatio is the ratio of the damping to critical damping, 0 being undamped, 1 being critically damped, and higher values being overdamped. Try to avoid using Frequency values higher than around half the update rate. That is, if you're updating at 60hz, 30 is a generally stable upper bound for Frequency. Higher frequencies in complex constraint configurations may require faster update rates or using the SubsteppingTimestepper. Note that, given a mass, frequency, and damping ratio, an equivalent stiffness constant and damping constant can be computed (and vice versa). I should probably add a helper for that at some point. Buoyancy zone FluidVolume N/A, may show up later in a less bad form Mesh-based collision detector with containment testing DetectorVolume No support for out of the box containment events, but a Mesh and narrow phase callbacks can perform a pretty similar job."
  },
  "api/BepuPhysics.ActiveConstraintBodyHandleCollector.html": {
    "href": "api/BepuPhysics.ActiveConstraintBodyHandleCollector.html",
    "title": "Struct ActiveConstraintBodyHandleCollector | Bepu API",
    "keywords": "Struct ActiveConstraintBodyHandleCollector Namespace BepuPhysics Assembly BepuPhysics.dll Collects body handles associated with an active constraint as integers. public struct ActiveConstraintBodyHandleCollector : IForEach<int> Implements IForEach<int> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ActiveConstraintBodyHandleCollector(Bodies, int*) public ActiveConstraintBodyHandleCollector(Bodies bodies, int* handles) Parameters bodies Bodies handles int* Fields Bodies public Bodies Bodies Field Value Bodies Count public int Count Field Value int Handles public int* Handles Field Value int* Methods LoopBody(int) public void LoopBody(int encodedBodyIndex) Parameters encodedBodyIndex int"
  },
  "api/BepuPhysics.ActiveConstraintBodyIndexCollector.html": {
    "href": "api/BepuPhysics.ActiveConstraintBodyIndexCollector.html",
    "title": "Struct ActiveConstraintBodyIndexCollector | Bepu API",
    "keywords": "Struct ActiveConstraintBodyIndexCollector Namespace BepuPhysics Assembly BepuPhysics.dll Collects body indices associated with an active constraint. Encoded metadata is stripped. public struct ActiveConstraintBodyIndexCollector : IForEach<int> Implements IForEach<int> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ActiveConstraintBodyIndexCollector(int*) public ActiveConstraintBodyIndexCollector(int* indices) Parameters indices int* Fields Count public int Count Field Value int Indices public int* Indices Field Value int* Methods LoopBody(int) public void LoopBody(int encodedBodyIndex) Parameters encodedBodyIndex int"
  },
  "api/BepuPhysics.ActiveConstraintDynamicBodyHandleCollector.html": {
    "href": "api/BepuPhysics.ActiveConstraintDynamicBodyHandleCollector.html",
    "title": "Struct ActiveConstraintDynamicBodyHandleCollector | Bepu API",
    "keywords": "Struct ActiveConstraintDynamicBodyHandleCollector Namespace BepuPhysics Assembly BepuPhysics.dll Collects body handles associated with an active constraint as integers. public struct ActiveConstraintDynamicBodyHandleCollector : IForEach<int> Implements IForEach<int> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ActiveConstraintDynamicBodyHandleCollector(Bodies, int*) public ActiveConstraintDynamicBodyHandleCollector(Bodies bodies, int* handles) Parameters bodies Bodies handles int* Fields Bodies public Bodies Bodies Field Value Bodies Count public int Count Field Value int Handles public int* Handles Field Value int* Methods LoopBody(int) public void LoopBody(int encodedBodyIndex) Parameters encodedBodyIndex int"
  },
  "api/BepuPhysics.AngularIntegrationMode.html": {
    "href": "api/BepuPhysics.AngularIntegrationMode.html",
    "title": "Enum AngularIntegrationMode | Bepu API",
    "keywords": "Enum AngularIntegrationMode Namespace BepuPhysics Assembly BepuPhysics.dll Defines how a pose integrator should handle angular velocity integration. public enum AngularIntegrationMode Fields ConserveMomentum = 1 Approximately conserves angular momentum by updating the angular velocity according to the change in orientation. Does a decent job for gyroscopes, but angular velocities will tend to drift towards a minimal inertia axis. ConserveMomentumWithGyroscopicTorque = 2 Approximately conserves angular momentum by including an implicit gyroscopic torque. Best option for Dzhanibekov effect simulation, but applies a damping effect that can make gyroscopes less useful. Nonconserving = 0 Angular velocity is directly integrated and does not change as the body pose changes. Does not conserve angular momentum."
  },
  "api/BepuPhysics.BatchCompressor.html": {
    "href": "api/BepuPhysics.BatchCompressor.html",
    "title": "Class BatchCompressor | Bepu API",
    "keywords": "Class BatchCompressor Namespace BepuPhysics Assembly BepuPhysics.dll Handles the movement of constraints from higher indexed batches into lower indexed batches to avoid accumulating a bunch of unnecessary ConstraintBatches. public class BatchCompressor Inheritance object BatchCompressor Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BatchCompressor(Solver, Bodies, float, float) public BatchCompressor(Solver solver, Bodies bodies, float targetCandidateFraction = 0.005, float maximumCompressionFraction = 0.0005) Parameters solver Solver bodies Bodies targetCandidateFraction float maximumCompressionFraction float Properties Bodies public Bodies Bodies { get; } Property Value Bodies MaximumCompressionFraction Gets or sets the maximum number of constraint moves that can occur in a single execution of Compress as a fraction of the total number of constraints. public float MaximumCompressionFraction { get; set; } Property Value float Solver public Solver Solver { get; } Property Value Solver TargetCandidateFraction Gets or sets the desired number of candidates to analyze as a fraction of the total number of constraints. public float TargetCandidateFraction { get; set; } Property Value float Methods Compress(BufferPool, IThreadDispatcher, bool) Incrementally finds and applies a set of compressions to apply to the constraints in the solver's batches. Constraints in higher index batches try to move to lower index batches whenever possible. public void Compress(BufferPool pool, IThreadDispatcher threadDispatcher = null, bool deterministic = false) Parameters pool BufferPool threadDispatcher IThreadDispatcher deterministic bool"
  },
  "api/BepuPhysics.Bodies.html": {
    "href": "api/BepuPhysics.Bodies.html",
    "title": "Class Bodies | Bepu API",
    "keywords": "Class Bodies Namespace BepuPhysics Assembly BepuPhysics.dll Collection of all allocated bodies. public class Bodies Inheritance object Bodies Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Bodies(BufferPool, Shapes, BroadPhase, int, int, int) Constructs a new bodies collection. Initialize must be called for the instance to be ready for use. public Bodies(BufferPool pool, Shapes shapes, BroadPhase broadPhase, int initialBodyCapacity, int initialIslandCapacity, int initialConstraintCapacityPerBody) Parameters pool BufferPool Pool for the collection to pull persistent allocations from. shapes Shapes Shapes referenced by the collection's bodies. broadPhase BroadPhase Broad phase containing the body collidables. initialBodyCapacity int Initial number of bodies to allocate space for in the active set. initialIslandCapacity int Initial number of islands to allocate space for in the Sets buffer. initialConstraintCapacityPerBody int Expected number of constraint references per body to allocate space for. Fields BodyReferenceMask Mask of bits containing the decoded body reference in a constraint body reference. For active constraints this would be the body index bits, for sleeping constraints this would be the body handle bits. public const int BodyReferenceMask = 1073741823 Field Value int BodyReferenceMetadataMask public const uint BodyReferenceMetadataMask = 3221225472 Field Value uint DoesntExistFlagIndex public const int DoesntExistFlagIndex = 31 Field Value int DynamicLimit Constraint body references greater than a given unsigned value are either kinematic (bit 30 set) or correspond to an empty lane (bit 31 set). public const uint DynamicLimit = 1073741824 Field Value uint HandlePool Pool from which handles are pulled for new bodies. public IdPool HandlePool Field Value IdPool HandleToLocation Remaps a body handle integer value to the actual array index of the body. The backing array index may change in response to cache optimization. public Buffer<BodyMemoryLocation> HandleToLocation Field Value Buffer<BodyMemoryLocation> KinematicFlagIndex public const int KinematicFlagIndex = 30 Field Value int KinematicMask public const int KinematicMask = 1073741824 Field Value int Sets The set of existing bodies. The slot at index 0 contains all active bodies. Later slots, if allocated, contain the bodies associated with inactive islands. Note that this buffer does not necessarily contain contiguous elements. When a set is removed, a gap remains. public Buffer<BodySet> Sets Field Value Buffer<BodySet> Properties ActiveSet Gets a reference to the active set, stored in the index 0 of the Sets buffer. public ref BodySet ActiveSet { get; } Property Value BodySet Reference to the active body set. this[BodyHandle] Gets a reference to a body in the collection. public BodyReference this[BodyHandle handle] { get; } Parameters handle BodyHandle Handle of the body to pull a reference for. Property Value BodyReference Reference to the requested body. Remarks This is an alias for the older GetBodyReference(BodyHandle) and the BodyReference constructor. They are all equivalent. MinimumConstraintCapacityPerBody Gets or sets the minimum constraint capacity for each body. Future resizes or allocations will obey this minimum, but changing this does not immediately resize existing lists. public int MinimumConstraintCapacityPerBody { get; set; } Property Value int Pool Gets the pool used by the bodies collection to allocate and free memory. public BufferPool Pool { get; } Property Value BufferPool Methods Add(in BodyDescription) Adds a new active body to the simulation. public BodyHandle Add(in BodyDescription description) Parameters description BodyDescription Description of the body to add. Returns BodyHandle Handle of the created body. ApplyDescription(BodyHandle, in BodyDescription) Applies a description to a body. Properly handles any transitions between dynamic and kinematic and between shapeless and shapeful. If the body is becoming kinematic, any constraints which only contain kinematic bodies will be removed. Wakes up the body. Updates the bounds of the body in the broad phase. public void ApplyDescription(BodyHandle handle, in BodyDescription description) Parameters handle BodyHandle Handle of the body to receive the description. description BodyDescription Description to apply to the body. BodyExists(BodyHandle) Checks whether a body handle is currently registered with the bodies set. public bool BodyExists(BodyHandle bodyHandle) Parameters bodyHandle BodyHandle Handle to check for. Returns bool True if the handle exists in the collection, false otherwise. Clear() Clears all bodies from all sets without releasing any memory that wouldn't be released by a sequence of regular removals. public void Clear() CountBodies() Computes the number of bodies contained in the simulation. public int CountBodies() Returns int Number of bodies contained in the simulation. Remarks Enumerates all BodySet instances in the Bodies collection, summing the body counts for every allocated instance. For simulations with very large numbers of sleeping body sets, this is not a trivial operation. Dispose() Returns all body resources to the pool used to create them. public void Dispose() Remarks The object can be reused if it is reinitialized by using EnsureCapacity or Resize. EnsureCapacity(int) Increases the size of active body buffers if needed to hold the target capacity. public void EnsureCapacity(int capacity) Parameters capacity int Target data capacity. EnsureConstraintListCapacities() Ensures all active body constraint lists can hold at least MinimumConstraintCapacityPerBody constraints. Inactive bodies are untouched. public void EnsureConstraintListCapacities() EnumerateConnectedBodies<TEnumerator>(BodyHandle, ref TEnumerator) Enumerates all the bodies connected to a given body. Bodies which are connected by more than one constraint will be reported multiple times. public void EnumerateConnectedBodies<TEnumerator>(BodyHandle bodyHandle, ref TEnumerator enumerator) where TEnumerator : IForEach<BodyHandle> Parameters bodyHandle BodyHandle Handle of the body to enumerate the connections of. This body will not appear in the set of enumerated bodies, even if it is connected to itself somehow. enumerator TEnumerator Enumerator instance to run on each connected body. Type Parameters TEnumerator Type of the enumerator to execute on each connected body. GatherState<TAccessFilter>(Vector<int>, bool, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) public void GatherState<TAccessFilter>(Vector<int> encodedBodyIndices, bool worldInertia, out Vector3Wide position, out QuaternionWide orientation, out BodyVelocityWide velocity, out BodyInertiaWide inertia) where TAccessFilter : unmanaged, IBodyAccessFilter Parameters encodedBodyIndices Vector<int> worldInertia bool position Vector3Wide orientation QuaternionWide velocity BodyVelocityWide inertia BodyInertiaWide Type Parameters TAccessFilter GetBodyReference(BodyHandle) Gets a reference to a body by its handle. public BodyReference GetBodyReference(BodyHandle handle) Parameters handle BodyHandle Handle of the body to grab a reference of. Returns BodyReference Reference to the desired body. Remarks This is an alias for this[BodyHandle] and the BodyReference constructor. They are all equivalent. GetDescription(BodyHandle) Gets the description of a body by handle. public BodyDescription GetDescription(BodyHandle handle) Parameters handle BodyHandle Handle of the body to look up. Returns BodyDescription Description of the body. GetDescription(BodyHandle, out BodyDescription) Gets the description of a body by handle. public void GetDescription(BodyHandle handle, out BodyDescription description) Parameters handle BodyHandle Handle of the body to look up. description BodyDescription Description of the body. HasLockedInertia(Symmetric3x3) Gets whether the angular inertia matches that of a kinematic body (that is, all inverse inertia tensor components are zero). public static bool HasLockedInertia(Symmetric3x3 inertia) Parameters inertia Symmetric3x3 Body inertia to analyze. Returns bool True if all components of inverse mass and inertia are zero, false otherwise. HasLockedInertia(Symmetric3x3*) Gets whether the angular inertia matches that of a kinematic body (that is, all inverse inertia tensor components are zero). public static bool HasLockedInertia(Symmetric3x3* inertia) Parameters inertia Symmetric3x3* Body inertia to analyze. Returns bool True if all components of inverse mass and inertia are zero, false otherwise. Initialize(Solver, IslandAwakener, IslandSleeper) Initializes the bodies set. Used to complete bidirectional dependencies. public void Initialize(Solver solver, IslandAwakener awakener, IslandSleeper sleeper) Parameters solver Solver Solver responsible for the constraints connected to the collection's bodies. awakener IslandAwakener Island awakener to use when bodies undergo transitions requiring that they exist in the active set. sleeper IslandSleeper IsEncodedDynamicReference(int) Checks whether a constraint encoded body reference value refers to a dynamic body. public static bool IsEncodedDynamicReference(int encodedBodyReferenceValue) Parameters encodedBodyReferenceValue int Raw encoded value taken from a constraint. Returns bool True if the encoded body reference refers to a dynamic body, false otherwise. IsEncodedKinematicReference(int) Checks whether a constraint encoded body reference value refers to a kinematic body. public static bool IsEncodedKinematicReference(int encodedBodyReferenceValue) Parameters encodedBodyReferenceValue int Raw encoded value taken from a constraint. Returns bool True if the encoded body reference refers to a kinematic body, false otherwise. IsKinematic(BodyInertia) Gets whether the inertia matches that of a kinematic body (that is, all inverse mass and inertia components are zero). public static bool IsKinematic(BodyInertia inertia) Parameters inertia BodyInertia Body inertia to analyze. Returns bool True if all components of inverse mass and inertia are zero, false otherwise. IsKinematic(BodyInertia*) Gets whether the inertia matches that of a kinematic body (that is, all inverse mass and inertia components are zero). public static bool IsKinematic(BodyInertia* inertia) Parameters inertia BodyInertia* Body inertia to analyze. Returns bool True if all components of inverse mass and inertia are zero, false otherwise. IsKinematic(BodyInertiaWide) Checks inertia lanes for kinematicity (all inverse mass and inertia values are zero). public static Vector<int> IsKinematic(BodyInertiaWide inertia) Parameters inertia BodyInertiaWide Inertia to examine for kinematicity. Returns Vector<int> Mask of lanes which contain zeroed inverse masses and inertias. Remove(BodyHandle) Removes a body from the set by its handle. If the body is inactive, all bodies in its island will be forced active. public void Remove(BodyHandle handle) Parameters handle BodyHandle Handle of the body to remove. RemoveAt(int) Removes an active body by its index. Any constraints connected to this body will be removed. Assumes that the input location is valid. public void RemoveAt(int activeBodyIndex) Parameters activeBodyIndex int Index of the active body. Resize(int) Resizes the allocated spans for active body data. Note that this is conservative; it will never orphan existing objects. public void Resize(int capacity) Parameters capacity int Target body data capacity. ResizeConstraintListCapacities() Resizes all active body constraint lists to meet the MinimumConstraintCapacityPerBody. Inactive bodies are untouched. Resizes are guaranteed to never shrink a list below the current count. public void ResizeConstraintListCapacities() ScatterInertia(ref BodyInertiaWide, Vector<int>, Vector<int>) public void ScatterInertia(ref BodyInertiaWide inertia, Vector<int> encodedBodyIndices, Vector<int> mask) Parameters inertia BodyInertiaWide encodedBodyIndices Vector<int> mask Vector<int> ScatterPose(ref Vector3Wide, ref QuaternionWide, Vector<int>, Vector<int>) public void ScatterPose(ref Vector3Wide position, ref QuaternionWide orientation, Vector<int> encodedBodyIndices, Vector<int> mask) Parameters position Vector3Wide orientation QuaternionWide encodedBodyIndices Vector<int> mask Vector<int> ScatterVelocities<TAccessFilter>(ref BodyVelocityWide, ref Vector<int>) public void ScatterVelocities<TAccessFilter>(ref BodyVelocityWide sourceVelocities, ref Vector<int> encodedBodyIndices) where TAccessFilter : unmanaged, IBodyAccessFilter Parameters sourceVelocities BodyVelocityWide encodedBodyIndices Vector<int> Type Parameters TAccessFilter SetLocalInertia(BodyHandle, in BodyInertia) Changes the local mass and inertia tensor associated with a body. Properly handles the transition between kinematic and dynamic. If the body is becoming kinematic, any constraints which only contain kinematic bodies will be removed. Wakes up the body. public void SetLocalInertia(BodyHandle handle, in BodyInertia localInertia) Parameters handle BodyHandle Handle of the body whose inertia should change. localInertia BodyInertia New local inertia for the body. Remarks This function is only necessary when the inertia change could potentially result in a transition between dynamic and kinematic states. If it is guaranteed to be dynamic before and after the change, the inertia can be directly modified without issue. SetShape(BodyHandle, TypedIndex) Changes the shape of a body. Properly handles the transition between shapeless and shapeful. If the body is inactive, it will be forced awake. Updates the bounds of the body in the broad phase. public void SetShape(BodyHandle handle, TypedIndex newShape) Parameters handle BodyHandle Handle of the body to change the shape of. newShape TypedIndex Index of the new shape to use for the body. TransposeMotionStates(Buffer<MotionState>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide) Transposes of bundle of array-of-structures layout motion states into a bundle of array-of-structures-of-arrays layout. Size of buffer must be no larger than the Count. public static void TransposeMotionStates(Buffer<MotionState> states, out Vector3Wide position, out QuaternionWide orientation, out BodyVelocityWide velocity) Parameters states Buffer<MotionState> Array-of-structures data to transpose. position Vector3Wide Array-of-structures-of-arrays positions. orientation QuaternionWide Array-of-structures-of-arrays orientations. velocity BodyVelocityWide Array-of-structures-of-arrays velocities. UpdateBounds(BodyHandle) Updates the bounds held within the broad phase for the body's current state. Does not expand the bounding box by velocity. If there is no shape associated with the body, this does nothing. public void UpdateBounds(BodyHandle bodyHandle) Parameters bodyHandle BodyHandle"
  },
  "api/BepuPhysics.BodyActivity.html": {
    "href": "api/BepuPhysics.BodyActivity.html",
    "title": "Struct BodyActivity | Bepu API",
    "keywords": "Struct BodyActivity Namespace BepuPhysics Assembly BepuPhysics.dll Describes how a body sleeps, and its current state with respect to sleeping. public struct BodyActivity Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields MinimumTimestepsUnderThreshold The number of time steps that the body must be under the sleep threshold before the body becomes a sleeping candidate. Note that the body is not guaranteed to go to sleep immediately after meeting this minimum. public byte MinimumTimestepsUnderThreshold Field Value byte SleepCandidate True if this body is a candidate for being slept. If all the bodies that it is connected to by constraints are also candidates, this body may go to sleep. public bool SleepCandidate Field Value bool SleepThreshold Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity). Setting this to a negative value guarantees the body cannot go to sleep without user action. public float SleepThreshold Field Value float TimestepsUnderThresholdCount If the body is awake, this is the number of time steps that the body has had a velocity below the sleep threshold. public byte TimestepsUnderThresholdCount Field Value byte"
  },
  "api/BepuPhysics.BodyActivityDescription.html": {
    "href": "api/BepuPhysics.BodyActivityDescription.html",
    "title": "Struct BodyActivityDescription | Bepu API",
    "keywords": "Struct BodyActivityDescription Namespace BepuPhysics Assembly BepuPhysics.dll Describes the thresholds for a body going to sleep. public struct BodyActivityDescription Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BodyActivityDescription(float, byte) Creates a body activity description. public BodyActivityDescription(float sleepThreshold, byte minimumTimestepCountUnderThreshold = 32) Parameters sleepThreshold float Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity). minimumTimestepCountUnderThreshold byte The number of time steps that the body must be under the sleep threshold before the body becomes a sleep candidate. Note that the body is not guaranteed to go to sleep immediately after meeting this minimum. Fields MinimumTimestepCountUnderThreshold The number of time steps that the body must be under the sleep threshold before the body becomes a sleep candidate. Note that the body is not guaranteed to go to sleep immediately after meeting this minimum. public byte MinimumTimestepCountUnderThreshold Field Value byte SleepThreshold Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity). public float SleepThreshold Field Value float Operators implicit operator BodyActivityDescription(float) Creates a body activity description. Uses a MinimumTimestepCountUnderThreshold of 32. public static implicit operator BodyActivityDescription(float sleepThreshold) Parameters sleepThreshold float Threshold of squared velocity under which the body is allowed to go to sleep. This is compared against dot(linearVelocity, linearVelocity) + dot(angularVelocity, angularVelocity). Note that the body is not guaranteed to go to sleep immediately after meeting this minimum. Returns BodyActivityDescription"
  },
  "api/BepuPhysics.BodyConstraintReference.html": {
    "href": "api/BepuPhysics.BodyConstraintReference.html",
    "title": "Struct BodyConstraintReference | Bepu API",
    "keywords": "Struct BodyConstraintReference Namespace BepuPhysics Assembly BepuPhysics.dll public struct BodyConstraintReference Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields BodyIndexInConstraint public int BodyIndexInConstraint Field Value int ConnectingConstraintHandle public ConstraintHandle ConnectingConstraintHandle Field Value ConstraintHandle"
  },
  "api/BepuPhysics.BodyDescription.html": {
    "href": "api/BepuPhysics.BodyDescription.html",
    "title": "Struct BodyDescription | Bepu API",
    "keywords": "Struct BodyDescription Namespace BepuPhysics Assembly BepuPhysics.dll Describes a body's state. public struct BodyDescription Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Activity Sleeping settings for the body. public BodyActivityDescription Activity Field Value BodyActivityDescription Collidable Shape and collision detection settings for the body. public CollidableDescription Collidable Field Value CollidableDescription LocalInertia Mass and inertia tensor of the body. public BodyInertia LocalInertia Field Value BodyInertia Pose Position and orientation of the body. public RigidPose Pose Field Value RigidPose Velocity Linear and angular velocity of the body. public BodyVelocity Velocity Field Value BodyVelocity Methods CreateConvexDynamic<TConvexShape>(RigidPose, BodyVelocity, float, Shapes, in TConvexShape) Creates a dynamic body description with collidable, inertia, and activity descriptions generated from a convex shape. Adds the shape to the given shape set. public static BodyDescription CreateConvexDynamic<TConvexShape>(RigidPose pose, BodyVelocity velocity, float mass, Shapes shapes, in TConvexShape shape) where TConvexShape : unmanaged, IConvexShape Parameters pose RigidPose Pose of the body. velocity BodyVelocity Initial velocity of the body. mass float Mass of the body. The inertia tensor will be calculated based on this mass and the shape. shapes Shapes Shape collection to add the shape to. shape TConvexShape Shape to add to the shape set and to create the body from. Returns BodyDescription Constructed description for the body. Type Parameters TConvexShape Type of the shape to create a body for. CreateConvexDynamic<TConvexShape>(RigidPose, float, Shapes, in TConvexShape) Creates a dynamic body description with zero initial velocity and collidable, inertia, and activity descriptions generated from a convex shape. Adds the shape to the given shape set. public static BodyDescription CreateConvexDynamic<TConvexShape>(RigidPose pose, float mass, Shapes shapes, in TConvexShape shape) where TConvexShape : unmanaged, IConvexShape Parameters pose RigidPose Pose of the body. mass float Mass of the body. The inertia tensor will be calculated based on this mass and the shape. shapes Shapes Shape collection to add the shape to. shape TConvexShape Shape to add to the shape set and to create the body from. Returns BodyDescription Constructed description for the body. Type Parameters TConvexShape Type of the shape to create a body for. CreateConvexKinematic<TConvexShape>(RigidPose, BodyVelocity, Shapes, in TConvexShape) Creates a kinematic body description with collidable and activity descriptions generated from a convex shape. Adds the shape to the given shape set. public static BodyDescription CreateConvexKinematic<TConvexShape>(RigidPose pose, BodyVelocity velocity, Shapes shapes, in TConvexShape shape) where TConvexShape : unmanaged, IConvexShape Parameters pose RigidPose Pose of the body. velocity BodyVelocity Initial velocity of the body. shapes Shapes Shape collection to add the shape to. shape TConvexShape Shape to add to the shape set and to create the body from. Returns BodyDescription Constructed description for the body. Type Parameters TConvexShape Type of the shape to create a body for. CreateConvexKinematic<TConvexShape>(RigidPose, Shapes, TConvexShape) Creates a kinematic body description with zero initial velocity and collidable and activity descriptions generated from a convex shape. Adds the shape to the given shape set. public static BodyDescription CreateConvexKinematic<TConvexShape>(RigidPose pose, Shapes shapes, TConvexShape shape) where TConvexShape : unmanaged, IConvexShape Parameters pose RigidPose Pose of the body. shapes Shapes Shape collection to add the shape to. shape TConvexShape Shape to add to the shape set and to create the body from. Returns BodyDescription Constructed description for the body. Type Parameters TConvexShape Type of the shape to create a body for. CreateDynamic(RigidPose, BodyInertia, CollidableDescription, BodyActivityDescription) Creates a dynamic body description with zero initial velocity. public static BodyDescription CreateDynamic(RigidPose pose, BodyInertia inertia, CollidableDescription collidable, BodyActivityDescription activity) Parameters pose RigidPose Pose of the body. inertia BodyInertia Local inertia of the body. collidable CollidableDescription Collidable to associate with the body. activity BodyActivityDescription Activity settings for the body. Returns BodyDescription Constructed description for the body. CreateDynamic(RigidPose, BodyVelocity, BodyInertia, CollidableDescription, BodyActivityDescription) Creates a dynamic body description. public static BodyDescription CreateDynamic(RigidPose pose, BodyVelocity velocity, BodyInertia inertia, CollidableDescription collidable, BodyActivityDescription activity) Parameters pose RigidPose Pose of the body. velocity BodyVelocity Initial velocity of the body. inertia BodyInertia Local inertia of the body. collidable CollidableDescription Collidable to associate with the body. activity BodyActivityDescription Activity settings for the body. Returns BodyDescription Constructed description for the body. CreateKinematic(RigidPose, BodyVelocity, CollidableDescription, BodyActivityDescription) Creates a kinematic body description. public static BodyDescription CreateKinematic(RigidPose pose, BodyVelocity velocity, CollidableDescription collidable, BodyActivityDescription activity) Parameters pose RigidPose Pose of the body. velocity BodyVelocity Initial velocity of the body. collidable CollidableDescription Collidable to associate with the body. activity BodyActivityDescription Activity settings for the body. Returns BodyDescription Constructed description for the body. CreateKinematic(RigidPose, CollidableDescription, BodyActivityDescription) Creates a kinematic body description with zero initial velocity. public static BodyDescription CreateKinematic(RigidPose pose, CollidableDescription collidable, BodyActivityDescription activity) Parameters pose RigidPose Pose of the body. collidable CollidableDescription Collidable to associate with the body. activity BodyActivityDescription Activity settings for the body. Returns BodyDescription Constructed description for the body. GetDefaultActivity<TShape>(in TShape) Computes a decent default activity description for a shape. public static BodyActivityDescription GetDefaultActivity<TShape>(in TShape shape) where TShape : struct, IConvexShape Parameters shape TShape Shape to create an activity description for. Returns BodyActivityDescription Default activity description for the given shape. Type Parameters TShape Type of the shape to create an activity description for. GetDefaultSpeculativeMargin<TShape>(in TShape) Computes a decent default speculative margin for a shape based on its minimum and maximum radii. public static float GetDefaultSpeculativeMargin<TShape>(in TShape shape) where TShape : struct, IConvexShape Parameters shape TShape Shape to compute a speculative margin for. Returns float Speculative margin for the given shape. Type Parameters TShape Type of the shape to compute a speculative margin for."
  },
  "api/BepuPhysics.BodyDynamics.html": {
    "href": "api/BepuPhysics.BodyDynamics.html",
    "title": "Struct BodyDynamics | Bepu API",
    "keywords": "Struct BodyDynamics Namespace BepuPhysics Assembly BepuPhysics.dll Stores all body information needed by the solver together. public struct BodyDynamics Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks With 2.4's revamp of the solver, every solving stage loads pose, velocity, and inertia for every body in each constraint. L2 prefetchers often fetch memory in even-odd pairs of cache lines (see https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf#page=162). Since L2 is likely pulling in adjacent cache lines when loading either motion state or inertias, they might as well live together in one block. Note that this goes along with a change to the buffer pool's default alignment to 128 bytes. Fields Inertia Inertia information for the body. public BodyInertias Inertia Field Value BodyInertias Motion Pose and velocity information for the body. public MotionState Motion Field Value MotionState Methods ToString() Returns a string representing the BodyDynamics. public override string ToString() Returns string String representing the BodyDynamics."
  },
  "api/BepuPhysics.BodyHandle.html": {
    "href": "api/BepuPhysics.BodyHandle.html",
    "title": "Struct BodyHandle | Bepu API",
    "keywords": "Struct BodyHandle Namespace BepuPhysics Assembly BepuPhysics.dll Unique identifier of a body belonging to a simulation's Bodies collection. public struct BodyHandle : IEquatable<BodyHandle>, IEqualityComparerRef<BodyHandle> Implements IEquatable<BodyHandle> IEqualityComparerRef<BodyHandle> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BodyHandle(int) public BodyHandle(int value) Parameters value int Fields Value Index in the handle-to-memory mapping table used to look up the current memory location of the body. This value will not (and must not) change during the body's lifespan, but the memory that the table points to could change. public int Value Field Value int Methods Equals(BodyHandle) Indicates whether the current object is equal to another object of the same type. public bool Equals(BodyHandle other) Parameters other BodyHandle An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(ref BodyHandle, ref BodyHandle) public bool Equals(ref BodyHandle a, ref BodyHandle b) Parameters a BodyHandle b BodyHandle Returns bool Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Hash(ref BodyHandle) public int Hash(ref BodyHandle item) Parameters item BodyHandle Returns int ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(BodyHandle, BodyHandle) public static bool operator ==(BodyHandle a, BodyHandle b) Parameters a BodyHandle b BodyHandle Returns bool operator !=(BodyHandle, BodyHandle) public static bool operator !=(BodyHandle a, BodyHandle b) Parameters a BodyHandle b BodyHandle Returns bool"
  },
  "api/BepuPhysics.BodyInertia.html": {
    "href": "api/BepuPhysics.BodyInertia.html",
    "title": "Struct BodyInertia | Bepu API",
    "keywords": "Struct BodyInertia Namespace BepuPhysics Assembly BepuPhysics.dll Stores the inertia for a body. public struct BodyInertia Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This representation stores the inverse mass and inverse inertia tensor. Most of the high frequency use cases in the engine naturally use the inverse. Fields InverseInertiaTensor Inverse of the body's inertia tensor. public Symmetric3x3 InverseInertiaTensor Field Value Symmetric3x3 InverseMass Inverse of the body's mass. public float InverseMass Field Value float Methods ToString() Returns a string representing the BodyInertia as \"InverseMass, InverseInertiaTensor\". public override string ToString() Returns string String representing the BodyInertia."
  },
  "api/BepuPhysics.BodyInertiaWide.html": {
    "href": "api/BepuPhysics.BodyInertiaWide.html",
    "title": "Struct BodyInertiaWide | Bepu API",
    "keywords": "Struct BodyInertiaWide Namespace BepuPhysics Assembly BepuPhysics.dll public struct BodyInertiaWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields InverseInertiaTensor public Symmetric3x3Wide InverseInertiaTensor Field Value Symmetric3x3Wide InverseMass public Vector<float> InverseMass Field Value Vector<float>"
  },
  "api/BepuPhysics.BodyInertias.html": {
    "href": "api/BepuPhysics.BodyInertias.html",
    "title": "Struct BodyInertias | Bepu API",
    "keywords": "Struct BodyInertias Namespace BepuPhysics Assembly BepuPhysics.dll Stores the local and world views of a body's inertia, packed together for efficient access. public struct BodyInertias Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Local Local inertia of the body. public BodyInertia Local Field Value BodyInertia World Transformed world inertia of the body. Note that this is only valid between the velocity integration that updates it and the pose integration that follows. Outside of that execution window, this should be considered undefined. public BodyInertia World Field Value BodyInertia Remarks We cache this here because velocity integration wants both the local and world inertias, and any integration happening within the solver will do so without the benefit of sequential loads. In that context, being able to load a single cache line to grab both local and world inertia helps quite a lot. Methods ToString() Returns a string representing the BodyInertias. public override string ToString() Returns string String representing the BodyInertias."
  },
  "api/BepuPhysics.BodyMemoryLocation.html": {
    "href": "api/BepuPhysics.BodyMemoryLocation.html",
    "title": "Struct BodyMemoryLocation | Bepu API",
    "keywords": "Struct BodyMemoryLocation Namespace BepuPhysics Assembly BepuPhysics.dll Location of a body in memory. public struct BodyMemoryLocation Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Index Index of the body within its owning set. public int Index Field Value int SetIndex Index of the set owning the body reference. If the set index is 0, the body is awake. If the set index is greater than zero, the body is asleep. public int SetIndex Field Value int"
  },
  "api/BepuPhysics.BodyReference.html": {
    "href": "api/BepuPhysics.BodyReference.html",
    "title": "Struct BodyReference | Bepu API",
    "keywords": "Struct BodyReference Namespace BepuPhysics Assembly BepuPhysics.dll Convenience structure for directly referring to a body's properties. public struct BodyReference Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Note that this type makes no attempt to protect against unsafe modification of body properties, nor does modifying its properties try to wake up bodies if they are asleep. Constructors BodyReference(BodyHandle, Bodies) Constructs a new body reference. public BodyReference(BodyHandle handle, Bodies bodies) Parameters handle BodyHandle Handle of the body to refer to. bodies Bodies Collection containing the body. Remarks This is equivalent to GetBodyReference(BodyHandle) and this[BodyHandle]. Fields Bodies The bodies collection containing the body. public Bodies Bodies Field Value Bodies Handle Handle of the body that this reference refers to. public BodyHandle Handle Field Value BodyHandle Properties Activity Gets a reference to the body's activity state. public ref BodyActivity Activity { get; } Property Value BodyActivity Awake Gets or sets whether the body is in the active set. Setting this to true will attempt to wake the body; setting it to false will force the body and any constraint-connected bodies asleep. public bool Awake { get; set; } Property Value bool BoundingBox Gets a copy of the body's bounding box. If the body has no shape, the bounding box has a min at float.MaxValue and a max at float.MinValue. public BoundingBox BoundingBox { get; } Property Value BoundingBox Collidable Gets a reference to the body's collidable. public ref Collidable Collidable { get; } Property Value Collidable CollidableReference Gets a CollidableReference for this body. CollidableReferences uniquely identify a collidable object in a simulation by including both the dynamic/kinematic/static state of the object and its handle. Despite an unfortunate naming collision, CollidableReferences are distinct from a direct reference to a body's collidable data, which you can get from the Collidable property. public CollidableReference CollidableReference { get; } Property Value CollidableReference Constraints Gets a reference to the list of the body's connected constraints. public ref QuickList<BodyConstraintReference> Constraints { get; } Property Value QuickList<BodyConstraintReference> Dynamics Gets a reference to the body's solver-relevant state, including pose, velocity, and inertia. public ref BodyDynamics Dynamics { get; } Property Value BodyDynamics Exists Gets whether the body reference exists within the body set. True if the handle maps to a valid memory location that agrees that the handle points to it, false otherwise. public bool Exists { get; } Property Value bool HasLockedInertia Gets whether the body has locked inertia, meaning its inverse inertia tensor is zero. public bool HasLockedInertia { get; } Property Value bool Kinematic Gets whether the body is kinematic, meaning its inverse inertia and mass are all zero. public bool Kinematic { get; } Property Value bool LocalInertia Gets a reference to the body's local inertia. public ref BodyInertia LocalInertia { get; } Property Value BodyInertia MemoryLocation Gets a reference to the body's memory location stored in the handle to location mapping. public ref BodyMemoryLocation MemoryLocation { get; } Property Value BodyMemoryLocation MotionState Gets a reference to the body's motion state, including both pose and velocity. public ref MotionState MotionState { get; } Property Value MotionState Pose Gets a reference to the body's pose. public ref RigidPose Pose { get; } Property Value RigidPose Velocity Gets a reference to the body's velocity. public ref BodyVelocity Velocity { get; } Property Value BodyVelocity Methods ApplyAngularImpulse(Vector3) Applies an angular impulse to an angular velocity. Does not wake the body up. public void ApplyAngularImpulse(Vector3 angularImpulse) Parameters angularImpulse Vector3 Impulse to apply to the velocity. ApplyAngularImpulse(Vector3, in Symmetric3x3, ref Vector3) Applies an angular impulse to an angular velocity. Does not wake the body up. public static void ApplyAngularImpulse(Vector3 angularImpulse, in Symmetric3x3 inverseInertiaTensor, ref Vector3 angularVelocity) Parameters angularImpulse Vector3 Impulse to apply to the velocity. inverseInertiaTensor Symmetric3x3 Inverse inertia tensor to transform the impulse with. angularVelocity Vector3 Angular velocity to be modified. ApplyDescription(in BodyDescription) Sets a body's properties according to a description. Properly handles any transitions between dynamic and kinematic and between shapeless and shapeful. If the body is becoming kinematic, any constraints which only contain kinematic bodies will be removed. Wakes up the body and updates its bounds in the broad phase. public void ApplyDescription(in BodyDescription description) Parameters description BodyDescription Description of the body. ApplyImpulse(in BodySet, int, Vector3, Vector3) Applies an impulse to a body by index. Does not wake the body up. public static void ApplyImpulse(in BodySet set, int index, Vector3 impulse, Vector3 impulseOffset) Parameters set BodySet Body set containing the body to apply an impulse to. index int Index of the body in the body set. impulse Vector3 Impulse to apply to the body. impulseOffset Vector3 World space offset from the center of the body to apply the impulse at. ApplyImpulse(Vector3, Vector3) Applies an impulse to a body at the given world space offset. Does not modify activity states. public void ApplyImpulse(Vector3 impulse, Vector3 impulseOffset) Parameters impulse Vector3 Impulse to apply to the body. impulseOffset Vector3 World space offset to apply the impulse at. ApplyImpulse(Vector3, Vector3, ref BodyInertia, ref RigidPose, ref BodyVelocity) Applies an impulse to a body by index. Does not wake the body up. public static void ApplyImpulse(Vector3 impulse, Vector3 impulseOffset, ref BodyInertia localInertia, ref RigidPose pose, ref BodyVelocity velocity) Parameters impulse Vector3 Impulse to apply to the body. impulseOffset Vector3 World space offset from the center of the body to apply the impulse at. localInertia BodyInertia Local inertia of the body to apply impulse to. pose RigidPose Pose of the body to apply impulse to. velocity BodyVelocity Velocity of the body to apply impulse to. ApplyLinearImpulse(Vector3) Applies an impulse to a linear velocity. Does not wake the body up. public void ApplyLinearImpulse(Vector3 impulse) Parameters impulse Vector3 Impulse to apply to the velocity. ApplyLinearImpulse(Vector3, float, ref Vector3) Applies an impulse to a linear velocity. Does not wake the body up. public static void ApplyLinearImpulse(Vector3 impulse, float inverseMass, ref Vector3 linearVelocity) Parameters impulse Vector3 Impulse to apply to the velocity. inverseMass float Inverse mass to transform the impulse with. linearVelocity Vector3 Linear velocity to be modified. BecomeKinematic() If the body is dynamic, turns the body kinematic by setting all inverse inertia and mass values to zero and activates it. Any constraints connected to the body that now only contain kinematic references are removed. If the body is kinematic, does nothing. public void BecomeKinematic() ComputeInverseInertia(out Symmetric3x3) Computes the world space inverse inertia tensor for the body based on the LocalInertia and Pose. public void ComputeInverseInertia(out Symmetric3x3 inverseInertia) Parameters inverseInertia Symmetric3x3 GetBoundsReferencesFromBroadPhase(out Vector3*, out Vector3*) Gets direct pointers to the body's bounding box minimum and maximum in the broad phase. Outputs null if the body has no shape. public bool GetBoundsReferencesFromBroadPhase(out Vector3* min, out Vector3* max) Parameters min Vector3* Pointer to the bounding box minimum in the broad phase. Null if the body has no shape. max Vector3* Pointer to the bounding box maximum in the broad phase. Null if the body has no shape. Returns bool True if the body has a shape and bounds, false otherwise. GetDescription(out BodyDescription) Gets a description of the body. public void GetDescription(out BodyDescription description) Parameters description BodyDescription Description of the body. GetVelocityForOffset(Vector3, out Vector3) Computes the velocity of a world space offset point attached to the body. public void GetVelocityForOffset(Vector3 offset, out Vector3 velocity) Parameters offset Vector3 World space offset from the body's center to the point to measure. velocity Vector3 Effective velocity of the point if it were attached to the body. SetLocalInertia(in BodyInertia) Sets the body's local inertia to the provided inertia. Wakes up the body and correctly handles any transition between dynamic and kinematic states. If the body moves from dynamic to kinematic, any constraints connected to the body that now only contain kinematic references are removed. public void SetLocalInertia(in BodyInertia localInertia) Parameters localInertia BodyInertia SetShape(TypedIndex) Changes the shape of a body. Properly handles the transition between shapeless and shapeful. If the body is inactive, it will be forced awake. Updates the bounds of the body in the broad phase. public void SetShape(TypedIndex newShape) Parameters newShape TypedIndex Index of the new shape to use for the body. UpdateBounds() Updates the body's bounds in the broad phase for its current state. Does not include velocity expansion. Does nothing if the body has no shape. public void UpdateBounds() Remarks Can be useful if you made modifications to the body's state that you want reflected in the broad phase before the next timestep. For example, if you want to perform ray casts against the broad phase after moving objects around directly, their bounds must be updated or else the broad phase bounds will be out of date and the ray will likely miss. Operators implicit operator BodyHandle(BodyReference) Implicitly converts a BodyReference to the BodyHandle that the body reference was created from. public static implicit operator BodyHandle(BodyReference reference) Parameters reference BodyReference Body reference to extract the handle from. Returns BodyHandle"
  },
  "api/BepuPhysics.BodySet.html": {
    "href": "api/BepuPhysics.BodySet.html",
    "title": "Struct BodySet | Bepu API",
    "keywords": "Struct BodySet Namespace BepuPhysics Assembly BepuPhysics.dll Stores a group of bodies- either the set of active bodies, or the bodies involved in an inactive simulation island. public struct BodySet Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BodySet(int, BufferPool) public BodySet(int initialCapacity, BufferPool pool) Parameters initialCapacity int pool BufferPool Fields Activity Activity states of bodies in the set. public Buffer<BodyActivity> Activity Field Value Buffer<BodyActivity> Collidables The collidables owned by each body in the set. Speculative margins, continuity settings, and shape indices can be changed directly. Shape indices cannot transition between pointing at a shape and pointing at nothing or vice versa without notifying the broad phase of the collidable addition or removal. public Buffer<Collidable> Collidables Field Value Buffer<Collidable> Constraints List of constraints associated with each body in the set. public Buffer<QuickList<BodyConstraintReference>> Constraints Field Value Buffer<QuickList<BodyConstraintReference>> Count public int Count Field Value int DynamicsState Stores all data involved in solving constraints for a body, including pose, velocity, and inertia. public Buffer<BodyDynamics> DynamicsState Field Value Buffer<BodyDynamics> IndexToHandle Remaps a body index to its handle. public Buffer<BodyHandle> IndexToHandle Field Value Buffer<BodyHandle> Properties Allocated Gets whether this instance is backed by allocated memory. public bool Allocated { get; } Property Value bool Methods BodyIsConstrainedBy(int, ConstraintHandle) public bool BodyIsConstrainedBy(int bodyIndex, ConstraintHandle constraintHandle) Parameters bodyIndex int constraintHandle ConstraintHandle Returns bool Clear(BufferPool) public void Clear(BufferPool pool) Parameters pool BufferPool Dispose(BufferPool) Disposes the body set's buffers and any resources within them. public void Dispose(BufferPool pool) Parameters pool BufferPool Pool to return resources to. DisposeBuffers(BufferPool) Disposes the buffers, but nothing inside of the buffers. Per-body constraint lists stored in the set will not be returned. public void DisposeBuffers(BufferPool pool) Parameters pool BufferPool Pool to return the set's top level buffers to. GetDescription(int, out BodyDescription) public void GetDescription(int index, out BodyDescription description) Parameters index int description BodyDescription"
  },
  "api/BepuPhysics.BodyVelocity.html": {
    "href": "api/BepuPhysics.BodyVelocity.html",
    "title": "Struct BodyVelocity | Bepu API",
    "keywords": "Struct BodyVelocity Namespace BepuPhysics Assembly BepuPhysics.dll Linear and angular velocity for a body. public struct BodyVelocity Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BodyVelocity(Vector3) Creates a new set of body velocities. Angular velocity is set to zero. public BodyVelocity(Vector3 linear) Parameters linear Vector3 Linear velocity to use for the body. BodyVelocity(Vector3, Vector3) Creates a new set of body velocities. public BodyVelocity(Vector3 linear, Vector3 angular) Parameters linear Vector3 Linear velocity to use for the body. angular Vector3 Angular velocity to use for the body. Fields Angular Angular velocity associated with the body. public Vector3 Angular Field Value Vector3 Linear Linear velocity associated with the body. public Vector3 Linear Field Value Vector3 Methods ToString() Returns a string representing the BodyVelocity as \"Linear, Angular\". public override string ToString() Returns string String representing the BodyVelocity. Operators implicit operator BodyVelocity(Vector3) Creates a body velocity by treating a Vector3 as a linear velocity. Angular velocity is set to zero. public static implicit operator BodyVelocity(Vector3 linearVelocity) Parameters linearVelocity Vector3 Linear velocity to use in the body velocity. Returns BodyVelocity implicit operator BodyVelocity((Vector3 linearVelocity, Vector3 angularVelocity)) Creates a body velocity from a tuple of linear and angular velocities.. public static implicit operator BodyVelocity((Vector3 linearVelocity, Vector3 angularVelocity) velocities) Parameters velocities (Vector3 linearVelocity, Vector3 angularVelocity) Velocities to use in the body velocity. Returns BodyVelocity"
  },
  "api/BepuPhysics.BodyVelocityWide.html": {
    "href": "api/BepuPhysics.BodyVelocityWide.html",
    "title": "Struct BodyVelocityWide | Bepu API",
    "keywords": "Struct BodyVelocityWide Namespace BepuPhysics Assembly BepuPhysics.dll public struct BodyVelocityWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Angular public Vector3Wide Angular Field Value Vector3Wide Linear public Vector3Wide Linear Field Value Vector3Wide"
  },
  "api/BepuPhysics.BoundingBoxBatch.html": {
    "href": "api/BepuPhysics.BoundingBoxBatch.html",
    "title": "Struct BoundingBoxBatch | Bepu API",
    "keywords": "Struct BoundingBoxBatch Namespace BepuPhysics Assembly BepuPhysics.dll public struct BoundingBoxBatch Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BoundingBoxBatch(BufferPool, int) public BoundingBoxBatch(BufferPool pool, int initialCapacity) Parameters pool BufferPool initialCapacity int Fields Continuations public Buffer<BoundsContinuation> Continuations Field Value Buffer<BoundsContinuation> Count public int Count Field Value int MotionStates public Buffer<MotionState> MotionStates Field Value Buffer<MotionState> ShapeIndices public Buffer<int> ShapeIndices Field Value Buffer<int> Properties Allocated public bool Allocated { get; } Property Value bool Methods Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool"
  },
  "api/BepuPhysics.BoundingBoxBatcher.html": {
    "href": "api/BepuPhysics.BoundingBoxBatcher.html",
    "title": "Struct BoundingBoxBatcher | Bepu API",
    "keywords": "Struct BoundingBoxBatcher Namespace BepuPhysics Assembly BepuPhysics.dll public struct BoundingBoxBatcher Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BoundingBoxBatcher(Bodies, Shapes, BroadPhase, BufferPool, float) public BoundingBoxBatcher(Bodies bodies, Shapes shapes, BroadPhase broadPhase, BufferPool pool, float dt) Parameters bodies Bodies shapes Shapes broadPhase BroadPhase pool BufferPool dt float Fields CollidablesPerFlush The number of bodies to accumulate per type before executing an AABB update. The more bodies per batch, the less virtual overhead and execution divergence. However, this should be kept low enough such that the data that has to be gathered by the bounding box update is still usually in L1. public const int CollidablesPerFlush = 16 Field Value int Methods Add(int, in RigidPose, in BodyVelocity, in Collidable) public void Add(int bodyIndex, in RigidPose pose, in BodyVelocity velocity, in Collidable collidable) Parameters bodyIndex int pose RigidPose velocity BodyVelocity collidable Collidable AddCompoundChild(int, TypedIndex, in RigidPose, in BodyVelocity) public void AddCompoundChild(int bodyIndex, TypedIndex shapeIndex, in RigidPose pose, in BodyVelocity velocity) Parameters bodyIndex int shapeIndex TypedIndex pose RigidPose velocity BodyVelocity ExecuteCompoundBatch<TShape>(CompoundShapeBatch<TShape>) public void ExecuteCompoundBatch<TShape>(CompoundShapeBatch<TShape> shapeBatch) where TShape : unmanaged, ICompoundShape Parameters shapeBatch CompoundShapeBatch<TShape> Type Parameters TShape ExecuteConvexBatch<TShape, TShapeWide>(ConvexShapeBatch<TShape, TShapeWide>) public void ExecuteConvexBatch<TShape, TShapeWide>(ConvexShapeBatch<TShape, TShapeWide> shapeBatch) where TShape : unmanaged, IConvexShape where TShapeWide : unmanaged, IShapeWide<TShape> Parameters shapeBatch ConvexShapeBatch<TShape, TShapeWide> Type Parameters TShape TShapeWide ExecuteHomogeneousCompoundBatch<TShape, TChildShape, TChildShapeWide>(HomogeneousCompoundShapeBatch<TShape, TChildShape, TChildShapeWide>) public void ExecuteHomogeneousCompoundBatch<TShape, TChildShape, TChildShapeWide>(HomogeneousCompoundShapeBatch<TShape, TChildShape, TChildShapeWide> shapeBatch) where TShape : unmanaged, IHomogeneousCompoundShape<TChildShape, TChildShapeWide> where TChildShape : unmanaged, IConvexShape where TChildShapeWide : unmanaged, IShapeWide<TChildShape> Parameters shapeBatch HomogeneousCompoundShapeBatch<TShape, TChildShape, TChildShapeWide> Type Parameters TShape TChildShape TChildShapeWide Flush() public void Flush()"
  },
  "api/BepuPhysics.BoundingBoxHelpers.html": {
    "href": "api/BepuPhysics.BoundingBoxHelpers.html",
    "title": "Class BoundingBoxHelpers | Bepu API",
    "keywords": "Class BoundingBoxHelpers Namespace BepuPhysics Assembly BepuPhysics.dll public static class BoundingBoxHelpers Inheritance object BoundingBoxHelpers Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExpandBoundingBox(in Vector3Wide, ref Vector3Wide, ref Vector3Wide) public static void ExpandBoundingBox(in Vector3Wide expansion, ref Vector3Wide min, ref Vector3Wide max) Parameters expansion Vector3Wide min Vector3Wide max Vector3Wide ExpandBoundingBox(Vector3, ref Vector3, ref Vector3) public static void ExpandBoundingBox(Vector3 expansion, ref Vector3 min, ref Vector3 max) Parameters expansion Vector3 min Vector3 max Vector3 ExpandBoundingBox(ref Vector3, ref Vector3, Vector3, Vector3, float, float, float, float) public static void ExpandBoundingBox(ref Vector3 min, ref Vector3 max, Vector3 linearVelocity, Vector3 angularVelocity, float dt, float maximumRadius, float maximumAngularExpansion, float maximumAllowedExpansion) Parameters min Vector3 max Vector3 linearVelocity Vector3 angularVelocity Vector3 dt float maximumRadius float maximumAngularExpansion float maximumAllowedExpansion float ExpandBoundingBoxes(BodyVelocityWide, Vector<float>, Vector<float>, Vector<float>, Vector<float>, ref Vector3Wide, ref Vector3Wide) public static void ExpandBoundingBoxes(BodyVelocityWide velocities, Vector<float> dtWide, Vector<float> maximumRadius, Vector<float> maximumAngularExpansion, Vector<float> maximumExpansion, ref Vector3Wide min, ref Vector3Wide max) Parameters velocities BodyVelocityWide dtWide Vector<float> maximumRadius Vector<float> maximumAngularExpansion Vector<float> maximumExpansion Vector<float> min Vector3Wide max Vector3Wide ExpandLocalBoundingBoxes(ref Vector3Wide, ref Vector3Wide, in Vector<float>, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector3Wide, float, in Vector<float>, in Vector<float>, in Vector<float>) Expands the bounding box surrounding a shape A in the local space of some other collidable B. public static void ExpandLocalBoundingBoxes(ref Vector3Wide min, ref Vector3Wide max, in Vector<float> radiusA, in Vector3Wide localPositionA, in Vector3Wide localRelativeLinearVelocityA, in Vector3Wide angularVelocityA, in Vector3Wide angularVelocityB, float dt, in Vector<float> maximumRadius, in Vector<float> maximumAngularExpansion, in Vector<float> maximumAllowedExpansion) Parameters min Vector3Wide max Vector3Wide radiusA Vector<float> localPositionA Vector3Wide localRelativeLinearVelocityA Vector3Wide angularVelocityA Vector3Wide angularVelocityB Vector3Wide dt float maximumRadius Vector<float> maximumAngularExpansion Vector<float> maximumAllowedExpansion Vector<float> GetAngularBoundsExpansion(Vector<float>, Vector<float>, Vector<float>, Vector<float>) public static Vector<float> GetAngularBoundsExpansion(Vector<float> angularSpeed, Vector<float> vectorDt, Vector<float> maximumRadius, Vector<float> maximumAngularExpansion) Parameters angularSpeed Vector<float> vectorDt Vector<float> maximumRadius Vector<float> maximumAngularExpansion Vector<float> Returns Vector<float> GetAngularBoundsExpansion(float, float, float, float) public static float GetAngularBoundsExpansion(float angularVelocityMagnitude, float dt, float maximumRadius, float maximumAngularExpansion) Parameters angularVelocityMagnitude float dt float maximumRadius float maximumAngularExpansion float Returns float GetBoundsExpansion(Vector3Wide, Vector3Wide, Vector<float>, Vector<float>, Vector<float>, out Vector3Wide, out Vector3Wide) public static void GetBoundsExpansion(Vector3Wide linearVelocity, Vector3Wide angularVelocity, Vector<float> dtWide, Vector<float> maximumRadius, Vector<float> maximumAngularExpansion, out Vector3Wide minBoundsExpansion, out Vector3Wide maxBoundsExpansion) Parameters linearVelocity Vector3Wide angularVelocity Vector3Wide dtWide Vector<float> maximumRadius Vector<float> maximumAngularExpansion Vector<float> minBoundsExpansion Vector3Wide maxBoundsExpansion Vector3Wide GetBoundsExpansion(Vector3Wide, Vector<float>, Vector<float>, out Vector3Wide, out Vector3Wide) public static void GetBoundsExpansion(Vector3Wide linearVelocity, Vector<float> dtWide, Vector<float> angularExpansion, out Vector3Wide minExpansion, out Vector3Wide maxExpansion) Parameters linearVelocity Vector3Wide dtWide Vector<float> angularExpansion Vector<float> minExpansion Vector3Wide maxExpansion Vector3Wide GetBoundsExpansion(Vector3, Vector3, float, float, float, float, out Vector3, out Vector3) public static void GetBoundsExpansion(Vector3 linearVelocity, Vector3 angularVelocity, float dt, float maximumRadius, float maximumAngularExpansion, float maximumAllowedExpansion, out Vector3 minExpansion, out Vector3 maxExpansion) Parameters linearVelocity Vector3 angularVelocity Vector3 dt float maximumRadius float maximumAngularExpansion float maximumAllowedExpansion float minExpansion Vector3 maxExpansion Vector3 GetBoundsExpansion(Vector3, float, float, out Vector3, out Vector3) public static void GetBoundsExpansion(Vector3 linearVelocity, float dt, float angularExpansion, out Vector3 minExpansion, out Vector3 maxExpansion) Parameters linearVelocity Vector3 dt float angularExpansion float minExpansion Vector3 maxExpansion Vector3 GetLocalBoundingBoxForSweep(TypedIndex, Shapes, in RigidPose, Quaternion, in BodyVelocity, Vector3, Quaternion, in BodyVelocity, float, out Vector3, out Vector3, out Vector3) Computes the bounding box of a child shape A in the local space of some other collidable B with a sweep direction representing the net linear motion. public static void GetLocalBoundingBoxForSweep(TypedIndex shapeIndex, Shapes shapes, in RigidPose shapePoseLocalToA, Quaternion orientationA, in BodyVelocity velocityA, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float dt, out Vector3 sweep, out Vector3 min, out Vector3 max) Parameters shapeIndex TypedIndex shapes Shapes shapePoseLocalToA RigidPose orientationA Quaternion velocityA BodyVelocity offsetB Vector3 orientationB Quaternion velocityB BodyVelocity dt float sweep Vector3 min Vector3 max Vector3 GetLocalBoundingBoxForSweep<TConvex>(ref TConvex, Quaternion, in BodyVelocity, Vector3, Quaternion, in BodyVelocity, float, out Vector3, out Vector3, out Vector3) Computes the bounding box of shape A in the local space of some other collidable B with a sweep direction representing the net linear motion. public static void GetLocalBoundingBoxForSweep<TConvex>(ref TConvex shape, Quaternion orientationA, in BodyVelocity velocityA, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float dt, out Vector3 sweep, out Vector3 min, out Vector3 max) where TConvex : struct, IConvexShape Parameters shape TConvex orientationA Quaternion velocityA BodyVelocity offsetB Vector3 orientationB Quaternion velocityB BodyVelocity dt float sweep Vector3 min Vector3 max Vector3 Type Parameters TConvex"
  },
  "api/BepuPhysics.BoundingBoxInstance.html": {
    "href": "api/BepuPhysics.BoundingBoxInstance.html",
    "title": "Struct BoundingBoxInstance | Bepu API",
    "keywords": "Struct BoundingBoxInstance Namespace BepuPhysics Assembly BepuPhysics.dll public struct BoundingBoxInstance Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Continuation public BoundsContinuation Continuation Field Value BoundsContinuation ShapeIndex public int ShapeIndex Field Value int"
  },
  "api/BepuPhysics.BoundsContinuation.html": {
    "href": "api/BepuPhysics.BoundsContinuation.html",
    "title": "Struct BoundsContinuation | Bepu API",
    "keywords": "Struct BoundsContinuation Namespace BepuPhysics Assembly BepuPhysics.dll public struct BoundsContinuation Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BodyIndex Gets the index of the body associated with this continuation. public int BodyIndex { get; } Property Value int CompoundChild Gets whether this continuation is associated with a compound's child. public bool CompoundChild { get; } Property Value bool Methods CreateCompoundChildContinuation(int) Creates a bounding box calculation continuation for a given compound body. public static BoundsContinuation CreateCompoundChildContinuation(int compoundBodyIndex) Parameters compoundBodyIndex int Index of the compound body to set the bounding box of. Returns BoundsContinuation CreateContinuation(int) Creates a bounding box calculation continuation for a given noncompound body. public static BoundsContinuation CreateContinuation(int bodyIndex) Parameters bodyIndex int Index of the body to set the bounding box of. Returns BoundsContinuation"
  },
  "api/BepuPhysics.CollidableProperty-1.html": {
    "href": "api/BepuPhysics.CollidableProperty-1.html",
    "title": "Class CollidableProperty<T> | Bepu API",
    "keywords": "Class CollidableProperty<T> Namespace BepuPhysics Assembly BepuPhysics.dll Convenience collection that stores extra properties about bodies and statics, indexed by the body or static handle. public class CollidableProperty<T> : IDisposable where T : unmanaged Type Parameters T Type of the data to store. Inheritance object CollidableProperty<T> Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This is built for use cases relying on random access like the narrow phase. For maximum performance with sequential access, an index-aligned structure would be better. Constructors CollidableProperty(Simulation, BufferPool) Constructs a new collection to store handle-aligned body and static properties. public CollidableProperty(Simulation simulation, BufferPool pool = null) Parameters simulation Simulation Simulation to track. pool BufferPool Pool from which to pull internal resources. If null, uses the Simulation pool. CollidableProperty(BufferPool) Constructs a new collection to store handle-aligned body properties. Assumes the Initialize function will be called later to provide the Bodies collection. public CollidableProperty(BufferPool pool = null) Parameters pool BufferPool Pool from which to pull internal resources. If null, uses the later Initialize-provided Bodies pool. Properties this[BodyHandle] Gets a reference to the properties associated with a body's handle. public ref T this[BodyHandle bodyHandle] { get; } Parameters bodyHandle BodyHandle Body handle to retrieve the properties for. Property Value T Reference to properties associated with a body handle. this[CollidableReference] Gets a reference to the properties associated with a collidable. public ref T this[CollidableReference collidable] { get; } Parameters collidable CollidableReference Collidable to retrieve the properties for. Property Value T Reference to properties associated with a collidable. this[StaticHandle] Gets a reference to the properties associated with a static's handle. public ref T this[StaticHandle staticHandle] { get; } Parameters staticHandle StaticHandle Static handle to retrieve the properties for. Property Value T Reference to properties associated with a static handle. Methods Allocate(BodyHandle) Ensures there is space for a given body handle and returns a reference to the used memory. public ref T Allocate(BodyHandle bodyHandle) Parameters bodyHandle BodyHandle Body handle to allocate for. Returns T Reference to the data for the given body. Allocate(CollidableReference) Ensures there is space for a given collidable reference and returns a reference to the used memory. public ref T Allocate(CollidableReference collidableReference) Parameters collidableReference CollidableReference Collidable reference to allocate for. Returns T Reference to the data for the given collidable. Allocate(StaticHandle) Ensures there is space for a given static handle and returns a reference to the used memory. public ref T Allocate(StaticHandle handle) Parameters handle StaticHandle Static handle to allocate for. Returns T Reference to the data for the given static. CompactBodies() Compacts the memory used by the collection for bodies to a safe minimum based on the Bodies collection. public void CompactBodies() CompactStatics() Compacts the memory used by the collection for statics to a safe minimum based on the Statics collection. public void CompactStatics() Dispose() Returns all held resources. public void Dispose() EnsureBodyCapacity(int) Ensures that the internal structures have at least the given capacity for bodies. public void EnsureBodyCapacity(int capacity) Parameters capacity int Capacity to ensure. EnsureStaticCapacity(int) Ensures that the internal structures have at least the given capacity for statics. public void EnsureStaticCapacity(int capacity) Parameters capacity int Capacity to ensure. Initialize(Simulation) Initializes the property collection if the Bodies/Statics-less constructor was used. public void Initialize(Simulation simulation) Parameters simulation Simulation Simulation whose bodies and statics will be tracked."
  },
  "api/BepuPhysics.Collidables.BigCompound.html": {
    "href": "api/BepuPhysics.Collidables.BigCompound.html",
    "title": "Struct BigCompound | Bepu API",
    "keywords": "Struct BigCompound Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Compound shape containing a bunch of shapes accessible through a tree acceleration structure. Useful for compounds with lots of children. public struct BigCompound : ICompoundShape, IDisposableShape, IShape, IBoundsQueryableCompound Implements ICompoundShape IDisposableShape IShape IBoundsQueryableCompound Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BigCompound(Buffer<CompoundChild>, Shapes, BufferPool, IThreadDispatcher) Creates a compound shape with an acceleration structure. public BigCompound(Buffer<CompoundChild> children, Shapes shapes, BufferPool pool, IThreadDispatcher dispatcher = null) Parameters children Buffer<CompoundChild> Set of children in the compound. shapes Shapes Shapes set in which child shapes are allocated. pool BufferPool Pool to use to allocate acceleration structures. dispatcher IThreadDispatcher Thread dispatcher to use to multithread the acceleration structure build, if any. Fields Children Buffer of children within this compound. public Buffer<CompoundChild> Children Field Value Buffer<CompoundChild> Id Type id of compound shapes. public const int Id = 7 Field Value int Tree Acceleration structure for the compound children. public Tree Tree Field Value Tree Properties ChildCount Gets the number of children in the compound shape. public int ChildCount { get; } Property Value int TypeId Unique type id for this shape type. public static int TypeId { get; } Property Value int Methods Add(CompoundChild, BufferPool, Shapes) Adds a child to the compound. public void Add(CompoundChild child, BufferPool pool, Shapes shapes) Parameters child CompoundChild Child to add to the compound. pool BufferPool Pool to use to resize the compound's children buffer if necessary. shapes Shapes Shapes collection containing the compound's children. Remarks This function keeps the Tree in a valid state, but significant changes over time may degrade the tree's quality and result in reduced collision/query performance. If this happens, consider calling RefitAndRefine(BufferPool, int, float) with a refinementIndex that changes with each call (to prioritize different parts of the tree). Incrementing a counter with each call would work fine. The ideal frequency of refinement depends on the kind of modifications being made, but it's likely to be rare. AddChildBoundsToBatcher(ref BoundingBoxBatcher, in RigidPose, in BodyVelocity, int) Submits child shapes to a bounding box batcher for vectorized bounds calculation. public void AddChildBoundsToBatcher(ref BoundingBoxBatcher batcher, in RigidPose pose, in BodyVelocity velocity, int bodyIndex) Parameters batcher BoundingBoxBatcher Batcher to accumulate children in. pose RigidPose Pose of the compound. velocity BodyVelocity Velocity of the compound used to expand child bounds. bodyIndex int Index of the body in the active body set; used to accumulate child bounds results. Remarks This is used internally for bounding box calculation, but it is unlikely to be useful externally. ComputeBounds(Quaternion, Shapes, out Vector3, out Vector3) Computes the bounding box of a compound shape. public void ComputeBounds(Quaternion orientation, Shapes shapeBatches, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the compound. shapeBatches Shapes Shape batches to look up child shape information in. min Vector3 Minimum of the compound's bounding box. max Vector3 Maximum of the compound's bounding box. ComputeInertia(Span<float>, Shapes) Computes the inertia of a compound. Does not recenter the child poses. public BodyInertia ComputeInertia(Span<float> childMasses, Shapes shapes) Parameters childMasses Span<float> Masses of the children. shapes Shapes Shapes collection containing the data for the compound child shapes. Returns BodyInertia Inertia of the compound. ComputeInertia(Span<float>, Shapes, out Vector3) Computes the inertia of a compound. Recenters the child poses around the calculated center of mass. public BodyInertia ComputeInertia(Span<float> childMasses, Shapes shapes, out Vector3 centerOfMass) Parameters childMasses Span<float> Masses of the children. shapes Shapes Shapes collection containing the data for the compound child shapes. centerOfMass Vector3 Calculated center of mass of the compound. Subtracted from all the compound child poses. Returns BodyInertia Inertia of the compound. CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapes) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapes Shapes Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine. CreateWithSweepBuild(Buffer<CompoundChild>, Shapes, BufferPool) Creates a compound shape instance and builds an acceleration structure using a sweep builder. public static BigCompound CreateWithSweepBuild(Buffer<CompoundChild> children, Shapes shapes, BufferPool pool) Parameters children Buffer<CompoundChild> Children to use in the compound. shapes Shapes Shapes set in which child shapes are allocated. pool BufferPool Pool used to allocate acceleration structures. Returns BigCompound Created compound shape. Remarks The sweep builder is significantly slower than the binned builder, but can sometimes create higher quality trees. Note that the binned builder can be tuned to create higher quality trees. That is usually a better choice than trying to use the sweep builder; this is here primarily for legacy reasons. CreateWithoutTreeBuild(Buffer<CompoundChild>, BufferPool) Creates a BigCompound shape instance, but leaves the Tree in an unbuilt state. The Tree must be built before the compound can be used. public static BigCompound CreateWithoutTreeBuild(Buffer<CompoundChild> children, BufferPool pool) Parameters children Buffer<CompoundChild> Children to use in the compound. pool BufferPool Pool used to allocate acceleration structures. Returns BigCompound Created compound shape. Remarks In some cases, the default binned build may not be the ideal builder. This function does everything needed to set up a tree without the expense of figuring out the details of the acceleration structure. The user can then run whatever build/refinement process is appropriate. Dispose(BufferPool) Returns all resources used by the shape instance to the given pool. public void Dispose(BufferPool bufferPool) Parameters bufferPool BufferPool FillSubtreesForChildren(Span<CompoundChild>, Shapes, Span<NodeChild>) Fills a buffer of subtrees according to a buffer of triangles. public static void FillSubtreesForChildren(Span<CompoundChild> children, Shapes shapes, Span<NodeChild> subtrees) Parameters children Span<CompoundChild> Children to build subtrees from. shapes Shapes Shapes set in which child shapes are allocated. subtrees Span<NodeChild> Subtrees created for the triangles. Remarks The term \"subtree\" is used because the binned builder does not care whether the input came from leaf nodes or a refinement process's internal nodes. FindLocalOverlaps<TOverlaps>(Vector3, Vector3, Vector3, float, BufferPool, Shapes, void*) public void FindLocalOverlaps<TOverlaps>(Vector3 min, Vector3 max, Vector3 sweep, float maximumT, BufferPool pool, Shapes shapes, void* overlaps) where TOverlaps : ICollisionTaskSubpairOverlaps Parameters min Vector3 max Vector3 sweep Vector3 maximumT float pool BufferPool shapes Shapes overlaps void* Type Parameters TOverlaps FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair>, BufferPool, Shapes, ref TOverlaps) public void FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair> pairs, BufferPool pool, Shapes shapes, ref TOverlaps overlaps) where TOverlaps : struct, ICollisionTaskOverlaps<TSubpairOverlaps> where TSubpairOverlaps : struct, ICollisionTaskSubpairOverlaps Parameters pairs Buffer<OverlapQueryForPair> pool BufferPool shapes Shapes overlaps TOverlaps Type Parameters TOverlaps TSubpairOverlaps GetChild(int) Gets a child from the compound by index. public ref CompoundChild GetChild(int compoundChildIndex) Parameters compoundChildIndex int Index of the child to look up. Returns CompoundChild Reference to the requested compound child. RayTest<TRayHitHandler>(in RigidPose, in RayData, ref float, Shapes, ref TRayHitHandler) Tests a ray against the shape. public void RayTest<TRayHitHandler>(in RigidPose pose, in RayData ray, ref float maximumT, Shapes shapes, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the shape during the ray test. ray RayData Ray to test against the shape. maximumT float Maximum distance along the ray, in units of the ray direction's length, that the ray will test. shapes Shapes hitHandler TRayHitHandler Callbacks called when the ray interacts with a test candidate. Type Parameters TRayHitHandler RayTest<TRayHitHandler>(in RigidPose, ref RaySource, Shapes, ref TRayHitHandler) Tests multiple rays against the shape. public void RayTest<TRayHitHandler>(in RigidPose pose, ref RaySource rays, Shapes shapes, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the shape during the ray test. rays RaySource Rays to test against the shape. shapes Shapes hitHandler TRayHitHandler Callbacks called when the ray interacts with a test candidate. Type Parameters TRayHitHandler RemoveAt(int, BufferPool) Removes a child from the compound by index. The last child is pulled to fill the gap left by the removed child. public void RemoveAt(int childIndex, BufferPool pool) Parameters childIndex int Index of the child to remove from the compound. pool BufferPool Pool to use to resize the compound's children buffer if necessary. Remarks This function keeps the Tree in a valid state, but significant changes over time may degrade the tree's quality and result in reduced collision/query performance. If this happens, consider calling RefitAndRefine(BufferPool, int, float) with a refinementIndex that changes with each call (to prioritize different parts of the tree). Incrementing a counter with each call would work fine. The ideal frequency of refinement depends on the kind of modifications being made, but it's likely to be rare."
  },
  "api/BepuPhysics.Collidables.Box.html": {
    "href": "api/BepuPhysics.Collidables.Box.html",
    "title": "Struct Box | Bepu API",
    "keywords": "Struct Box Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Collision shape representing a solid cuboid. public struct Box : IConvexShape, IShape Implements IConvexShape IShape Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Box(float, float, float) Creates a Box shape. public Box(float width, float height, float length) Parameters width float Width of the box along the local X axis. height float Height of the box along the local Y axis. length float Length of the box along the local Z axis. Fields HalfHeight Half of the box's height along its local Y axis. public float HalfHeight Field Value float HalfLength Half of the box's length along its local Z axis. public float HalfLength Field Value float HalfWidth Half of the box's width along its local X axis. public float HalfWidth Field Value float Id Type id of box shapes. public const int Id = 2 Field Value int Properties Height Gets or sets the height of the box along its local Y axis. public float Height { get; set; } Property Value float Length Gets or sets the length of the box along its local Z axis. public float Length { get; set; } Property Value float TypeId Unique type id for this shape type. public static int TypeId { get; } Property Value int Width Gets or sets the width of the box along its local X axis. public float Width { get; set; } Property Value float Methods ComputeAngularExpansionData(out float, out float) Computes information about how the bounding box should be expanded in response to angular velocity. public readonly void ComputeAngularExpansionData(out float maximumRadius, out float maximumAngularExpansion) Parameters maximumRadius float maximumAngularExpansion float Remarks This is typically used in the engine for predicting bounding boxes at the beginning of the frame. Velocities are used to expand the bounding box so that likely future collisions will be detected. Linear velocity expands the bounding box in a direct and simple way, but angular expansion requires more information about the shape. Imagine a long and thin capsule versus a sphere: high angular velocity may require significant expansion on the capsule, but spheres are rotationally invariant. ComputeBounds(Quaternion, out Vector3, out Vector3) Computes the bounding box of a shape given an orientation. public readonly void ComputeBounds(Quaternion orientation, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the shape to use when computing the bounding box. min Vector3 Minimum corner of the bounding box. max Vector3 Maximum corner of the bounding box. ComputeInertia(float) Computes the inertia for a body given a mass. public readonly BodyInertia ComputeInertia(float mass) Parameters mass float Mass to use to compute the body's inertia. Returns BodyInertia Inertia for the body. Remarks Note that the BodyInertia returned by this stores the inverse mass and inverse inertia tensor. This is because the most high frequency use of body inertia most naturally uses the inverse. CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapeBatches) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapeBatches Shapes The set of shapes to contain this batch. Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine. RayTest(in RigidPose, Vector3, Vector3, out float, out Vector3) Tests a ray against the shape. public readonly bool RayTest(in RigidPose pose, Vector3 origin, Vector3 direction, out float t, out Vector3 normal) Parameters pose RigidPose Pose of the shape during the ray test. origin Vector3 Origin of the ray to test against the shape relative to the shape. direction Vector3 Direction of the ray to test against the shape. t float Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3 Normal of the impact surface, if any. Returns bool True if the ray intersected the shape, false otherwise."
  },
  "api/BepuPhysics.Collidables.BoxSupportFinder.html": {
    "href": "api/BepuPhysics.Collidables.BoxSupportFinder.html",
    "title": "Struct BoxSupportFinder | Bepu API",
    "keywords": "Struct BoxSupportFinder Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct BoxSupportFinder : ISupportFinder<Box, BoxWide> Implements ISupportFinder<Box, BoxWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties HasMargin Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape. public bool HasMargin { get; } Property Value bool Methods ComputeLocalSupport(in BoxWide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeLocalSupport(in BoxWide shape, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape BoxWide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide ComputeSupport(in BoxWide, in Matrix3x3Wide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeSupport(in BoxWide shape, in Matrix3x3Wide orientation, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape BoxWide orientation Matrix3x3Wide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide GetMargin(in BoxWide, out Vector<float>) Margin associated with the shape according to this support finder. public void GetMargin(in BoxWide shape, out Vector<float> margin) Parameters shape BoxWide Shape to find the margin of. margin Vector<float> Margin of the shape."
  },
  "api/BepuPhysics.Collidables.BoxWide.html": {
    "href": "api/BepuPhysics.Collidables.BoxWide.html",
    "title": "Struct BoxWide | Bepu API",
    "keywords": "Struct BoxWide Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct BoxWide : IShapeWide<Box> Implements IShapeWide<Box> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields HalfHeight public Vector<float> HalfHeight Field Value Vector<float> HalfLength public Vector<float> HalfLength Field Value Vector<float> HalfWidth public Vector<float> HalfWidth Field Value Vector<float> Properties AllowOffsetMemoryAccess Gets whether this type supports accessing its memory by lane offsets. If false, WriteSlot must be used instead of WriteFirst. public bool AllowOffsetMemoryAccess { get; } Property Value bool InternalAllocationSize Gets the number of bytes required for allocations within the wide shape. public int InternalAllocationSize { get; } Property Value int MinimumWideRayCount Gets the lower bound on the number of rays to execute in a wide fashion. Ray bundles with fewer rays will fall back to the single ray code path. public static int MinimumWideRayCount { get; } Property Value int Methods Broadcast(in Box) Broadcasts a scalar shape into a bundle containing the same shape in every lane. public void Broadcast(in Box shape) Parameters shape Box Scalar shape to broadcast. GetBounds(ref QuaternionWide, int, out Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide) Computes the bounds of all shapes in the bundle. public void GetBounds(ref QuaternionWide orientations, int countInBundle, out Vector<float> maximumRadius, out Vector<float> maximumAngularExpansion, out Vector3Wide min, out Vector3Wide max) Parameters orientations QuaternionWide Orientations of the shapes in the bundle. countInBundle int Number of lanes filled in the bundle. maximumRadius Vector<float> Computed maximum radius of the shapes in the bundle. maximumAngularExpansion Vector<float> Computed maximum bounds expansion that can be caused by angular motion. min Vector3Wide Minimum bounds of the shapes. max Vector3Wide Maximum bounds of the shapes. Initialize(in Buffer<byte>) For types with a nonzero internal allocation size, provides memory to the shape for internal allocations. Memory should be assumed to be stack allocated. public void Initialize(in Buffer<byte> memory) Parameters memory Buffer<byte> Memory to use for internal allocations in the wide shape. RayTest(ref RigidPoseWide, ref RayWide, out Vector<int>, out Vector<float>, out Vector3Wide) Tests a ray against the shape. public void RayTest(ref RigidPoseWide pose, ref RayWide ray, out Vector<int> intersected, out Vector<float> t, out Vector3Wide normal) Parameters pose RigidPoseWide ray RayWide intersected Vector<int> Mask representing hit state in each lane. -1 means the ray in that lane hit, 0 means a miss. t Vector<float> Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3Wide Normal of the impact surface, if any. WriteFirst(in Box) Places the specified AOS-formatted shape into the first lane of the wide 'this' reference. public void WriteFirst(in Box source) Parameters source Box AOS-formatted shape to gather from. Remarks Note that we are effectively using the TShapeWide as a stride. The base address is offset by the user of this function, so the implementation only ever considers the first slot. WriteSlot(int, in Box) Places the specified AOS-formatted shape into the selected slot of the wide 'this' reference. public void WriteSlot(int index, in Box source) Parameters index int Index of the slot to put the data into. source Box Source of the data to insert."
  },
  "api/BepuPhysics.Collidables.Capsule.html": {
    "href": "api/BepuPhysics.Collidables.Capsule.html",
    "title": "Struct Capsule | Bepu API",
    "keywords": "Struct Capsule Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Collision shape representing a sphere-expanded line segment. public struct Capsule : IConvexShape, IShape Implements IConvexShape IShape Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Capsule(float, float) Creates a capsule shape. public Capsule(float radius, float length) Parameters radius float Radius of the capsule. length float Length of the capsule's internal line segment along the local Y axis. Fields HalfLength Half of the length of the internal line segment. Oriented along the local Y axis. public float HalfLength Field Value float Id Type id of capsule shapes. public const int Id = 1 Field Value int Radius Spherical expansion applied to the internal line segment. public float Radius Field Value float Properties Length Gets or sets the length of the capsule's internal line segment along the local Y axis. public float Length { get; set; } Property Value float TypeId Unique type id for this shape type. public static int TypeId { get; } Property Value int Methods ComputeAngularExpansionData(out float, out float) Computes information about how the bounding box should be expanded in response to angular velocity. public readonly void ComputeAngularExpansionData(out float maximumRadius, out float maximumAngularExpansion) Parameters maximumRadius float maximumAngularExpansion float Remarks This is typically used in the engine for predicting bounding boxes at the beginning of the frame. Velocities are used to expand the bounding box so that likely future collisions will be detected. Linear velocity expands the bounding box in a direct and simple way, but angular expansion requires more information about the shape. Imagine a long and thin capsule versus a sphere: high angular velocity may require significant expansion on the capsule, but spheres are rotationally invariant. ComputeBounds(Quaternion, out Vector3, out Vector3) Computes the bounding box of a shape given an orientation. public readonly void ComputeBounds(Quaternion orientation, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the shape to use when computing the bounding box. min Vector3 Minimum corner of the bounding box. max Vector3 Maximum corner of the bounding box. ComputeInertia(float) Computes the inertia for a body given a mass. public readonly BodyInertia ComputeInertia(float mass) Parameters mass float Mass to use to compute the body's inertia. Returns BodyInertia Inertia for the body. Remarks Note that the BodyInertia returned by this stores the inverse mass and inverse inertia tensor. This is because the most high frequency use of body inertia most naturally uses the inverse. CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapeBatches) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapeBatches Shapes The set of shapes to contain this batch. Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine. RayTest(in RigidPose, Vector3, Vector3, out float, out Vector3) Tests a ray against the shape. public readonly bool RayTest(in RigidPose pose, Vector3 origin, Vector3 direction, out float t, out Vector3 normal) Parameters pose RigidPose Pose of the shape during the ray test. origin Vector3 Origin of the ray to test against the shape relative to the shape. direction Vector3 Direction of the ray to test against the shape. t float Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3 Normal of the impact surface, if any. Returns bool True if the ray intersected the shape, false otherwise."
  },
  "api/BepuPhysics.Collidables.CapsuleSupportFinder.html": {
    "href": "api/BepuPhysics.Collidables.CapsuleSupportFinder.html",
    "title": "Struct CapsuleSupportFinder | Bepu API",
    "keywords": "Struct CapsuleSupportFinder Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct CapsuleSupportFinder : ISupportFinder<Capsule, CapsuleWide> Implements ISupportFinder<Capsule, CapsuleWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties HasMargin Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape. public bool HasMargin { get; } Property Value bool Methods ComputeLocalSupport(in CapsuleWide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeLocalSupport(in CapsuleWide shape, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape CapsuleWide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide ComputeSupport(in CapsuleWide, in Matrix3x3Wide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeSupport(in CapsuleWide shape, in Matrix3x3Wide orientation, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape CapsuleWide orientation Matrix3x3Wide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide GetMargin(in CapsuleWide, out Vector<float>) Margin associated with the shape according to this support finder. public void GetMargin(in CapsuleWide shape, out Vector<float> margin) Parameters shape CapsuleWide Shape to find the margin of. margin Vector<float> Margin of the shape."
  },
  "api/BepuPhysics.Collidables.CapsuleWide.html": {
    "href": "api/BepuPhysics.Collidables.CapsuleWide.html",
    "title": "Struct CapsuleWide | Bepu API",
    "keywords": "Struct CapsuleWide Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct CapsuleWide : IShapeWide<Capsule> Implements IShapeWide<Capsule> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields HalfLength public Vector<float> HalfLength Field Value Vector<float> Radius public Vector<float> Radius Field Value Vector<float> Properties AllowOffsetMemoryAccess Gets whether this type supports accessing its memory by lane offsets. If false, WriteSlot must be used instead of WriteFirst. public bool AllowOffsetMemoryAccess { get; } Property Value bool InternalAllocationSize Gets the number of bytes required for allocations within the wide shape. public int InternalAllocationSize { get; } Property Value int MinimumWideRayCount Gets the lower bound on the number of rays to execute in a wide fashion. Ray bundles with fewer rays will fall back to the single ray code path. public static int MinimumWideRayCount { get; } Property Value int Methods Broadcast(in Capsule) Broadcasts a scalar shape into a bundle containing the same shape in every lane. public void Broadcast(in Capsule shape) Parameters shape Capsule Scalar shape to broadcast. GetBounds(ref QuaternionWide, int, out Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide) Computes the bounds of all shapes in the bundle. public void GetBounds(ref QuaternionWide orientations, int countInBundle, out Vector<float> maximumRadius, out Vector<float> maximumAngularExpansion, out Vector3Wide min, out Vector3Wide max) Parameters orientations QuaternionWide Orientations of the shapes in the bundle. countInBundle int Number of lanes filled in the bundle. maximumRadius Vector<float> Computed maximum radius of the shapes in the bundle. maximumAngularExpansion Vector<float> Computed maximum bounds expansion that can be caused by angular motion. min Vector3Wide Minimum bounds of the shapes. max Vector3Wide Maximum bounds of the shapes. Initialize(in Buffer<byte>) For types with a nonzero internal allocation size, provides memory to the shape for internal allocations. Memory should be assumed to be stack allocated. public void Initialize(in Buffer<byte> memory) Parameters memory Buffer<byte> Memory to use for internal allocations in the wide shape. RayTest(ref RigidPoseWide, ref RayWide, out Vector<int>, out Vector<float>, out Vector3Wide) Tests a ray against the shape. public void RayTest(ref RigidPoseWide pose, ref RayWide ray, out Vector<int> intersected, out Vector<float> t, out Vector3Wide normal) Parameters pose RigidPoseWide ray RayWide intersected Vector<int> Mask representing hit state in each lane. -1 means the ray in that lane hit, 0 means a miss. t Vector<float> Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3Wide Normal of the impact surface, if any. WriteFirst(in Capsule) Places the specified AOS-formatted shape into the first lane of the wide 'this' reference. public void WriteFirst(in Capsule source) Parameters source Capsule AOS-formatted shape to gather from. Remarks Note that we are effectively using the TShapeWide as a stride. The base address is offset by the user of this function, so the implementation only ever considers the first slot. WriteSlot(int, in Capsule) Places the specified AOS-formatted shape into the selected slot of the wide 'this' reference. public void WriteSlot(int index, in Capsule source) Parameters index int Index of the slot to put the data into. source Capsule Source of the data to insert."
  },
  "api/BepuPhysics.Collidables.Collidable.html": {
    "href": "api/BepuPhysics.Collidables.Collidable.html",
    "title": "Struct Collidable | Bepu API",
    "keywords": "Struct Collidable Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Description of a collidable used by a body living in the broad phase and able to generate collision pairs. Collidables with a ShapeIndex that points to nothing (a default constructed TypedIndex) are not capable of colliding with anything. This can be used for a body which needs no collidable representation. public struct Collidable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields BroadPhaseIndex Index of the collidable in the broad phase. Used to look up the target location for bounding box scatters. Under normal circumstances, this should not be set externally. public int BroadPhaseIndex Field Value int Continuity Continuous collision detection settings for this collidable. Includes the collision detection mode to use and tuning variables associated with those modes. public ContinuousDetection Continuity Field Value ContinuousDetection MaximumSpeculativeMargin Upper bound on the value of the speculative margin used by the collidable. public float MaximumSpeculativeMargin Field Value float Remarks MaxValue tends to be a good default value for discrete or passive mode collidables. The speculative margin will increase in size proportional to velocity magnitude, so having an unlimited maximum won't cost extra if the body isn't moving fast. Smaller values can be useful for improving performance in chaotic situations where missing a collision is acceptable. When using Continuous, a speculative margin larger than the velocity magnitude will result in the sweep test being skipped, so lowering the maximum margin can help avoid ghost collisions. MinimumSpeculativeMargin Lower bound on the value of the speculative margin used by the collidable. public float MinimumSpeculativeMargin Field Value float Remarks 0 tends to be a good default value. Higher values can be chosen if velocity magnitude is a poor proxy for speculative margins, but these cases are rare. In those cases, try to use the smallest value that still satisfies requirements to avoid creating unnecessary contact constraints. Shape Index of the shape used by the body. While this can be changed, any transition from shapeless->shapeful or shapeful->shapeless must be reported to the broad phase. If you need to perform such a transition, consider using SetShape(BodyHandle, TypedIndex) or ApplyDescription(BodyHandle, in BodyDescription); those functions update the relevant state. public TypedIndex Shape Field Value TypedIndex SpeculativeMargin Automatically computed size of the margin around the surface of the shape in which contacts can be generated. These contacts will have negative depth and only contribute if the frame's velocities would push the shapes of a pair into overlap. This is automatically set by bounding box prediction each frame, and is bound by the collidable's MinimumSpeculativeMargin and MaximumSpeculativeMargin values. The effective speculative margin for a collision pair can also be modified from INarrowPhaseCallbacks callbacks. This should be positive to avoid jittering. It can also be used as a form of continuous collision detection, but excessively high values combined with fast motion may result in visible 'ghost collision' artifacts. For continuous collision detection with less chance of ghost collisions, use Continuous. If using Continuous, consider setting MaximumSpeculativeMargin to a smaller value to help filter ghost collisions. For more information, see the ContinuousCollisionDetection.md documentation. public float SpeculativeMargin Field Value float"
  },
  "api/BepuPhysics.Collidables.CollidableDescription.html": {
    "href": "api/BepuPhysics.Collidables.CollidableDescription.html",
    "title": "Struct CollidableDescription | Bepu API",
    "keywords": "Struct CollidableDescription Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Describes a collidable and how it should handle continuous collision detection. public struct CollidableDescription Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CollidableDescription(TypedIndex) Constructs a new collidable description with Passive. Will use a MinimumSpeculativeMargin of 0 and a MaximumSpeculativeMargin of MaxValue. public CollidableDescription(TypedIndex shape) Parameters shape TypedIndex Shape used by the collidable. Remarks Passive and Discrete are equivalent in behavior when the MaximumSpeculativeMargin is MaxValue since they both result in the same (unbounded) expansion of body bounding boxes in response to velocity. CollidableDescription(TypedIndex, ContinuousDetection) Constructs a new collidable description. Uses 0 for the MinimumSpeculativeMargin and MaxValue for the MaximumSpeculativeMargin . public CollidableDescription(TypedIndex shape, ContinuousDetection continuity) Parameters shape TypedIndex Shape used by the collidable. continuity ContinuousDetection Continuous collision detection settings for the collidable. CollidableDescription(TypedIndex, float) Constructs a new collidable description with Discrete. Will use a minimum speculative margin of 0 and the given maximumSpeculativeMargin. public CollidableDescription(TypedIndex shape, float maximumSpeculativeMargin) Parameters shape TypedIndex Shape used by the collidable. maximumSpeculativeMargin float Maximum speculative margin to be used with the discrete continuity configuration. CollidableDescription(TypedIndex, float, ContinuousDetection) Constructs a new collidable description. Uses 0 for the MinimumSpeculativeMargin . public CollidableDescription(TypedIndex shape, float maximumSpeculativeMargin, ContinuousDetection continuity) Parameters shape TypedIndex Shape used by the collidable. maximumSpeculativeMargin float Upper bound on the value of the speculative margin used by the collidable. continuity ContinuousDetection Continuous collision detection settings for the collidable. CollidableDescription(TypedIndex, float, float) Constructs a new collidable description with Discrete. public CollidableDescription(TypedIndex shape, float minimumSpeculativeMargin, float maximumSpeculativeMargin) Parameters shape TypedIndex Shape used by the collidable. minimumSpeculativeMargin float Lower bound on the value of the speculative margin used by the collidable. maximumSpeculativeMargin float Upper bound on the value of the speculative margin used by the collidable. CollidableDescription(TypedIndex, float, float, ContinuousDetection) Constructs a new collidable description. public CollidableDescription(TypedIndex shape, float minimumSpeculativeMargin, float maximumSpeculativeMargin, ContinuousDetection continuity) Parameters shape TypedIndex Shape used by the collidable. minimumSpeculativeMargin float Lower bound on the value of the speculative margin used by the collidable. maximumSpeculativeMargin float Upper bound on the value of the speculative margin used by the collidable. continuity ContinuousDetection Continuous collision detection settings for the collidable. Fields Continuity Continuous collision detection settings used by the collidable. public ContinuousDetection Continuity Field Value ContinuousDetection MaximumSpeculativeMargin Upper bound on the value of the speculative margin used by the collidable. public float MaximumSpeculativeMargin Field Value float Remarks MaxValue tends to be a good default value for discrete or passive mode collidables. The speculative margin will increase in size proportional to velocity magnitude, so having an unlimited maximum won't cost extra if the body isn't moving fast. Smaller values can be useful for improving performance in chaotic situations where missing a collision is acceptable. When using Continuous, a speculative margin larger than the velocity magnitude will result in the sweep test being skipped, so lowering the maximum margin can help avoid ghost collisions. MinimumSpeculativeMargin Lower bound on the value of the speculative margin used by the collidable. public float MinimumSpeculativeMargin Field Value float Remarks 0 tends to be a good default value. Higher values can be chosen if velocity magnitude is a poor proxy for speculative margins, but these cases are rare. In those cases, try to use the smallest value that still satisfies requirements to avoid creating unnecessary contact constraints. Shape Shape of the collidable. public TypedIndex Shape Field Value TypedIndex Operators implicit operator CollidableDescription(TypedIndex) Constructs a new collidable description with Passive. Will use a minimum speculative margin of 0 and a maximum of MaxValue. public static implicit operator CollidableDescription(TypedIndex shapeIndex) Parameters shapeIndex TypedIndex Shape index to use for the collidable. Returns CollidableDescription"
  },
  "api/BepuPhysics.Collidables.CollidableMobility.html": {
    "href": "api/BepuPhysics.Collidables.CollidableMobility.html",
    "title": "Enum CollidableMobility | Bepu API",
    "keywords": "Enum CollidableMobility Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Represents how a collidable can interact and move. public enum CollidableMobility Fields Dynamic = 0 Marks a collidable as owned by a dynamic body. Kinematic = 1 Marks a collidable as owned by a kinematic body. Static = 2 Marks the collidable as an independent immobile collidable."
  },
  "api/BepuPhysics.Collidables.CollidableReference.html": {
    "href": "api/BepuPhysics.Collidables.CollidableReference.html",
    "title": "Struct CollidableReference | Bepu API",
    "keywords": "Struct CollidableReference Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Uses a bitpacked representation to refer to a body or static collidable. public struct CollidableReference : IEquatable<CollidableReference> Implements IEquatable<CollidableReference> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CollidableReference(CollidableMobility, BodyHandle) Creates a collidable reference for a body. public CollidableReference(CollidableMobility mobility, BodyHandle handle) Parameters mobility CollidableMobility Mobility type of the owner of the collidable. handle BodyHandle Handle of the owner of the collidable. CollidableReference(StaticHandle) Creates a collidable reference for a static. public CollidableReference(StaticHandle handle) Parameters handle StaticHandle Handle of the owner of the collidable. Fields Packed Bitpacked representation of the collidable reference. public uint Packed Field Value uint Properties BodyHandle Gets the body handle of the owner of the collidable referred to by this instance. public BodyHandle BodyHandle { get; } Property Value BodyHandle Mobility Gets the mobility state of the owner of this collidable. public CollidableMobility Mobility { get; } Property Value CollidableMobility RawHandleValue Gets the integer value of the handle of the owner of the collidable referred to by this instance. public int RawHandleValue { get; } Property Value int StaticHandle Gets the static handle of the owner of the collidable referred to by this instance. public StaticHandle StaticHandle { get; } Property Value StaticHandle Methods Equals(CollidableReference) Indicates whether the current object is equal to another object of the same type. public bool Equals(CollidableReference other) Parameters other CollidableReference An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object other) Parameters other object Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(CollidableReference, CollidableReference) public static bool operator ==(CollidableReference x, CollidableReference y) Parameters x CollidableReference y CollidableReference Returns bool operator !=(CollidableReference, CollidableReference) public static bool operator !=(CollidableReference x, CollidableReference y) Parameters x CollidableReference y CollidableReference Returns bool"
  },
  "api/BepuPhysics.Collidables.CollidableReferenceComparer.html": {
    "href": "api/BepuPhysics.Collidables.CollidableReferenceComparer.html",
    "title": "Struct CollidableReferenceComparer | Bepu API",
    "keywords": "Struct CollidableReferenceComparer Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct CollidableReferenceComparer : IEqualityComparerRef<CollidableReference> Implements IEqualityComparerRef<CollidableReference> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Equals(ref CollidableReference, ref CollidableReference) public bool Equals(ref CollidableReference a, ref CollidableReference b) Parameters a CollidableReference b CollidableReference Returns bool Hash(ref CollidableReference) public int Hash(ref CollidableReference item) Parameters item CollidableReference Returns int"
  },
  "api/BepuPhysics.Collidables.Compound.html": {
    "href": "api/BepuPhysics.Collidables.Compound.html",
    "title": "Struct Compound | Bepu API",
    "keywords": "Struct Compound Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Minimalist compound shape containing a list of child shapes. Does not make use of any internal acceleration structure; should be used only with small groups of shapes. public struct Compound : ICompoundShape, IDisposableShape, IShape, IBoundsQueryableCompound Implements ICompoundShape IDisposableShape IShape IBoundsQueryableCompound Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Compound(Buffer<CompoundChild>) Creates a compound shape with no acceleration structure. public Compound(Buffer<CompoundChild> children) Parameters children Buffer<CompoundChild> Set of children in the compound. Fields Children Buffer of children within this compound. public Buffer<CompoundChild> Children Field Value Buffer<CompoundChild> Id Type id of list based compound shapes. public const int Id = 6 Field Value int Properties ChildCount Gets the number of children in the compound shape. public int ChildCount { get; } Property Value int TypeId Unique type id for this shape type. public static int TypeId { get; } Property Value int Methods Add(CompoundChild, BufferPool) Adds a child to the compound. public void Add(CompoundChild child, BufferPool pool) Parameters child CompoundChild Child to add to the compound. pool BufferPool Pool to use to resize the compound's children buffer if necessary. AddChildBoundsToBatcher(ref BoundingBoxBatcher, in RigidPose, in BodyVelocity, int) Submits child shapes to a bounding box batcher for vectorized bounds calculation. public void AddChildBoundsToBatcher(ref BoundingBoxBatcher batcher, in RigidPose pose, in BodyVelocity velocity, int bodyIndex) Parameters batcher BoundingBoxBatcher Batcher to accumulate children in. pose RigidPose Pose of the compound. velocity BodyVelocity Velocity of the compound used to expand child bounds. bodyIndex int Index of the body in the active body set; used to accumulate child bounds results. Remarks This is used internally for bounding box calculation, but it is unlikely to be useful externally. AddChildBoundsToBatcher(ref Buffer<CompoundChild>, ref BoundingBoxBatcher, in RigidPose, in BodyVelocity, int) public static void AddChildBoundsToBatcher(ref Buffer<CompoundChild> children, ref BoundingBoxBatcher batcher, in RigidPose pose, in BodyVelocity velocity, int bodyIndex) Parameters children Buffer<CompoundChild> batcher BoundingBoxBatcher pose RigidPose velocity BodyVelocity bodyIndex int ComputeBounds(Quaternion, Shapes, out Vector3, out Vector3) Computes the bounding box of a compound shape. public void ComputeBounds(Quaternion orientation, Shapes shapeBatches, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the compound. shapeBatches Shapes Shape batches to look up child shape information in. min Vector3 Minimum of the compound's bounding box. max Vector3 Maximum of the compound's bounding box. ComputeChildBounds(in CompoundChild, Quaternion, Shapes, out Vector3, out Vector3) public static void ComputeChildBounds(in CompoundChild child, Quaternion orientation, Shapes shapeBatches, out Vector3 childMin, out Vector3 childMax) Parameters child CompoundChild orientation Quaternion shapeBatches Shapes childMin Vector3 childMax Vector3 ComputeInertia(Span<float>, Shapes) Computes the inertia of a compound. Does not recenter the child poses. public BodyInertia ComputeInertia(Span<float> childMasses, Shapes shapes) Parameters childMasses Span<float> Masses of the children. shapes Shapes Shapes collection containing the data for the compound child shapes. Returns BodyInertia Inertia of the compound. ComputeInertia(Span<float>, Shapes, out Vector3) Computes the inertia of a compound. Recenters the child poses around the calculated center of mass. public BodyInertia ComputeInertia(Span<float> childMasses, Shapes shapes, out Vector3 centerOfMass) Parameters childMasses Span<float> Masses of the children. shapes Shapes Shapes collection containing the data for the compound child shapes. centerOfMass Vector3 Calculated center of mass of the compound. Subtracted from all the compound child poses. Returns BodyInertia Inertia of the compound. CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapes) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapes Shapes Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine. Dispose(BufferPool) Returns all resources used by the shape instance to the given pool. public void Dispose(BufferPool bufferPool) Parameters bufferPool BufferPool FindLocalOverlaps<TOverlaps>(Vector3, Vector3, Vector3, float, BufferPool, Shapes, void*) public void FindLocalOverlaps<TOverlaps>(Vector3 min, Vector3 max, Vector3 sweep, float maximumT, BufferPool pool, Shapes shapes, void* overlapsPointer) where TOverlaps : ICollisionTaskSubpairOverlaps Parameters min Vector3 max Vector3 sweep Vector3 maximumT float pool BufferPool shapes Shapes overlapsPointer void* Type Parameters TOverlaps FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair>, BufferPool, Shapes, ref TOverlaps) public void FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair> pairs, BufferPool pool, Shapes shapes, ref TOverlaps overlaps) where TOverlaps : struct, ICollisionTaskOverlaps<TSubpairOverlaps> where TSubpairOverlaps : struct, ICollisionTaskSubpairOverlaps Parameters pairs Buffer<OverlapQueryForPair> pool BufferPool shapes Shapes overlaps TOverlaps Type Parameters TOverlaps TSubpairOverlaps GetChild(int) Gets a child from the compound by index. public ref CompoundChild GetChild(int compoundChildIndex) Parameters compoundChildIndex int Index of the child to look up. Returns CompoundChild Reference to the requested compound child. GetRotatedChildPose(in RigidPose, Quaternion, out RigidPose) public static void GetRotatedChildPose(in RigidPose localPose, Quaternion orientation, out RigidPose rotatedChildPose) Parameters localPose RigidPose orientation Quaternion rotatedChildPose RigidPose GetRotatedChildPose(in RigidPoseWide, in QuaternionWide, out RigidPoseWide) public static void GetRotatedChildPose(in RigidPoseWide localPose, in QuaternionWide orientation, out RigidPoseWide rotatedChildPose) Parameters localPose RigidPoseWide orientation QuaternionWide rotatedChildPose RigidPoseWide GetRotatedChildPose(in RigidPoseWide, in QuaternionWide, out Vector3Wide, out QuaternionWide) public static void GetRotatedChildPose(in RigidPoseWide localPose, in QuaternionWide orientation, out Vector3Wide childPosition, out QuaternionWide childOrientation) Parameters localPose RigidPoseWide orientation QuaternionWide childPosition Vector3Wide childOrientation QuaternionWide GetRotatedChildPose(Vector3, Quaternion, Quaternion, out RigidPose) public static void GetRotatedChildPose(Vector3 localPosition, Quaternion localOrientation, Quaternion orientation, out RigidPose rotatedChildPose) Parameters localPosition Vector3 localOrientation Quaternion orientation Quaternion rotatedChildPose RigidPose GetRotatedChildPose(Vector3, Quaternion, Quaternion, out Vector3, out Quaternion) public static void GetRotatedChildPose(Vector3 localPosition, Quaternion localOrientation, Quaternion parentOrientation, out Vector3 rotatedPosition, out Quaternion rotatedOrientation) Parameters localPosition Vector3 localOrientation Quaternion parentOrientation Quaternion rotatedPosition Vector3 rotatedOrientation Quaternion GetWorldPose(in RigidPose, in RigidPose, out RigidPose) public static void GetWorldPose(in RigidPose localPose, in RigidPose transform, out RigidPose worldPose) Parameters localPose RigidPose transform RigidPose worldPose RigidPose RayTest<TRayHitHandler>(in RigidPose, in RayData, ref float, Shapes, ref TRayHitHandler) Tests a ray against the shape. public void RayTest<TRayHitHandler>(in RigidPose pose, in RayData ray, ref float maximumT, Shapes shapeBatches, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the shape during the ray test. ray RayData Ray to test against the shape. maximumT float Maximum distance along the ray, in units of the ray direction's length, that the ray will test. shapeBatches Shapes Shape batches to look up child shapes in if necessary. hitHandler TRayHitHandler Callbacks called when the ray interacts with a test candidate. Type Parameters TRayHitHandler RayTest<TRayHitHandler>(in RigidPose, ref RaySource, Shapes, ref TRayHitHandler) Tests multiple rays against the shape. public void RayTest<TRayHitHandler>(in RigidPose pose, ref RaySource rays, Shapes shapeBatches, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the shape during the ray test. rays RaySource Rays to test against the shape. shapeBatches Shapes Shape batches to look up child shapes in if necessary. hitHandler TRayHitHandler Callbacks called when the ray interacts with a test candidate. Type Parameters TRayHitHandler RemoveAt(int, BufferPool) Removes a child from the compound by index. The last child is pulled to fill the gap left by the removed child. public void RemoveAt(int childIndex, BufferPool pool) Parameters childIndex int Index of the child to remove from the compound. pool BufferPool Pool to use to resize the compound's children buffer if necessary. ValidateChildIndex(TypedIndex, Shapes) Checks if a shape index. public static bool ValidateChildIndex(TypedIndex shapeIndex, Shapes shapeBatches) Parameters shapeIndex TypedIndex Shape index to analyze. shapeBatches Shapes Shape collection into which the index indexes. Returns bool True if the index is valid, false otherwise. ValidateChildIndices(Span<CompoundChild>, Shapes) Checks if a set of children shape indices are all valid. public static bool ValidateChildIndices(Span<CompoundChild> children, Shapes shapeBatches) Parameters children Span<CompoundChild> Children to examine. shapeBatches Shapes Shape collection into which the children index. Returns bool True if all child indices are valid, false otherwise."
  },
  "api/BepuPhysics.Collidables.CompoundBuilder.Child.html": {
    "href": "api/BepuPhysics.Collidables.CompoundBuilder.Child.html",
    "title": "Struct CompoundBuilder.Child | Bepu API",
    "keywords": "Struct CompoundBuilder.Child Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct CompoundBuilder.Child Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalInverseInertia Inverse inertia tensor of the child in its local space. public Symmetric3x3 LocalInverseInertia Field Value Symmetric3x3 LocalPose public RigidPose LocalPose Field Value RigidPose ShapeIndex public TypedIndex ShapeIndex Field Value TypedIndex Weight Weight associated with this child. Acts as the child's mass when interpreted as a dynamic compound. When interpreted as kinematic with recentering, it is used as a local pose weight to compute the center of rotation. public float Weight Field Value float"
  },
  "api/BepuPhysics.Collidables.CompoundBuilder.html": {
    "href": "api/BepuPhysics.Collidables.CompoundBuilder.html",
    "title": "Struct CompoundBuilder | Bepu API",
    "keywords": "Struct CompoundBuilder Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Reusable convenience type for incrementally building compound shapes. public struct CompoundBuilder : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CompoundBuilder(BufferPool, Shapes, int) Creates a compound builder. public CompoundBuilder(BufferPool pool, Shapes shapes, int initialBuilderCapacity) Parameters pool BufferPool Buffer pool to allocate memory from when necessary. shapes Shapes Shapes collection to access when constructing the compound children. initialBuilderCapacity int Number of children the compound builder can hold without resizing. Fields Children public QuickList<CompoundBuilder.Child> Children Field Value QuickList<CompoundBuilder.Child> Pool public BufferPool Pool Field Value BufferPool Shapes public Shapes Shapes Field Value Shapes Methods Add(TypedIndex, in RigidPose, in BodyInertia) Adds a new shape to the accumulator. public void Add(TypedIndex shape, in RigidPose localPose, in BodyInertia childInertia) Parameters shape TypedIndex Index of the shape to add. localPose RigidPose Pose of the shape in the compound's local space. childInertia BodyInertia Inverse inertia tensor and inverse mass of the shape being added in the child's local space. The inverse mass is used as the inverse weight for building the compound. Add(TypedIndex, in RigidPose, in Symmetric3x3, float) Adds a new shape to the accumulator. public void Add(TypedIndex shape, in RigidPose localPose, in Symmetric3x3 localInverseInertia, float weight) Parameters shape TypedIndex Index of the shape to add. localPose RigidPose Pose of the shape in the compound's local space. localInverseInertia Symmetric3x3 Inverse inertia tensor of the shape being added in its local space. This is assumed to already be scaled as desired by the weight. weight float Weight of the shape. If the compound is interpreted as a dynamic, this will be used as the mass. Otherwise, it is used for recentering. AddForKinematic(TypedIndex, in RigidPose, float) Adds a new shape to the accumulator, assuming it has infinite inertia. public void AddForKinematic(TypedIndex shape, in RigidPose localPose, float weight) Parameters shape TypedIndex Index of the shape to add. localPose RigidPose Pose of the shape in the compound's local space. weight float Weight of the shape used for computing the center of rotation. AddForKinematic<TShape>(in TShape, in RigidPose, float) Adds a new shape to the accumulator, creating a new shape in the shapes set. Inertia is assumed to be infinite. public void AddForKinematic<TShape>(in TShape shape, in RigidPose localPose, float weight) where TShape : unmanaged, IConvexShape Parameters shape TShape Shape to add. localPose RigidPose Pose of the shape in the compound's local space. weight float Weight of the shape. If the compound is interpreted as a dynamic, this will be used as the mass. Otherwise, it is used for recentering. Type Parameters TShape Type of the shape to add to the accumulator and the shapes set. Add<TShape>(in TShape, in RigidPose, float) Adds a new shape to the accumulator, creating a new shape in the shapes set. The mass used to compute the inertia tensor will be based on the given weight. public void Add<TShape>(in TShape shape, in RigidPose localPose, float weight) where TShape : unmanaged, IConvexShape Parameters shape TShape Shape to add. localPose RigidPose Pose of the shape in the compound's local space. weight float Weight of the shape. If the compound is interpreted as a dynamic, this will be used as the mass and scales the inertia tensor. Otherwise, it is used for recentering. Type Parameters TShape Type of the shape to add to the accumulator and the shapes set. BuildDynamicCompound(out Buffer<CompoundChild>, out BodyInertia) Builds a buffer of compound children from the accumulated set for a dynamic compound. Does not recenter the children. Does not reset the accumulator. public void BuildDynamicCompound(out Buffer<CompoundChild> children, out BodyInertia inertia) Parameters children Buffer<CompoundChild> List of children created from the accumulated set. inertia BodyInertia Combined inertia of the compound. BuildDynamicCompound(out Buffer<CompoundChild>, out BodyInertia, out Vector3) Builds a buffer of compound children from the accumulated set for a dynamic compound. Computes a center of mass and recenters child shapes relative to it. Does not reset the accumulator. public void BuildDynamicCompound(out Buffer<CompoundChild> children, out BodyInertia inertia, out Vector3 center) Parameters children Buffer<CompoundChild> List of children created from the accumulated set. inertia BodyInertia Combined inertia of the compound. center Vector3 Computed center of rotation based on the poses and weights of accumulated children. BuildKinematicCompound(out Buffer<CompoundChild>) Builds a buffer of compound children from the accumulated set for a kinematic compound. Does not recenter children. Does not reset the accumulator. public void BuildKinematicCompound(out Buffer<CompoundChild> children) Parameters children Buffer<CompoundChild> List of children created from the accumulated set. BuildKinematicCompound(out Buffer<CompoundChild>, out Vector3) Builds a buffer of compound children from the accumulated set for a kinematic compound. Computes a center of mass and recenters child shapes relative to it. Does not reset the accumulator. public void BuildKinematicCompound(out Buffer<CompoundChild> children, out Vector3 center) Parameters children Buffer<CompoundChild> List of children created from the accumulated set. center Vector3 Computed center of rotation based on the poses and weights of accumulated children. ComputeCenterOfMass(Span<CompoundChild>, Span<float>) Computes the center of mass of a compound. public static Vector3 ComputeCenterOfMass(Span<CompoundChild> children, Span<float> childMasses) Parameters children Span<CompoundChild> Children of the compound. childMasses Span<float> Masses of the children in the compound. Returns Vector3 The compound's center of mass. ComputeCenterOfMass(Span<CompoundChild>, Span<float>, out float) Computes the center of mass of a compound. public static Vector3 ComputeCenterOfMass(Span<CompoundChild> children, Span<float> childMasses, out float inverseMass) Parameters children Span<CompoundChild> Children of the compound. childMasses Span<float> Masses of the children in the compound. inverseMass float Inverse of the sum of all child masses. Returns Vector3 The compound's center of mass. ComputeCenterOfMass(Span<RigidPose>, Span<float>) Computes the center of mass of a compound. public static Vector3 ComputeCenterOfMass(Span<RigidPose> childPoses, Span<float> childMasses) Parameters childPoses Span<RigidPose> Poses of the children in the compound. childMasses Span<float> Masses of the children in the compound. Returns Vector3 The compound's center of mass. ComputeCenterOfMass(Span<RigidPose>, Span<float>, out float) Computes the center of mass of a compound. public static Vector3 ComputeCenterOfMass(Span<RigidPose> childPoses, Span<float> childMasses, out float inverseMass) Parameters childPoses Span<RigidPose> Poses of the children in the compound. childMasses Span<float> Masses of the children in the compound. inverseMass float Inverse of the sum of all child masses. Returns Vector3 The compound's center of mass. ComputeInertia(Span<CompoundChild>, Span<float>, Shapes) Computes the inertia of a compound. Does not recenter the child poses. public static BodyInertia ComputeInertia(Span<CompoundChild> children, Span<float> childMasses, Shapes shapes) Parameters children Span<CompoundChild> Children of the compound. childMasses Span<float> Masses of the children. shapes Shapes Shapes collection containing the data for the compound child shapes. Returns BodyInertia Inertia of the compound. ComputeInertia(Span<CompoundChild>, Span<float>, Shapes, out Vector3) Computes the inertia of a compound. Recenters the child poses around the calculated center of mass. public static BodyInertia ComputeInertia(Span<CompoundChild> children, Span<float> childMasses, Shapes shapes, out Vector3 centerOfMass) Parameters children Span<CompoundChild> Children of the compound. Child local positions will have the calculated center of mass subtracted from them. childMasses Span<float> Masses of the children. shapes Shapes Shapes collection containing the data for the compound child shapes. centerOfMass Vector3 Calculated center of mass of the compound. Subtracted from all the compound child poses. Returns BodyInertia Inertia of the compound. ComputeInertiaForChild(in RigidPose, Symmetric3x3, float) Computes the uninverted inertia contribution of a child. public static Symmetric3x3 ComputeInertiaForChild(in RigidPose pose, Symmetric3x3 inverseLocalInertia, float mass) Parameters pose RigidPose Pose of the child. inverseLocalInertia Symmetric3x3 Inverse inertia tensor of the child in its local space. mass float Mass of the child. Returns Symmetric3x3 Inertia contribution of the child to a compound given its relative pose. ComputeInertiaForChild(Vector3, Quaternion, Symmetric3x3, float) Computes the uninverted inertia contribution of a child. public static Symmetric3x3 ComputeInertiaForChild(Vector3 position, Quaternion orientation, Symmetric3x3 inverseLocalInertia, float mass) Parameters position Vector3 Position of the child. orientation Quaternion Orientation of the child. inverseLocalInertia Symmetric3x3 Inverse inertia tensor of the child in its local space. mass float Mass of the child. Returns Symmetric3x3 Inertia contribution of the child to a compound given its relative pose. ComputeInverseInertia(Span<CompoundChild>, Span<Symmetric3x3>, Span<float>) Computes the inertia for a set of compound children based on their poses and the provided inverse inertias. Does not recenter the children. public static BodyInertia ComputeInverseInertia(Span<CompoundChild> children, Span<Symmetric3x3> inverseLocalInertias, Span<float> childMasses) Parameters children Span<CompoundChild> Children and their associated poses. inverseLocalInertias Span<Symmetric3x3> Inverse inertias of the children, each in the child's local space. Assumed to have already been premultiplied by the mass of the child. childMasses Span<float> Masses of each child in the compound. Returns BodyInertia BodyInertia of the compound. ComputeInverseInertia(Span<CompoundChild>, Span<Symmetric3x3>, Span<float>, out Vector3) Computes the inertia for a set of compound children based on their poses and the provided inverse inertias. Recenters the children onto the computed center of mass. public static BodyInertia ComputeInverseInertia(Span<CompoundChild> children, Span<Symmetric3x3> inverseLocalInertias, Span<float> childMasses, out Vector3 centerOfMass) Parameters children Span<CompoundChild> Children and their associated poses. Center of mass will be subtracted from the child position. inverseLocalInertias Span<Symmetric3x3> Inverse inertias of the children, each in the child's local space. Assumed to have already been premultiplied by the mass of the child. childMasses Span<float> Masses of each child in the compound. centerOfMass Vector3 Computed center of mass that was subtracted from the child positions. Returns BodyInertia BodyInertia of the compound. ComputeInverseInertia(Span<RigidPose>, Span<Symmetric3x3>, Span<float>) Computes the inverse inertia for a set of compound children based on their poses and the provided inverse inertias. Does not recenter the children. public static BodyInertia ComputeInverseInertia(Span<RigidPose> childPoses, Span<Symmetric3x3> inverseLocalInertias, Span<float> childMasses) Parameters childPoses Span<RigidPose> Poses of the compound's children. inverseLocalInertias Span<Symmetric3x3> Inverse inertias of the children, each in the child's local space. Assumed to have already been premultiplied by the mass of the child. childMasses Span<float> Masses of each child in the compound. Returns BodyInertia BodyInertia of the compound. ComputeInverseInertia(Span<RigidPose>, Span<Symmetric3x3>, Span<float>, out Vector3) Computes the inertia for a set of compound children based on their poses and the provided inverse inertias. Recenters the children onto the computed center of mass. public static BodyInertia ComputeInverseInertia(Span<RigidPose> childPoses, Span<Symmetric3x3> inverseLocalInertias, Span<float> childMasses, out Vector3 centerOfMass) Parameters childPoses Span<RigidPose> Poses of the compound's children. Center of mass will be subtracted from the child position. inverseLocalInertias Span<Symmetric3x3> Inverse inertias of the children, each in the child's local space. Assumed to have already been premultiplied by the mass of the child. childMasses Span<float> Masses of each child in the compound. centerOfMass Vector3 Computed center of mass that was subtracted from the child positions. Returns BodyInertia BodyInertia of the compound. Dispose() Returns internal resources to the pool, rendering the builder unusable. public void Dispose() GetOffsetInertiaContribution(Vector3, float, out Symmetric3x3) Gets the contribution to an inertia tensor of a point mass at the given offset from the center of mass. public static void GetOffsetInertiaContribution(Vector3 offset, float mass, out Symmetric3x3 contribution) Parameters offset Vector3 Offset from the center of mass. mass float Mass of the point. contribution Symmetric3x3 Contribution to the inertia tensor. Reset() Empties out the accumulated children. public void Reset()"
  },
  "api/BepuPhysics.Collidables.CompoundChild.html": {
    "href": "api/BepuPhysics.Collidables.CompoundChild.html",
    "title": "Struct CompoundChild | Bepu API",
    "keywords": "Struct CompoundChild Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Shape and pose of a child within a compound shape. public struct CompoundChild Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CompoundChild(in RigidPose, TypedIndex) Creates a compound child. public CompoundChild(in RigidPose pose, TypedIndex shapeIndex) Parameters pose RigidPose Pose of the compound child in the local space of the parent shape. shapeIndex TypedIndex Index of the shape used by the child. Fields LocalOrientation Local orientation of the child in the compound. public Quaternion LocalOrientation Field Value Quaternion LocalPosition Local position of the child in the compound. public Vector3 LocalPosition Field Value Vector3 ShapeIndex Index of the shape within whatever shape collection holds the compound's child shape data. public TypedIndex ShapeIndex Field Value TypedIndex Methods AsPose() Returns a reference to the memory of the CompoundChild as a RigidPose. public ref RigidPose AsPose() Returns RigidPose Reference to this compound child as a pose."
  },
  "api/BepuPhysics.Collidables.CompoundShapeBatch-1.html": {
    "href": "api/BepuPhysics.Collidables.CompoundShapeBatch-1.html",
    "title": "Class CompoundShapeBatch<TShape> | Bepu API",
    "keywords": "Class CompoundShapeBatch<TShape> Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public class CompoundShapeBatch<TShape> : ShapeBatch<TShape> where TShape : unmanaged, ICompoundShape Type Parameters TShape Inheritance object ShapeBatch ShapeBatch<TShape> CompoundShapeBatch<TShape> Inherited Members ShapeBatch<TShape>.this[int] ShapeBatch<TShape>.Add(in TShape) ShapeBatch<TShape>.Clear() ShapeBatch<TShape>.EnsureCapacity(int) ShapeBatch<TShape>.Resize(int) ShapeBatch<TShape>.Dispose() ShapeBatch.shapesData ShapeBatch.shapeDataSize ShapeBatch.Capacity ShapeBatch.pool ShapeBatch.idPool ShapeBatch.TypeId ShapeBatch.Compound ShapeBatch.ShapeDataSize ShapeBatch.Remove(int) ShapeBatch.RemoveAndDispose(int, BufferPool) ShapeBatch.RecursivelyRemoveAndDispose(int, Shapes, BufferPool) ShapeBatch.ComputeBounds(int, Vector3, Quaternion, out Vector3, out Vector3) ShapeBatch.ComputeBounds(int, RigidPose, out Vector3, out Vector3) ShapeBatch.GetShapeData(int, out void*, out int) ShapeBatch.ResizeIdPool(int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CompoundShapeBatch(BufferPool, int, Shapes) public CompoundShapeBatch(BufferPool pool, int initialShapeCount, Shapes shapeBatches) Parameters pool BufferPool initialShapeCount int shapeBatches Shapes Methods ComputeBounds(ref BoundingBoxBatcher) public override void ComputeBounds(ref BoundingBoxBatcher batcher) Parameters batcher BoundingBoxBatcher ComputeBounds(int, Quaternion, out Vector3, out Vector3) public override void ComputeBounds(int shapeIndex, Quaternion orientation, out Vector3 min, out Vector3 max) Parameters shapeIndex int orientation Quaternion min Vector3 max Vector3 Dispose(int, BufferPool) protected override void Dispose(int index, BufferPool pool) Parameters index int pool BufferPool RayTest<TRayHitHandler>(int, in RigidPose, in RayData, ref float, ref TRayHitHandler) public override void RayTest<TRayHitHandler>(int shapeIndex, in RigidPose pose, in RayData ray, ref float maximumT, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters shapeIndex int pose RigidPose ray RayData maximumT float hitHandler TRayHitHandler Type Parameters TRayHitHandler RayTest<TRayHitHandler>(int, in RigidPose, ref RaySource, ref TRayHitHandler) public override void RayTest<TRayHitHandler>(int shapeIndex, in RigidPose pose, ref RaySource rays, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters shapeIndex int pose RigidPose rays RaySource hitHandler TRayHitHandler Type Parameters TRayHitHandler RemoveAndDisposeChildren(int, Shapes, BufferPool) protected override void RemoveAndDisposeChildren(int index, Shapes shapes, BufferPool pool) Parameters index int shapes Shapes pool BufferPool"
  },
  "api/BepuPhysics.Collidables.ContinuousDetection.html": {
    "href": "api/BepuPhysics.Collidables.ContinuousDetection.html",
    "title": "Struct ContinuousDetection | Bepu API",
    "keywords": "Struct ContinuousDetection Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Defines how a collidable handles collisions with significant velocity. public struct ContinuousDetection Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields MinimumSweepTimestep If using Continuous, this defines the minimum progress that the sweep test will make when searching for the first time of impact. Collisions lasting less than MinimumSweepTimestep may be missed by the sweep test. Using larger values can significantly increase the performance of sweep tests. public float MinimumSweepTimestep Field Value float Mode The continuous collision detection mode. public ContinuousDetectionMode Mode Field Value ContinuousDetectionMode SweepConvergenceThreshold If using Continuous, sweep tests will terminate if the time of impact region has been refined to be smaller than SweepConvergenceThreshold. Values closer to zero will converge more closely to the true time of impact, but for speculative contact generation larger values usually work fine. Larger values allow the sweep to terminate much earlier and can significantly improve sweep performance. public float SweepConvergenceThreshold Field Value float Properties AllowExpansionBeyondSpeculativeMargin Gets whether the continuous collision detection configuration will permit bounding box expansion beyond the calculated speculative margin. public bool AllowExpansionBeyondSpeculativeMargin { get; } Property Value bool Discrete No sweep tests are performed. Default speculative contact generation will occur within the speculative margin. The collidable's bounding box will not be expanded by velocity beyond the speculative margin. This can be marginally cheaper than Passive modes if using a limited maximum speculative margin. If a Discrete mode collidable is moving quickly and the maximum speculative margin is limited, the fact that its bounding box is not expanded may cause it to miss a collision even with a non-Discrete collidable. Note that Discrete and Passive only differ if maximum speculative margin is restricted. public static ContinuousDetection Discrete { get; } Property Value ContinuousDetection Detection settings for the given discrete configuration. Passive No sweep tests are performed. Default speculative contact generation will occur within the speculative margin. The collidable's bounding box and speculative margin will be expanded by velocity. This is useful when a collidable may move quickly and does not itself require continuous detection, but there exist other collidables with continuous modes that should avoid missing collisions. public static ContinuousDetection Passive { get; } Property Value ContinuousDetection Detection settings for the passive configuration. Methods Continuous(float, float) Collision detection will start with a sweep test to identify a likely time of impact. Speculative contacts will be generated for the predicted collision. This mode can capture angular motion with very few ghost collisions. It can, however, miss secondary collisions that would have occurred due to the primary impact's velocity change. public static ContinuousDetection Continuous(float minimumSweepTimestep = 0.001, float sweepConvergenceThreshold = 0.001) Parameters minimumSweepTimestep float Minimum progress that the sweep test will make when searching for the first time of impact. Collisions lasting less than MinimumProgress may be missed by the sweep test. Using larger values can significantly increase the performance of sweep tests. sweepConvergenceThreshold float Threshold against which the time of impact region is compared for sweep termination. If the region has been refined to be smaller than SweepConvergenceThreshold, the sweep will terminate. Values closer to zero will converge more closely to the true time of impact, but for speculative contact generation larger values usually work fine. Larger values allow the sweep to terminate much earlier and can significantly improve sweep performance. Returns ContinuousDetection Detection settings for the given continuous configuration."
  },
  "api/BepuPhysics.Collidables.ContinuousDetectionMode.html": {
    "href": "api/BepuPhysics.Collidables.ContinuousDetectionMode.html",
    "title": "Enum ContinuousDetectionMode | Bepu API",
    "keywords": "Enum ContinuousDetectionMode Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Defines how a collidable will handle collision detection in the presence of velocity. public enum ContinuousDetectionMode Fields Continuous = 2 Collision detection will start with a sweep test to identify a likely time of impact. Speculative contacts will be generated for the predicted collision. This mode can capture angular motion with very few ghost collisions. It can, however, miss secondary collisions that would have occurred due to the primary impact's velocity change. Discrete = 0 No sweep tests are performed. Default speculative contact generation will occur within the speculative margin. The collidable's bounding box will not be expanded by velocity beyond the speculative margin. This is the cheapest mode. If a Discrete mode collidable is moving quickly and the maximum speculative margin is limited, the fact that its bounding box is not expanded may cause it to miss a collision even with a non-Discrete collidable. Passive = 1 No sweep tests are performed. Default speculative contact generation will occur within the speculative margin. The collidable's bounding box will be expanded by velocity without being limited by the speculative margin. This is useful when a collidable may move quickly and does not itself require continuous detection, but there exist other collidables with continuous modes that should avoid missing collisions."
  },
  "api/BepuPhysics.Collidables.ConvexHull.ConvexHullTriangleSource.html": {
    "href": "api/BepuPhysics.Collidables.ConvexHull.ConvexHullTriangleSource.html",
    "title": "Struct ConvexHull.ConvexHullTriangleSource | Bepu API",
    "keywords": "Struct ConvexHull.ConvexHullTriangleSource Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct ConvexHull.ConvexHullTriangleSource : ITriangleSource Implements ITriangleSource Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ConvexHullTriangleSource(in ConvexHull) public ConvexHullTriangleSource(in ConvexHull hull) Parameters hull ConvexHull Methods GetNextTriangle(out Vector3, out Vector3, out Vector3) Gets the next triangle in the sequence, if any. public bool GetNextTriangle(out Vector3 a, out Vector3 b, out Vector3 c) Parameters a Vector3 First vertex in the triangle. b Vector3 Second vertex in the triangle. c Vector3 Third vertex in the triangle. Returns bool True if there was another triangle, false otherwise."
  },
  "api/BepuPhysics.Collidables.ConvexHull.html": {
    "href": "api/BepuPhysics.Collidables.ConvexHull.html",
    "title": "Struct ConvexHull | Bepu API",
    "keywords": "Struct ConvexHull Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct ConvexHull : IConvexShape, IDisposableShape, IShape Implements IConvexShape IDisposableShape IShape Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ConvexHull(Span<Vector3>, BufferPool, out Vector3) Creates a convex hull from a point set. public ConvexHull(Span<Vector3> points, BufferPool pool, out Vector3 center) Parameters points Span<Vector3> Points to compute the convex hull of. pool BufferPool Pool in which to allocate the convex hull and any temporary resources needed to compute the hull. center Vector3 Computed center of the convex hull before the hull was recentered. Fields BoundingPlanes Bundled bounding planes associated with the convex hull's faces. public Buffer<HullBoundingPlanes> BoundingPlanes Field Value Buffer<HullBoundingPlanes> FaceToVertexIndicesStart Start indices of faces in the FaceVertexIndices. public Buffer<int> FaceToVertexIndicesStart Field Value Buffer<int> FaceVertexIndices Combined set of vertices used by each face. Use FaceToVertexIndicesStart to index into this for a particular face. Indices stored in counterclockwise winding in right handed space, clockwise in left handed space. public Buffer<HullVertexIndex> FaceVertexIndices Field Value Buffer<HullVertexIndex> Id Type id of convex hull shapes. public const int Id = 5 Field Value int Points Bundled points of the convex hull. public Buffer<Vector3Wide> Points Field Value Buffer<Vector3Wide> Properties TypeId Unique type id for this shape type. public static int TypeId { get; } Property Value int Methods ComputeAngularExpansionData(out float, out float) Computes information about how the bounding box should be expanded in response to angular velocity. public readonly void ComputeAngularExpansionData(out float maximumRadius, out float maximumAngularExpansion) Parameters maximumRadius float maximumAngularExpansion float Remarks This is typically used in the engine for predicting bounding boxes at the beginning of the frame. Velocities are used to expand the bounding box so that likely future collisions will be detected. Linear velocity expands the bounding box in a direct and simple way, but angular expansion requires more information about the shape. Imagine a long and thin capsule versus a sphere: high angular velocity may require significant expansion on the capsule, but spheres are rotationally invariant. ComputeBounds(Quaternion, out Vector3, out Vector3) Computes the bounding box of a shape given an orientation. public readonly void ComputeBounds(Quaternion orientation, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the shape to use when computing the bounding box. min Vector3 Minimum corner of the bounding box. max Vector3 Maximum corner of the bounding box. ComputeInertia(float) Computes the inertia for a body given a mass. public readonly BodyInertia ComputeInertia(float mass) Parameters mass float Mass to use to compute the body's inertia. Returns BodyInertia Inertia for the body. Remarks Note that the BodyInertia returned by this stores the inverse mass and inverse inertia tensor. This is because the most high frequency use of body inertia most naturally uses the inverse. CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapeBatches) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapeBatches Shapes The set of shapes to contain this batch. Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine. Dispose(BufferPool) Returns all resources used by the shape instance to the given pool. public void Dispose(BufferPool bufferPool) Parameters bufferPool BufferPool GetPoint(HullVertexIndex, out Vector3) public readonly void GetPoint(HullVertexIndex pointIndex, out Vector3 point) Parameters pointIndex HullVertexIndex point Vector3 GetPoint(int, out Vector3) public readonly void GetPoint(int pointIndex, out Vector3 point) Parameters pointIndex int point Vector3 GetVertexIndicesForFace(int, out Buffer<HullVertexIndex>) public readonly void GetVertexIndicesForFace(int faceIndex, out Buffer<HullVertexIndex> faceVertexIndices) Parameters faceIndex int faceVertexIndices Buffer<HullVertexIndex> RayTest(in RigidPose, Vector3, Vector3, out float, out Vector3) Tests a ray against the shape. public readonly bool RayTest(in RigidPose pose, Vector3 origin, Vector3 direction, out float t, out Vector3 normal) Parameters pose RigidPose Pose of the shape during the ray test. origin Vector3 Origin of the ray to test against the shape relative to the shape. direction Vector3 Direction of the ray to test against the shape. t float Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3 Normal of the impact surface, if any. Returns bool True if the ray intersected the shape, false otherwise."
  },
  "api/BepuPhysics.Collidables.ConvexHullHelper.EdgeEndpoints.html": {
    "href": "api/BepuPhysics.Collidables.ConvexHullHelper.EdgeEndpoints.html",
    "title": "Struct ConvexHullHelper.EdgeEndpoints | Bepu API",
    "keywords": "Struct ConvexHullHelper.EdgeEndpoints Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct ConvexHullHelper.EdgeEndpoints : IEqualityComparerRef<ConvexHullHelper.EdgeEndpoints> Implements IEqualityComparerRef<ConvexHullHelper.EdgeEndpoints> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public int A Field Value int B public int B Field Value int Methods Equals(ref EdgeEndpoints, ref EdgeEndpoints) public bool Equals(ref ConvexHullHelper.EdgeEndpoints a, ref ConvexHullHelper.EdgeEndpoints b) Parameters a ConvexHullHelper.EdgeEndpoints b ConvexHullHelper.EdgeEndpoints Returns bool Hash(ref EdgeEndpoints) public int Hash(ref ConvexHullHelper.EdgeEndpoints item) Parameters item ConvexHullHelper.EdgeEndpoints Returns int ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/BepuPhysics.Collidables.ConvexHullHelper.html": {
    "href": "api/BepuPhysics.Collidables.ConvexHullHelper.html",
    "title": "Class ConvexHullHelper | Bepu API",
    "keywords": "Class ConvexHullHelper Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Helper methods to create and process convex hulls from point clouds. public static class ConvexHullHelper Inheritance object ConvexHullHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ComputeHull(Span<Vector3>, BufferPool, out HullData) Computes the convex hull of a set of points. public static void ComputeHull(Span<Vector3> points, BufferPool pool, out HullData hullData) Parameters points Span<Vector3> Point set to compute the convex hull of. pool BufferPool Buffer pool to pull memory from when creating the hull. hullData HullData Convex hull of the input point set. CreateShape(Span<Vector3>, HullData, BufferPool, out Vector3, out ConvexHull) Processes hull data into a runtime usable convex hull shape. Recenters the convex hull's points around its center of mass. public static bool CreateShape(Span<Vector3> points, HullData hullData, BufferPool pool, out Vector3 center, out ConvexHull hullShape) Parameters points Span<Vector3> Point array into which the hull data indexes. hullData HullData Raw input data to process. pool BufferPool Pool used to allocate resources for the hullShape. center Vector3 Computed center of mass of the convex hull before its points were recentered onto the origin. hullShape ConvexHull Convex hull shape created from the input data. Returns bool True if the shape was created successfully, false otherwise. If false, the hull probably had no volume and would not have worked properly as a shape. CreateShape(Span<Vector3>, BufferPool, out HullData, out Vector3, out ConvexHull) Creates a convex hull shape out of an input point set. Recenters the convex hull's points around its center of mass. public static bool CreateShape(Span<Vector3> points, BufferPool pool, out HullData hullData, out Vector3 center, out ConvexHull convexHull) Parameters points Span<Vector3> Points to use to create the hull. pool BufferPool Buffer pool used for temporary allocations and the output data structures. hullData HullData Intermediate hull data that got processed into the convex hull. center Vector3 Computed center of mass of the convex hull before its points were recentered onto the origin. convexHull ConvexHull Convex hull shape of the input point set. Returns bool True if the shape was created successfully, false otherwise. If false, the hull probably had no volume and would not have worked properly as a shape. CreateShape(Span<Vector3>, BufferPool, out Vector3, out ConvexHull) Creates a convex hull shape out of an input point set. Recenters the convex hull's points around its center of mass. public static bool CreateShape(Span<Vector3> points, BufferPool pool, out Vector3 center, out ConvexHull convexHull) Parameters points Span<Vector3> Points to use to create the hull. pool BufferPool Buffer pool used for temporary allocations and the output data structures. center Vector3 Computed center of mass of the convex hull before its points were recentered onto the origin. convexHull ConvexHull Convex hull shape of the input point set. Returns bool True if the shape was created successfully, false otherwise. If false, the hull probably had no volume and would not have worked properly as a shape. CreateTransformedCopy(in ConvexHull, in Matrix3x3, BufferPool, out ConvexHull) Creates a transformed copy of a convex hull. Unique FaceVertexIndices and FaceToVertexIndicesStart buffers are allocated for the copy target. public static void CreateTransformedCopy(in ConvexHull source, in Matrix3x3 transform, BufferPool pool, out ConvexHull target) Parameters source ConvexHull Source convex hull to copy. transform Matrix3x3 Transform to apply to the hull points. pool BufferPool Pool from which to allocate the new hull's buffers. target ConvexHull Target convex hull to copy into. CreateTransformedCopy(in ConvexHull, in Matrix3x3, Buffer<Vector3Wide>, Buffer<HullBoundingPlanes>) Creates a transformed copy of a convex hull. public static void CreateTransformedCopy(in ConvexHull source, in Matrix3x3 transform, Buffer<Vector3Wide> targetPoints, Buffer<HullBoundingPlanes> targetBoundingPlanes) Parameters source ConvexHull Source convex hull to copy. transform Matrix3x3 Transform to apply to the hull points. targetPoints Buffer<Vector3Wide> Transformed points in the copy target hull. targetBoundingPlanes Buffer<HullBoundingPlanes> Transformed bounding planes in the copy target hull. CreateTransformedShallowCopy(in ConvexHull, in Matrix3x3, BufferPool, out ConvexHull) Creates a transformed copy of a convex hull. FaceVertexIndices and FaceToVertexIndicesStart buffers from the source are reused in the copy target. Note that disposing two convex hulls with the same buffers will cause errors; disposal must be handled carefully to avoid double freeing the shared buffers. public static void CreateTransformedShallowCopy(in ConvexHull source, in Matrix3x3 transform, BufferPool pool, out ConvexHull target) Parameters source ConvexHull Source convex hull to copy. transform Matrix3x3 Transform to apply to the hull points. pool BufferPool Pool from which to allocate the new hull's points and bounding planes buffers. target ConvexHull Target convex hull to copy into. FaceVertexIndices and FaceToVertexIndicesStart buffers are reused from the source."
  },
  "api/BepuPhysics.Collidables.ConvexHullShapeBatch.html": {
    "href": "api/BepuPhysics.Collidables.ConvexHullShapeBatch.html",
    "title": "Class ConvexHullShapeBatch | Bepu API",
    "keywords": "Class ConvexHullShapeBatch Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public class ConvexHullShapeBatch : ConvexShapeBatch<ConvexHull, ConvexHullWide>, IConvexShapeBatch Inheritance object ShapeBatch ShapeBatch<ConvexHull> ConvexShapeBatch<ConvexHull, ConvexHullWide> ConvexHullShapeBatch Implements IConvexShapeBatch Inherited Members ConvexShapeBatch<ConvexHull, ConvexHullWide>.Dispose(int, BufferPool) ConvexShapeBatch<ConvexHull, ConvexHullWide>.RemoveAndDisposeChildren(int, Shapes, BufferPool) ConvexShapeBatch<ConvexHull, ConvexHullWide>.ComputeInertia(int, float) ConvexShapeBatch<ConvexHull, ConvexHullWide>.ComputeBounds(ref BoundingBoxBatcher) ConvexShapeBatch<ConvexHull, ConvexHullWide>.ComputeBounds(int, Quaternion, out Vector3, out Vector3) ConvexShapeBatch<ConvexHull, ConvexHullWide>.RayTest<TRayHitHandler>(int, in RigidPose, in RayData, ref float, ref TRayHitHandler) ConvexShapeBatch<ConvexHull, ConvexHullWide>.RayTest<TRayHitHandler>(int, in RigidPose, ref RaySource, ref TRayHitHandler) ShapeBatch<ConvexHull>.this[int] ShapeBatch<ConvexHull>.Add(in ConvexHull) ShapeBatch<ConvexHull>.Clear() ShapeBatch<ConvexHull>.EnsureCapacity(int) ShapeBatch<ConvexHull>.Resize(int) ShapeBatch<ConvexHull>.Dispose() ShapeBatch.shapesData ShapeBatch.shapeDataSize ShapeBatch.Capacity ShapeBatch.pool ShapeBatch.idPool ShapeBatch.TypeId ShapeBatch.Compound ShapeBatch.ShapeDataSize ShapeBatch.RemoveAndDisposeChildren(int, Shapes, BufferPool) ShapeBatch.Remove(int) ShapeBatch.RemoveAndDispose(int, BufferPool) ShapeBatch.RecursivelyRemoveAndDispose(int, Shapes, BufferPool) ShapeBatch.ComputeBounds(ref BoundingBoxBatcher) ShapeBatch.ComputeBounds(int, Quaternion, out Vector3, out Vector3) ShapeBatch.ComputeBounds(int, Vector3, Quaternion, out Vector3, out Vector3) ShapeBatch.ComputeBounds(int, RigidPose, out Vector3, out Vector3) ShapeBatch.RayTest<TRayHitHandler>(int, in RigidPose, in RayData, ref float, ref TRayHitHandler) ShapeBatch.RayTest<TRayHitHandler>(int, in RigidPose, ref RaySource, ref TRayHitHandler) ShapeBatch.GetShapeData(int, out void*, out int) ShapeBatch.ResizeIdPool(int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConvexHullShapeBatch(BufferPool, int) public ConvexHullShapeBatch(BufferPool pool, int initialShapeCount) Parameters pool BufferPool initialShapeCount int Methods Dispose(int, BufferPool) protected override void Dispose(int index, BufferPool pool) Parameters index int pool BufferPool"
  },
  "api/BepuPhysics.Collidables.ConvexHullSupportFinder.html": {
    "href": "api/BepuPhysics.Collidables.ConvexHullSupportFinder.html",
    "title": "Struct ConvexHullSupportFinder | Bepu API",
    "keywords": "Struct ConvexHullSupportFinder Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct ConvexHullSupportFinder : ISupportFinder<ConvexHull, ConvexHullWide> Implements ISupportFinder<ConvexHull, ConvexHullWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties HasMargin Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape. public bool HasMargin { get; } Property Value bool Methods ComputeLocalSupport(in ConvexHullWide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeLocalSupport(in ConvexHullWide shape, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape ConvexHullWide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide ComputeSupport(in ConvexHullWide, in Matrix3x3Wide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeSupport(in ConvexHullWide shape, in Matrix3x3Wide orientation, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape ConvexHullWide orientation Matrix3x3Wide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide GetMargin(in ConvexHullWide, out Vector<float>) Margin associated with the shape according to this support finder. public void GetMargin(in ConvexHullWide shape, out Vector<float> margin) Parameters shape ConvexHullWide Shape to find the margin of. margin Vector<float> Margin of the shape."
  },
  "api/BepuPhysics.Collidables.ConvexHullWide.html": {
    "href": "api/BepuPhysics.Collidables.ConvexHullWide.html",
    "title": "Struct ConvexHullWide | Bepu API",
    "keywords": "Struct ConvexHullWide Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct ConvexHullWide : IShapeWide<ConvexHull> Implements IShapeWide<ConvexHull> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Hulls public Buffer<ConvexHull> Hulls Field Value Buffer<ConvexHull> Properties AllowOffsetMemoryAccess Gets whether this type supports accessing its memory by lane offsets. If false, WriteSlot must be used instead of WriteFirst. public bool AllowOffsetMemoryAccess { get; } Property Value bool InternalAllocationSize Gets the number of bytes required for allocations within the wide shape. public int InternalAllocationSize { get; } Property Value int MinimumWideRayCount Gets the lower bound on the number of rays to execute in a wide fashion. Ray bundles with fewer rays will fall back to the single ray code path. public static int MinimumWideRayCount { get; } Property Value int Methods Broadcast(in ConvexHull) Broadcasts a scalar shape into a bundle containing the same shape in every lane. public void Broadcast(in ConvexHull shape) Parameters shape ConvexHull Scalar shape to broadcast. EstimateEpsilonScale(in Vector<int>, out Vector<float>) Provides an estimate of the scale of a shape. public void EstimateEpsilonScale(in Vector<int> terminatedLanes, out Vector<float> epsilonScale) Parameters terminatedLanes Vector<int> Mask of lanes which are inactive. epsilonScale Vector<float> Approximate scale of the shape for use in epsilons. GetBounds(ref QuaternionWide, int, out Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide) Computes the bounds of all shapes in the bundle. public void GetBounds(ref QuaternionWide orientations, int countInBundle, out Vector<float> maximumRadius, out Vector<float> maximumAngularExpansion, out Vector3Wide min, out Vector3Wide max) Parameters orientations QuaternionWide Orientations of the shapes in the bundle. countInBundle int Number of lanes filled in the bundle. maximumRadius Vector<float> Computed maximum radius of the shapes in the bundle. maximumAngularExpansion Vector<float> Computed maximum bounds expansion that can be caused by angular motion. min Vector3Wide Minimum bounds of the shapes. max Vector3Wide Maximum bounds of the shapes. Initialize(in Buffer<byte>) For types with a nonzero internal allocation size, provides memory to the shape for internal allocations. Memory should be assumed to be stack allocated. public void Initialize(in Buffer<byte> memory) Parameters memory Buffer<byte> Memory to use for internal allocations in the wide shape. RayTest(ref RigidPoseWide, ref RayWide, out Vector<int>, out Vector<float>, out Vector3Wide) Tests a ray against the shape. public void RayTest(ref RigidPoseWide poses, ref RayWide rayWide, out Vector<int> intersected, out Vector<float> t, out Vector3Wide normal) Parameters poses RigidPoseWide Poses of the shape bundle during the ray test. rayWide RayWide Ray to test against the shape bundle. intersected Vector<int> Mask representing hit state in each lane. -1 means the ray in that lane hit, 0 means a miss. t Vector<float> Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3Wide Normal of the impact surface, if any. WriteFirst(in ConvexHull) Places the specified AOS-formatted shape into the first lane of the wide 'this' reference. public void WriteFirst(in ConvexHull source) Parameters source ConvexHull AOS-formatted shape to gather from. Remarks Note that we are effectively using the TShapeWide as a stride. The base address is offset by the user of this function, so the implementation only ever considers the first slot. WriteSlot(int, in ConvexHull) Places the specified AOS-formatted shape into the selected slot of the wide 'this' reference. public void WriteSlot(int index, in ConvexHull source) Parameters index int Index of the slot to put the data into. source ConvexHull Source of the data to insert."
  },
  "api/BepuPhysics.Collidables.ConvexShapeBatch-2.html": {
    "href": "api/BepuPhysics.Collidables.ConvexShapeBatch-2.html",
    "title": "Class ConvexShapeBatch<TShape, TShapeWide> | Bepu API",
    "keywords": "Class ConvexShapeBatch<TShape, TShapeWide> Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public class ConvexShapeBatch<TShape, TShapeWide> : ShapeBatch<TShape>, IConvexShapeBatch where TShape : unmanaged, IConvexShape where TShapeWide : unmanaged, IShapeWide<TShape> Type Parameters TShape TShapeWide Inheritance object ShapeBatch ShapeBatch<TShape> ConvexShapeBatch<TShape, TShapeWide> Implements IConvexShapeBatch Derived ConvexHullShapeBatch Inherited Members ShapeBatch<TShape>.this[int] ShapeBatch<TShape>.Add(in TShape) ShapeBatch<TShape>.Clear() ShapeBatch<TShape>.EnsureCapacity(int) ShapeBatch<TShape>.Resize(int) ShapeBatch<TShape>.Dispose() ShapeBatch.shapesData ShapeBatch.shapeDataSize ShapeBatch.Capacity ShapeBatch.pool ShapeBatch.idPool ShapeBatch.TypeId ShapeBatch.Compound ShapeBatch.ShapeDataSize ShapeBatch.Remove(int) ShapeBatch.RemoveAndDispose(int, BufferPool) ShapeBatch.RecursivelyRemoveAndDispose(int, Shapes, BufferPool) ShapeBatch.ComputeBounds(int, Vector3, Quaternion, out Vector3, out Vector3) ShapeBatch.ComputeBounds(int, RigidPose, out Vector3, out Vector3) ShapeBatch.GetShapeData(int, out void*, out int) ShapeBatch.ResizeIdPool(int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConvexShapeBatch(BufferPool, int) public ConvexShapeBatch(BufferPool pool, int initialShapeCount) Parameters pool BufferPool initialShapeCount int Methods ComputeBounds(ref BoundingBoxBatcher) public override void ComputeBounds(ref BoundingBoxBatcher batcher) Parameters batcher BoundingBoxBatcher ComputeBounds(int, Quaternion, out Vector3, out Vector3) public override void ComputeBounds(int shapeIndex, Quaternion orientation, out Vector3 min, out Vector3 max) Parameters shapeIndex int orientation Quaternion min Vector3 max Vector3 ComputeInertia(int, float) Computes the inertia of a shape. public BodyInertia ComputeInertia(int shapeIndex, float mass) Parameters shapeIndex int Index of the shape to compute the inertia of. mass float Mass to use to compute the inertia. Returns BodyInertia Inertia of the shape. Dispose(int, BufferPool) protected override void Dispose(int index, BufferPool pool) Parameters index int pool BufferPool RayTest<TRayHitHandler>(int, in RigidPose, in RayData, ref float, ref TRayHitHandler) public override void RayTest<TRayHitHandler>(int shapeIndex, in RigidPose pose, in RayData ray, ref float maximumT, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters shapeIndex int pose RigidPose ray RayData maximumT float hitHandler TRayHitHandler Type Parameters TRayHitHandler RayTest<TRayHitHandler>(int, in RigidPose, ref RaySource, ref TRayHitHandler) public override void RayTest<TRayHitHandler>(int index, in RigidPose pose, ref RaySource rays, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters index int pose RigidPose rays RaySource hitHandler TRayHitHandler Type Parameters TRayHitHandler RemoveAndDisposeChildren(int, Shapes, BufferPool) protected override void RemoveAndDisposeChildren(int index, Shapes shapes, BufferPool pool) Parameters index int shapes Shapes pool BufferPool"
  },
  "api/BepuPhysics.Collidables.Cylinder.html": {
    "href": "api/BepuPhysics.Collidables.Cylinder.html",
    "title": "Struct Cylinder | Bepu API",
    "keywords": "Struct Cylinder Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Collision shape representing a cylinder. public struct Cylinder : IConvexShape, IShape Implements IConvexShape IShape Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Cylinder(float, float) Creates a cylinder shape. public Cylinder(float radius, float length) Parameters radius float Radius of the cylinder. length float Length of the cylinder along its local Y axis. Fields HalfLength Half length of the cylinder along its local Y axis. public float HalfLength Field Value float Id Type id of cylinder shapes. public const int Id = 4 Field Value int Radius Radius of the cylinder. public float Radius Field Value float Properties Length Gets or sets the length of the cylinder along its local Y axis. public float Length { get; set; } Property Value float TypeId Unique type id for this shape type. public static int TypeId { get; } Property Value int Methods ComputeAngularExpansionData(out float, out float) Computes information about how the bounding box should be expanded in response to angular velocity. public readonly void ComputeAngularExpansionData(out float maximumRadius, out float maximumAngularExpansion) Parameters maximumRadius float maximumAngularExpansion float Remarks This is typically used in the engine for predicting bounding boxes at the beginning of the frame. Velocities are used to expand the bounding box so that likely future collisions will be detected. Linear velocity expands the bounding box in a direct and simple way, but angular expansion requires more information about the shape. Imagine a long and thin capsule versus a sphere: high angular velocity may require significant expansion on the capsule, but spheres are rotationally invariant. ComputeBounds(Quaternion, out Vector3, out Vector3) Computes the bounding box of a shape given an orientation. public readonly void ComputeBounds(Quaternion orientation, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the shape to use when computing the bounding box. min Vector3 Minimum corner of the bounding box. max Vector3 Maximum corner of the bounding box. ComputeInertia(float) Computes the inertia for a body given a mass. public readonly BodyInertia ComputeInertia(float mass) Parameters mass float Mass to use to compute the body's inertia. Returns BodyInertia Inertia for the body. Remarks Note that the BodyInertia returned by this stores the inverse mass and inverse inertia tensor. This is because the most high frequency use of body inertia most naturally uses the inverse. CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapeBatches) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapeBatches Shapes The set of shapes to contain this batch. Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine. RayTest(in RigidPose, Vector3, Vector3, out float, out Vector3) Tests a ray against the shape. public readonly bool RayTest(in RigidPose pose, Vector3 origin, Vector3 direction, out float t, out Vector3 normal) Parameters pose RigidPose Pose of the shape during the ray test. origin Vector3 Origin of the ray to test against the shape relative to the shape. direction Vector3 Direction of the ray to test against the shape. t float Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3 Normal of the impact surface, if any. Returns bool True if the ray intersected the shape, false otherwise."
  },
  "api/BepuPhysics.Collidables.CylinderSupportFinder.html": {
    "href": "api/BepuPhysics.Collidables.CylinderSupportFinder.html",
    "title": "Struct CylinderSupportFinder | Bepu API",
    "keywords": "Struct CylinderSupportFinder Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct CylinderSupportFinder : ISupportFinder<Cylinder, CylinderWide> Implements ISupportFinder<Cylinder, CylinderWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties HasMargin Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape. public bool HasMargin { get; } Property Value bool Methods ComputeLocalSupport(in CylinderWide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeLocalSupport(in CylinderWide shape, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape CylinderWide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide ComputeSupport(in CylinderWide, in Matrix3x3Wide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeSupport(in CylinderWide shape, in Matrix3x3Wide orientation, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape CylinderWide orientation Matrix3x3Wide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide GetMargin(in CylinderWide, out Vector<float>) Margin associated with the shape according to this support finder. public void GetMargin(in CylinderWide shape, out Vector<float> margin) Parameters shape CylinderWide Shape to find the margin of. margin Vector<float> Margin of the shape."
  },
  "api/BepuPhysics.Collidables.CylinderWide.html": {
    "href": "api/BepuPhysics.Collidables.CylinderWide.html",
    "title": "Struct CylinderWide | Bepu API",
    "keywords": "Struct CylinderWide Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct CylinderWide : IShapeWide<Cylinder> Implements IShapeWide<Cylinder> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields HalfLength public Vector<float> HalfLength Field Value Vector<float> Radius public Vector<float> Radius Field Value Vector<float> Properties AllowOffsetMemoryAccess Gets whether this type supports accessing its memory by lane offsets. If false, WriteSlot must be used instead of WriteFirst. public bool AllowOffsetMemoryAccess { get; } Property Value bool InternalAllocationSize Gets the number of bytes required for allocations within the wide shape. public int InternalAllocationSize { get; } Property Value int MinimumWideRayCount Gets the lower bound on the number of rays to execute in a wide fashion. Ray bundles with fewer rays will fall back to the single ray code path. public static int MinimumWideRayCount { get; } Property Value int Methods Broadcast(in Cylinder) Broadcasts a scalar shape into a bundle containing the same shape in every lane. public void Broadcast(in Cylinder shape) Parameters shape Cylinder Scalar shape to broadcast. GetBounds(ref QuaternionWide, int, out Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide) Computes the bounds of all shapes in the bundle. public void GetBounds(ref QuaternionWide orientations, int countInBundle, out Vector<float> maximumRadius, out Vector<float> maximumAngularExpansion, out Vector3Wide min, out Vector3Wide max) Parameters orientations QuaternionWide Orientations of the shapes in the bundle. countInBundle int Number of lanes filled in the bundle. maximumRadius Vector<float> Computed maximum radius of the shapes in the bundle. maximumAngularExpansion Vector<float> Computed maximum bounds expansion that can be caused by angular motion. min Vector3Wide Minimum bounds of the shapes. max Vector3Wide Maximum bounds of the shapes. Initialize(in Buffer<byte>) For types with a nonzero internal allocation size, provides memory to the shape for internal allocations. Memory should be assumed to be stack allocated. public void Initialize(in Buffer<byte> memory) Parameters memory Buffer<byte> Memory to use for internal allocations in the wide shape. RayTest(ref RigidPoseWide, ref RayWide, out Vector<int>, out Vector<float>, out Vector3Wide) Tests a ray against the shape. public void RayTest(ref RigidPoseWide pose, ref RayWide ray, out Vector<int> intersected, out Vector<float> t, out Vector3Wide normal) Parameters pose RigidPoseWide ray RayWide intersected Vector<int> Mask representing hit state in each lane. -1 means the ray in that lane hit, 0 means a miss. t Vector<float> Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3Wide Normal of the impact surface, if any. WriteFirst(in Cylinder) Places the specified AOS-formatted shape into the first lane of the wide 'this' reference. public void WriteFirst(in Cylinder source) Parameters source Cylinder AOS-formatted shape to gather from. Remarks Note that we are effectively using the TShapeWide as a stride. The base address is offset by the user of this function, so the implementation only ever considers the first slot. WriteSlot(int, in Cylinder) Places the specified AOS-formatted shape into the selected slot of the wide 'this' reference. public void WriteSlot(int index, in Cylinder source) Parameters index int Index of the slot to put the data into. source Cylinder Source of the data to insert."
  },
  "api/BepuPhysics.Collidables.HomogeneousCompoundShapeBatch-3.html": {
    "href": "api/BepuPhysics.Collidables.HomogeneousCompoundShapeBatch-3.html",
    "title": "Class HomogeneousCompoundShapeBatch<TShape, TChildShape, TChildShapeWide> | Bepu API",
    "keywords": "Class HomogeneousCompoundShapeBatch<TShape, TChildShape, TChildShapeWide> Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public class HomogeneousCompoundShapeBatch<TShape, TChildShape, TChildShapeWide> : ShapeBatch<TShape> where TShape : unmanaged, IHomogeneousCompoundShape<TChildShape, TChildShapeWide> where TChildShape : unmanaged, IConvexShape where TChildShapeWide : unmanaged, IShapeWide<TChildShape> Type Parameters TShape TChildShape TChildShapeWide Inheritance object ShapeBatch ShapeBatch<TShape> HomogeneousCompoundShapeBatch<TShape, TChildShape, TChildShapeWide> Inherited Members ShapeBatch<TShape>.this[int] ShapeBatch<TShape>.Add(in TShape) ShapeBatch<TShape>.Clear() ShapeBatch<TShape>.EnsureCapacity(int) ShapeBatch<TShape>.Resize(int) ShapeBatch<TShape>.Dispose() ShapeBatch.shapesData ShapeBatch.shapeDataSize ShapeBatch.Capacity ShapeBatch.pool ShapeBatch.idPool ShapeBatch.TypeId ShapeBatch.Compound ShapeBatch.ShapeDataSize ShapeBatch.Remove(int) ShapeBatch.RemoveAndDispose(int, BufferPool) ShapeBatch.RecursivelyRemoveAndDispose(int, Shapes, BufferPool) ShapeBatch.ComputeBounds(int, Vector3, Quaternion, out Vector3, out Vector3) ShapeBatch.ComputeBounds(int, RigidPose, out Vector3, out Vector3) ShapeBatch.GetShapeData(int, out void*, out int) ShapeBatch.ResizeIdPool(int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HomogeneousCompoundShapeBatch(BufferPool, int) public HomogeneousCompoundShapeBatch(BufferPool pool, int initialShapeCount) Parameters pool BufferPool initialShapeCount int Methods ComputeBounds(ref BoundingBoxBatcher) public override void ComputeBounds(ref BoundingBoxBatcher batcher) Parameters batcher BoundingBoxBatcher ComputeBounds(int, Quaternion, out Vector3, out Vector3) public override void ComputeBounds(int shapeIndex, Quaternion orientation, out Vector3 min, out Vector3 max) Parameters shapeIndex int orientation Quaternion min Vector3 max Vector3 Dispose(int, BufferPool) protected override void Dispose(int index, BufferPool pool) Parameters index int pool BufferPool RayTest<TRayHitHandler>(int, in RigidPose, in RayData, ref float, ref TRayHitHandler) public override void RayTest<TRayHitHandler>(int shapeIndex, in RigidPose pose, in RayData ray, ref float maximumT, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters shapeIndex int pose RigidPose ray RayData maximumT float hitHandler TRayHitHandler Type Parameters TRayHitHandler RayTest<TRayHitHandler>(int, in RigidPose, ref RaySource, ref TRayHitHandler) public override void RayTest<TRayHitHandler>(int shapeIndex, in RigidPose pose, ref RaySource rays, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters shapeIndex int pose RigidPose rays RaySource hitHandler TRayHitHandler Type Parameters TRayHitHandler RemoveAndDisposeChildren(int, Shapes, BufferPool) protected override void RemoveAndDisposeChildren(int index, Shapes shapes, BufferPool pool) Parameters index int shapes Shapes pool BufferPool"
  },
  "api/BepuPhysics.Collidables.HullBoundingPlanes.html": {
    "href": "api/BepuPhysics.Collidables.HullBoundingPlanes.html",
    "title": "Struct HullBoundingPlanes | Bepu API",
    "keywords": "Struct HullBoundingPlanes Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct HullBoundingPlanes Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Normal Normal of the bounding plane. public Vector3Wide Normal Field Value Vector3Wide Offset Offset from the origin to a point on the plane along the normal. public Vector<float> Offset Field Value Vector<float>"
  },
  "api/BepuPhysics.Collidables.HullData.html": {
    "href": "api/BepuPhysics.Collidables.HullData.html",
    "title": "Struct HullData | Bepu API",
    "keywords": "Struct HullData Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Raw data representing a convex hull. public struct HullData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This is not yet transformed into a runtime format. It requires additional processing to be used in a ConvexHull shape; see ConvexHullHelper.ProcessHull. Fields FaceStartIndices Starting index in the FaceVertexIndices for each face. public Buffer<int> FaceStartIndices Field Value Buffer<int> FaceVertexIndices List of indices composing the faces of the hull. Individual faces indexed by the FaceIndices. public Buffer<int> FaceVertexIndices Field Value Buffer<int> OriginalVertexMapping Mapping of points on the convex hull back to the original point set. public Buffer<int> OriginalVertexMapping Field Value Buffer<int> Methods Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool GetFace(int, out HullFace) public void GetFace(int faceIndex, out HullFace face) Parameters faceIndex int face HullFace"
  },
  "api/BepuPhysics.Collidables.HullFace.html": {
    "href": "api/BepuPhysics.Collidables.HullFace.html",
    "title": "Struct HullFace | Bepu API",
    "keywords": "Struct HullFace Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Stores references to the points composing one of a convex hull's faces. public struct HullFace Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields OriginalVertexMapping public Buffer<int> OriginalVertexMapping Field Value Buffer<int> VertexIndices public Buffer<int> VertexIndices Field Value Buffer<int> Properties this[int] Gets the index of the vertex associated with the given face vertex index in the source point set. public int this[int index] { get; } Parameters index int Index into the face's vertex list. Property Value int Index of the vertex associated with the given face vertex index in the source point set. VertexCount Gets the number of vertices in the face. public int VertexCount { get; } Property Value int"
  },
  "api/BepuPhysics.Collidables.HullVertexIndex.html": {
    "href": "api/BepuPhysics.Collidables.HullVertexIndex.html",
    "title": "Struct HullVertexIndex | Bepu API",
    "keywords": "Struct HullVertexIndex Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct HullVertexIndex Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields BundleIndex public ushort BundleIndex Field Value ushort InnerIndex public ushort InnerIndex Field Value ushort Methods ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/BepuPhysics.Collidables.ICompoundShape.html": {
    "href": "api/BepuPhysics.Collidables.ICompoundShape.html",
    "title": "Interface ICompoundShape | Bepu API",
    "keywords": "Interface ICompoundShape Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Defines a compound shape type that has children of potentially different types. public interface ICompoundShape : IDisposableShape, IShape, IBoundsQueryableCompound Inherited Members IDisposableShape.Dispose(BufferPool) IShape.TypeId IShape.CreateShapeBatch(BufferPool, int, Shapes) IBoundsQueryableCompound.FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair>, BufferPool, Shapes, ref TOverlaps) IBoundsQueryableCompound.FindLocalOverlaps<TOverlaps>(Vector3, Vector3, Vector3, float, BufferPool, Shapes, void*) Properties ChildCount Gets the number of children in the compound shape. int ChildCount { get; } Property Value int Methods AddChildBoundsToBatcher(ref BoundingBoxBatcher, in RigidPose, in BodyVelocity, int) Submits child shapes to a bounding box batcher for vectorized bounds calculation. void AddChildBoundsToBatcher(ref BoundingBoxBatcher batcher, in RigidPose pose, in BodyVelocity velocity, int bodyIndex) Parameters batcher BoundingBoxBatcher Batcher to accumulate children in. pose RigidPose Pose of the compound. velocity BodyVelocity Velocity of the compound used to expand child bounds. bodyIndex int Index of the body in the active body set; used to accumulate child bounds results. Remarks This is used internally for bounding box calculation, but it is unlikely to be useful externally. ComputeBounds(Quaternion, Shapes, out Vector3, out Vector3) Computes the bounding box of a compound shape. void ComputeBounds(Quaternion orientation, Shapes shapeBatches, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the compound. shapeBatches Shapes Shape batches to look up child shape information in. min Vector3 Minimum of the compound's bounding box. max Vector3 Maximum of the compound's bounding box. GetChild(int) Gets a child from the compound by index. ref CompoundChild GetChild(int compoundChildIndex) Parameters compoundChildIndex int Index of the child to look up. Returns CompoundChild Reference to the requested compound child. RayTest<TRayHitHandler>(in RigidPose, in RayData, ref float, Shapes, ref TRayHitHandler) Tests a ray against the shape. void RayTest<TRayHitHandler>(in RigidPose pose, in RayData ray, ref float maximumT, Shapes shapeBatches, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the shape during the ray test. ray RayData Ray to test against the shape. maximumT float Maximum distance along the ray, in units of the ray direction's length, that the ray will test. shapeBatches Shapes Shape batches to look up child shapes in if necessary. hitHandler TRayHitHandler Callbacks called when the ray interacts with a test candidate. Type Parameters TRayHitHandler RayTest<TRayHitHandler>(in RigidPose, ref RaySource, Shapes, ref TRayHitHandler) Tests multiple rays against the shape. void RayTest<TRayHitHandler>(in RigidPose pose, ref RaySource rays, Shapes shapeBatches, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the shape during the ray test. rays RaySource Rays to test against the shape. shapeBatches Shapes Shape batches to look up child shapes in if necessary. hitHandler TRayHitHandler Callbacks called when the ray interacts with a test candidate. Type Parameters TRayHitHandler"
  },
  "api/BepuPhysics.Collidables.IConvexShape.html": {
    "href": "api/BepuPhysics.Collidables.IConvexShape.html",
    "title": "Interface IConvexShape | Bepu API",
    "keywords": "Interface IConvexShape Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Defines functions available on all convex shapes. Convex shapes have no hollowed out regions; any line passing through a convex shape will never enter and exit more than once. public interface IConvexShape : IShape Inherited Members IShape.TypeId IShape.CreateShapeBatch(BufferPool, int, Shapes) Methods ComputeAngularExpansionData(out float, out float) Computes information about how the bounding box should be expanded in response to angular velocity. void ComputeAngularExpansionData(out float maximumRadius, out float maximumAngularExpansion) Parameters maximumRadius float maximumAngularExpansion float Remarks This is typically used in the engine for predicting bounding boxes at the beginning of the frame. Velocities are used to expand the bounding box so that likely future collisions will be detected. Linear velocity expands the bounding box in a direct and simple way, but angular expansion requires more information about the shape. Imagine a long and thin capsule versus a sphere: high angular velocity may require significant expansion on the capsule, but spheres are rotationally invariant. ComputeBounds(Quaternion, out Vector3, out Vector3) Computes the bounding box of a shape given an orientation. void ComputeBounds(Quaternion orientation, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the shape to use when computing the bounding box. min Vector3 Minimum corner of the bounding box. max Vector3 Maximum corner of the bounding box. ComputeInertia(float) Computes the inertia for a body given a mass. BodyInertia ComputeInertia(float mass) Parameters mass float Mass to use to compute the body's inertia. Returns BodyInertia Inertia for the body. Remarks Note that the BodyInertia returned by this stores the inverse mass and inverse inertia tensor. This is because the most high frequency use of body inertia most naturally uses the inverse. RayTest(in RigidPose, Vector3, Vector3, out float, out Vector3) Tests a ray against the shape. bool RayTest(in RigidPose pose, Vector3 origin, Vector3 direction, out float t, out Vector3 normal) Parameters pose RigidPose Pose of the shape during the ray test. origin Vector3 Origin of the ray to test against the shape relative to the shape. direction Vector3 Direction of the ray to test against the shape. t float Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3 Normal of the impact surface, if any. Returns bool True if the ray intersected the shape, false otherwise."
  },
  "api/BepuPhysics.Collidables.IConvexShapeBatch.html": {
    "href": "api/BepuPhysics.Collidables.IConvexShapeBatch.html",
    "title": "Interface IConvexShapeBatch | Bepu API",
    "keywords": "Interface IConvexShapeBatch Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Defines a shape batch containing convex objects that support simple inertia calculations. public interface IConvexShapeBatch Remarks This interface gives compounds a way to compute inertia despite not having direct typed access to the child shapes. It's a layer of overhead that can usually be avoided, but it's sometimes convenient to be able to just enumerate child inertias. Methods ComputeInertia(int, float) Computes the inertia of a shape. BodyInertia ComputeInertia(int shapeIndex, float mass) Parameters shapeIndex int Index of the shape to compute the inertia of. mass float Mass to use to compute the inertia. Returns BodyInertia Inertia of the shape."
  },
  "api/BepuPhysics.Collidables.IDisposableShape.html": {
    "href": "api/BepuPhysics.Collidables.IDisposableShape.html",
    "title": "Interface IDisposableShape | Bepu API",
    "keywords": "Interface IDisposableShape Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public interface IDisposableShape : IShape Inherited Members IShape.TypeId IShape.CreateShapeBatch(BufferPool, int, Shapes) Methods Dispose(BufferPool) Returns all resources used by the shape instance to the given pool. void Dispose(BufferPool pool) Parameters pool BufferPool Pool to return shape resources to."
  },
  "api/BepuPhysics.Collidables.IHomogeneousCompoundShape-2.html": {
    "href": "api/BepuPhysics.Collidables.IHomogeneousCompoundShape-2.html",
    "title": "Interface IHomogeneousCompoundShape<TChildShape, TChildShapeWide> | Bepu API",
    "keywords": "Interface IHomogeneousCompoundShape<TChildShape, TChildShapeWide> Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Defines a compound shape type that has children of only one type. public interface IHomogeneousCompoundShape<TChildShape, TChildShapeWide> : IDisposableShape, IShape, IBoundsQueryableCompound where TChildShape : unmanaged, IConvexShape where TChildShapeWide : unmanaged, IShapeWide<TChildShape> Type Parameters TChildShape Type of the child shapes. TChildShapeWide Type of the child shapes, formatted in AOSOA layout. Inherited Members IDisposableShape.Dispose(BufferPool) IShape.TypeId IShape.CreateShapeBatch(BufferPool, int, Shapes) IBoundsQueryableCompound.FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair>, BufferPool, Shapes, ref TOverlaps) IBoundsQueryableCompound.FindLocalOverlaps<TOverlaps>(Vector3, Vector3, Vector3, float, BufferPool, Shapes, void*) Properties ChildCount Gets the number of children in the compound shape. int ChildCount { get; } Property Value int Methods ComputeBounds(Quaternion, out Vector3, out Vector3) Computes the bounding box of a compound shape. void ComputeBounds(Quaternion orientation, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the compound. min Vector3 Minimum of the compound's bounding box. max Vector3 Maximum of the compound's bounding box. GetLocalChild(int, out TChildShape) Gets a child shape as it appears in the compound's local space. void GetLocalChild(int childIndex, out TChildShape childData) Parameters childIndex int Index of the child in the compound parent. childData TChildShape Data representing the child. GetLocalChild(int, ref TChildShapeWide) Gets a child shape as it appears in the compound's local space. void GetLocalChild(int childIndex, ref TChildShapeWide childData) Parameters childIndex int Index of the child in the compound parent. childData TChildShapeWide Reference to an AOSOA slot. GetPosedLocalChild(int, out TChildShape, out RigidPose) Gets a child shape from the compound and compounds a pose for it in the local space of the compound parent. Useful for processes which require a child shape (like a triangle in a mesh) to have their center of mass at zero in the child's own local space. void GetPosedLocalChild(int childIndex, out TChildShape childData, out RigidPose childPose) Parameters childIndex int Index of the child. childData TChildShape Shape of the child. childPose RigidPose Pose in the compound's local space that brings the child shape as described to the proper location in the parent compound's local space. RayTest<TRayHitHandler>(in RigidPose, in RayData, ref float, ref TRayHitHandler) Tests a ray against the shape. void RayTest<TRayHitHandler>(in RigidPose pose, in RayData ray, ref float maximumT, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the shape during the ray test. ray RayData Ray to test against the shape. maximumT float Maximum distance along the ray, in units of the ray direction's length, that the ray will test. hitHandler TRayHitHandler Callbacks called when the ray interacts with a test candidate. Type Parameters TRayHitHandler RayTest<TRayHitHandler>(in RigidPose, ref RaySource, ref TRayHitHandler) Tests multiple rays against the shape. void RayTest<TRayHitHandler>(in RigidPose pose, ref RaySource rays, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the shape during the ray test. rays RaySource Rays to test against the shape. hitHandler TRayHitHandler Callbacks called when the ray interacts with a test candidate. Type Parameters TRayHitHandler"
  },
  "api/BepuPhysics.Collidables.IShape.html": {
    "href": "api/BepuPhysics.Collidables.IShape.html",
    "title": "Interface IShape | Bepu API",
    "keywords": "Interface IShape Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Defines a type usable as a shape by collidables. public interface IShape Properties TypeId Unique type id for this shape type. public static abstract int TypeId { get; } Property Value int Methods CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static abstract ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapeBatches) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapeBatches Shapes The set of shapes to contain this batch. Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine."
  },
  "api/BepuPhysics.Collidables.IShapeWide-1.html": {
    "href": "api/BepuPhysics.Collidables.IShapeWide-1.html",
    "title": "Interface IShapeWide<TShape> | Bepu API",
    "keywords": "Interface IShapeWide<TShape> Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Defines a widely vectorized bundle representation of a shape. public interface IShapeWide<TShape> where TShape : IShape Type Parameters TShape Scalar type of the shape. Properties AllowOffsetMemoryAccess Gets whether this type supports accessing its memory by lane offsets. If false, WriteSlot must be used instead of WriteFirst. bool AllowOffsetMemoryAccess { get; } Property Value bool InternalAllocationSize Gets the number of bytes required for allocations within the wide shape. int InternalAllocationSize { get; } Property Value int MinimumWideRayCount Gets the lower bound on the number of rays to execute in a wide fashion. Ray bundles with fewer rays will fall back to the single ray code path. public static abstract int MinimumWideRayCount { get; } Property Value int Methods Broadcast(in TShape) Broadcasts a scalar shape into a bundle containing the same shape in every lane. void Broadcast(in TShape shape) Parameters shape TShape Scalar shape to broadcast. GetBounds(ref QuaternionWide, int, out Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide) Computes the bounds of all shapes in the bundle. void GetBounds(ref QuaternionWide orientations, int countInBundle, out Vector<float> maximumRadius, out Vector<float> maximumAngularExpansion, out Vector3Wide min, out Vector3Wide max) Parameters orientations QuaternionWide Orientations of the shapes in the bundle. countInBundle int Number of lanes filled in the bundle. maximumRadius Vector<float> Computed maximum radius of the shapes in the bundle. maximumAngularExpansion Vector<float> Computed maximum bounds expansion that can be caused by angular motion. min Vector3Wide Minimum bounds of the shapes. max Vector3Wide Maximum bounds of the shapes. Initialize(in Buffer<byte>) For types with a nonzero internal allocation size, provides memory to the shape for internal allocations. Memory should be assumed to be stack allocated. void Initialize(in Buffer<byte> memory) Parameters memory Buffer<byte> Memory to use for internal allocations in the wide shape. RayTest(ref RigidPoseWide, ref RayWide, out Vector<int>, out Vector<float>, out Vector3Wide) Tests a ray against the shape. void RayTest(ref RigidPoseWide poses, ref RayWide rayWide, out Vector<int> intersected, out Vector<float> t, out Vector3Wide normal) Parameters poses RigidPoseWide Poses of the shape bundle during the ray test. rayWide RayWide Ray to test against the shape bundle. intersected Vector<int> Mask representing hit state in each lane. -1 means the ray in that lane hit, 0 means a miss. t Vector<float> Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3Wide Normal of the impact surface, if any. WriteFirst(in TShape) Places the specified AOS-formatted shape into the first lane of the wide 'this' reference. void WriteFirst(in TShape source) Parameters source TShape AOS-formatted shape to gather from. Remarks Note that we are effectively using the TShapeWide as a stride. The base address is offset by the user of this function, so the implementation only ever considers the first slot. WriteSlot(int, in TShape) Places the specified AOS-formatted shape into the selected slot of the wide 'this' reference. void WriteSlot(int index, in TShape source) Parameters index int Index of the slot to put the data into. source TShape Source of the data to insert."
  },
  "api/BepuPhysics.Collidables.ITriangleSource.html": {
    "href": "api/BepuPhysics.Collidables.ITriangleSource.html",
    "title": "Interface ITriangleSource | Bepu API",
    "keywords": "Interface ITriangleSource Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Defines a type capable of providing a sequence of triangles. public interface ITriangleSource Methods GetNextTriangle(out Vector3, out Vector3, out Vector3) Gets the next triangle in the sequence, if any. bool GetNextTriangle(out Vector3 a, out Vector3 b, out Vector3 c) Parameters a Vector3 First vertex in the triangle. b Vector3 Second vertex in the triangle. c Vector3 Third vertex in the triangle. Returns bool True if there was another triangle, false otherwise."
  },
  "api/BepuPhysics.Collidables.Mesh.MeshTriangleSource.html": {
    "href": "api/BepuPhysics.Collidables.Mesh.MeshTriangleSource.html",
    "title": "Struct Mesh.MeshTriangleSource | Bepu API",
    "keywords": "Struct Mesh.MeshTriangleSource Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct Mesh.MeshTriangleSource : ITriangleSource Implements ITriangleSource Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors MeshTriangleSource(in Mesh) public MeshTriangleSource(in Mesh mesh) Parameters mesh Mesh Methods GetNextTriangle(out Vector3, out Vector3, out Vector3) Gets the next triangle in the sequence, if any. public bool GetNextTriangle(out Vector3 a, out Vector3 b, out Vector3 c) Parameters a Vector3 First vertex in the triangle. b Vector3 Second vertex in the triangle. c Vector3 Third vertex in the triangle. Returns bool True if there was another triangle, false otherwise."
  },
  "api/BepuPhysics.Collidables.Mesh.html": {
    "href": "api/BepuPhysics.Collidables.Mesh.html",
    "title": "Struct Mesh | Bepu API",
    "keywords": "Struct Mesh Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Shape designed to contain a whole bunch of triangles. Triangle collisions and ray tests are one-sided; only tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates will generate contacts. public struct Mesh : IHomogeneousCompoundShape<Triangle, TriangleWide>, IDisposableShape, IShape, IBoundsQueryableCompound Implements IHomogeneousCompoundShape<Triangle, TriangleWide> IDisposableShape IShape IBoundsQueryableCompound Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Mesh(Buffer<Triangle>, Vector3, BufferPool, IThreadDispatcher) Creates a mesh shape. public Mesh(Buffer<Triangle> triangles, Vector3 scale, BufferPool pool, IThreadDispatcher dispatcher = null) Parameters triangles Buffer<Triangle> Triangles to use in the mesh. scale Vector3 Scale to apply to all vertices at runtime. Note that the scale is not baked into the triangles or acceleration structure; the same set of triangles and acceleration structure can be used across multiple Mesh instances with different scales. pool BufferPool Pool used to allocate acceleration structures. dispatcher IThreadDispatcher Dispatcher to use to multithread the execution of the mesh build process. If null, the build will be single threaded. Mesh(Span<byte>, BufferPool) Loads a mesh from data stored in a byte buffer previously stored by the Serialize function. public Mesh(Span<byte> data, BufferPool pool) Parameters data Span<byte> Data to load the mesh from. pool BufferPool Pool to create the mesh with. Fields Id Type id of mesh shapes. public const int Id = 8 Field Value int Tree Acceleration structure of the mesh. public Tree Tree Field Value Tree Triangles Buffer of triangles composing the mesh. Triangles will only collide with tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates. public Buffer<Triangle> Triangles Field Value Buffer<Triangle> Properties ChildCount Gets the number of children in the compound shape. public readonly int ChildCount { get; } Property Value int Scale Gets or sets the scale of the mesh. public Vector3 Scale { get; set; } Property Value Vector3 TypeId Unique type id for this shape type. public static int TypeId { get; } Property Value int Methods ComputeBounds(Quaternion, out Vector3, out Vector3) Computes the bounding box of a compound shape. public readonly void ComputeBounds(Quaternion orientation, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the compound. min Vector3 Minimum of the compound's bounding box. max Vector3 Maximum of the compound's bounding box. ComputeClosedCenterOfMass() Computes the center of mass of the mesh. Assumes the mesh is closed and should be treated as solid. public readonly Vector3 ComputeClosedCenterOfMass() Returns Vector3 Center of mass of the closed mesh. ComputeClosedCenterOfMass(out float, out Vector3) Computes the volume and center of mass of the mesh. Assumes the mesh is closed and should be treated as solid. public readonly void ComputeClosedCenterOfMass(out float volume, out Vector3 center) Parameters volume float Volume of the closed mesh. center Vector3 Center of mass of the closed mesh. ComputeClosedInertia(float) Computes the inertia of the mesh. Assumes the mesh is closed and should be treated as solid. public readonly BodyInertia ComputeClosedInertia(float mass) Parameters mass float Mass to scale the inertia tensor with. Returns BodyInertia Inertia tensor of the closed mesh. ComputeClosedInertia(float, out Vector3) Computes the inertia of the mesh around its volumetric center and recenters the points of the mesh around it. Assumes the mesh is closed and should be treated as solid. public BodyInertia ComputeClosedInertia(float mass, out Vector3 center) Parameters mass float Mass to scale the inertia tensor with. center Vector3 Center of the closed mesh. Returns BodyInertia Inertia tensor of the closed mesh. ComputeOpenCenterOfMass() Computes the center of mass of the mesh. Assumes the mesh is open and should be treated as a triangle soup. public readonly Vector3 ComputeOpenCenterOfMass() Returns Vector3 Center of mass of the open mesh. ComputeOpenInertia(float) Computes the inertia of the mesh. Assumes the mesh is open and should be treated as a triangle soup. public readonly BodyInertia ComputeOpenInertia(float mass) Parameters mass float Mass to scale the inertia tensor with. Returns BodyInertia Inertia of the open mesh. ComputeOpenInertia(float, out Vector3) Computes the inertia of the mesh around its volumetric center and recenters the points of the mesh around it. Assumes the mesh is open and should be treated as a triangle soup. public BodyInertia ComputeOpenInertia(float mass, out Vector3 center) Parameters mass float Mass to scale the inertia tensor with. center Vector3 Center of the open mesh. Returns BodyInertia Inertia tensor of the closed mesh. CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapeBatches) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapeBatches Shapes The set of shapes to contain this batch. Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine. CreateWithSweepBuild(Buffer<Triangle>, Vector3, BufferPool) Creates a mesh shape instance and builds an acceleration structure using a sweep builder. public static Mesh CreateWithSweepBuild(Buffer<Triangle> triangles, Vector3 scale, BufferPool pool) Parameters triangles Buffer<Triangle> Triangles to use in the mesh. scale Vector3 Scale to apply to all vertices at runtime. Note that the scale is not baked into the triangles or acceleration structure; the same set of triangles and acceleration structure can be used across multiple Mesh instances with different scales. pool BufferPool Pool used to allocate acceleration structures. Returns Mesh Created mesh shape. Remarks The sweep builder is significantly slower than the binned builder, but can sometimes create higher quality trees. Note that the binned builder can be tuned to create higher quality trees. That is usually a better choice than trying to use the sweep builder; this is here primarily for legacy reasons. CreateWithoutTreeBuild(Buffer<Triangle>, Vector3, BufferPool) Creates a mesh shape instance, but leaves the Tree in an unbuilt state. The tree must be built before the mesh can be used. public static Mesh CreateWithoutTreeBuild(Buffer<Triangle> triangles, Vector3 scale, BufferPool pool) Parameters triangles Buffer<Triangle> Triangles to use in the mesh. scale Vector3 Scale to apply to all vertices at runtime. Note that the scale is not baked into the triangles or acceleration structure; the same set of triangles and acceleration structure can be used across multiple Mesh instances with different scales. pool BufferPool Pool used to allocate acceleration structures. Returns Mesh Created mesh shape. Remarks In some cases, the default binned build may not be the ideal builder. This function does everything needed to set up a tree without the expense of figuring out the details of the acceleration structure. The user can then run whatever build/refinement process is appropriate. Dispose(BufferPool) Returns the mesh's resources to a buffer pool. public void Dispose(BufferPool bufferPool) Parameters bufferPool BufferPool Pool to return the mesh's resources to. FillSubtreesForTriangles(Span<Triangle>, Span<NodeChild>) Fills a buffer of subtrees according to a buffer of triangles. public static void FillSubtreesForTriangles(Span<Triangle> triangles, Span<NodeChild> subtrees) Parameters triangles Span<Triangle> Triangles to build subtrees from. subtrees Span<NodeChild> Subtrees created for the triangles. Remarks The term \"subtree\" is used because the binned builder does not care whether the input came from leaf nodes or a refinement process's internal nodes. FindLocalOverlaps<TOverlaps>(Vector3, Vector3, Vector3, float, BufferPool, Shapes, void*) public readonly void FindLocalOverlaps<TOverlaps>(Vector3 min, Vector3 max, Vector3 sweep, float maximumT, BufferPool pool, Shapes shapes, void* overlaps) where TOverlaps : ICollisionTaskSubpairOverlaps Parameters min Vector3 max Vector3 sweep Vector3 maximumT float pool BufferPool shapes Shapes overlaps void* Type Parameters TOverlaps FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair>, BufferPool, Shapes, ref TOverlaps) public readonly void FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair> pairs, BufferPool pool, Shapes shapes, ref TOverlaps overlaps) where TOverlaps : struct, ICollisionTaskOverlaps<TSubpairOverlaps> where TSubpairOverlaps : struct, ICollisionTaskSubpairOverlaps Parameters pairs Buffer<OverlapQueryForPair> pool BufferPool shapes Shapes overlaps TOverlaps Type Parameters TOverlaps TSubpairOverlaps GetLocalChild(int, out Triangle) Gets a child shape as it appears in the compound's local space. public readonly void GetLocalChild(int triangleIndex, out Triangle target) Parameters triangleIndex int target Triangle GetLocalChild(int, ref TriangleWide) Gets a child shape as it appears in the compound's local space. public readonly void GetLocalChild(int triangleIndex, ref TriangleWide target) Parameters triangleIndex int target TriangleWide GetPosedLocalChild(int, out Triangle, out RigidPose) Gets a child shape from the compound and compounds a pose for it in the local space of the compound parent. Useful for processes which require a child shape (like a triangle in a mesh) to have their center of mass at zero in the child's own local space. public readonly void GetPosedLocalChild(int triangleIndex, out Triangle target, out RigidPose childPose) Parameters triangleIndex int target Triangle childPose RigidPose Pose in the compound's local space that brings the child shape as described to the proper location in the parent compound's local space. GetSerializedByteCount() Gets the number of bytes it would take to store the given mesh in a byte buffer. public readonly int GetSerializedByteCount() Returns int Number of bytes it would take to store the mesh. RayTest<TRayHitHandler>(in RigidPose, in RayData, ref float, ref TRayHitHandler) Casts a ray against the mesh. Executes a callback for every test candidate and every hit. public readonly void RayTest<TRayHitHandler>(in RigidPose pose, in RayData ray, ref float maximumT, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the mesh during the ray test. ray RayData Ray to test against the mesh. maximumT float Maximum length of the ray in units of the ray direction length. hitHandler TRayHitHandler Callback to execute for every hit. Type Parameters TRayHitHandler Type of the callback to execute for every test candidate and hit. RayTest<TRayHitHandler>(in RigidPose, ref RaySource, ref TRayHitHandler) Casts a bunch of rays against the mesh at the same time, executing a callback for every test candidate and every hit. public readonly void RayTest<TRayHitHandler>(in RigidPose pose, ref RaySource rays, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters pose RigidPose Pose of the mesh during the ray test. rays RaySource Set of rays to cast against the mesh. hitHandler TRayHitHandler Callbacks to execute. Type Parameters TRayHitHandler Type of the callback to execute for every ray test candidate and every hit. Recenter(Vector3) Subtracts the newCenter from all points in the mesh hull. public void Recenter(Vector3 newCenter) Parameters newCenter Vector3 New center that all points will be made relative to. Serialize(Span<byte>) Writes a mesh's data to a byte buffer. public readonly void Serialize(Span<byte> data) Parameters data Span<byte> Byte buffer to store the mesh in."
  },
  "api/BepuPhysics.Collidables.MeshInertiaHelper.html": {
    "href": "api/BepuPhysics.Collidables.MeshInertiaHelper.html",
    "title": "Class MeshInertiaHelper | Bepu API",
    "keywords": "Class MeshInertiaHelper Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Provides helpers for computing the inertia of objects with triangular surfaces. public static class MeshInertiaHelper Inheritance object MeshInertiaHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ComputeClosedCenterOfMass<TTriangleSource>(ref TTriangleSource, out float, out Vector3) Computes the center of mass of a closed mesh. public static void ComputeClosedCenterOfMass<TTriangleSource>(ref TTriangleSource triangleSource, out float volume, out Vector3 center) where TTriangleSource : ITriangleSource Parameters triangleSource TTriangleSource Source from which to retrieve a sequence of triangles. volume float Volume of the mesh. center Vector3 Center of mass of the mesh. Type Parameters TTriangleSource Type of the triangle source. ComputeClosedInertia<TTriangleSource>(ref TTriangleSource, float, out float, out Symmetric3x3) Computes the inertia of a closed mesh. Triangles visible from outside the shape are assumed to have clockwise winding in right handed coordinates or counterclockwise winding in left handed coordinates. public static void ComputeClosedInertia<TTriangleSource>(ref TTriangleSource triangleSource, float mass, out float volume, out Symmetric3x3 inertia) where TTriangleSource : ITriangleSource Parameters triangleSource TTriangleSource Source from which to retrieve a sequence of triangles. mass float Mass of the mesh to scale the inertia tensor with. volume float Volume of the mesh. inertia Symmetric3x3 Inertia tensor of the mesh. Type Parameters TTriangleSource Type of the triangle source. ComputeClosedInertia<TTriangleSource>(ref TTriangleSource, float, out float, out Symmetric3x3, out Vector3) Computes the inertia of a closed mesh. Triangles visible from outside the shape are assumed to have clockwise winding in right handed coordinates or counterclockwise winding in left handed coordinates. public static void ComputeClosedInertia<TTriangleSource>(ref TTriangleSource triangleSource, float mass, out float volume, out Symmetric3x3 inertia, out Vector3 center) where TTriangleSource : ITriangleSource Parameters triangleSource TTriangleSource Source from which to retrieve a sequence of triangles. mass float Mass of the mesh to scale the inertia tensor with. volume float Volume of the mesh. inertia Symmetric3x3 Inertia tensor of the mesh. center Vector3 Center of mass of the mesh. Type Parameters TTriangleSource Type of the triangle source. ComputeOpenCenterOfMass<TTriangleSource>(ref TTriangleSource) Computes the center of mass of an open mesh, treating it as a triangle soup. public static Vector3 ComputeOpenCenterOfMass<TTriangleSource>(ref TTriangleSource triangleSource) where TTriangleSource : ITriangleSource Parameters triangleSource TTriangleSource Source from which to retrieve a sequence of triangles. Returns Vector3 Center of mass of the mesh. Type Parameters TTriangleSource Type of the triangle source. ComputeOpenInertia<TTriangleSource>(ref TTriangleSource, float, out Symmetric3x3) Computes the inertia of an open mesh, treating it as a triangle soup. public static void ComputeOpenInertia<TTriangleSource>(ref TTriangleSource triangleSource, float mass, out Symmetric3x3 inertia) where TTriangleSource : ITriangleSource Parameters triangleSource TTriangleSource Source from which to retrieve a sequence of triangles. mass float Mass of the mesh to scale the inertia tensor with. inertia Symmetric3x3 Inertia tensor of the mesh. Type Parameters TTriangleSource Type of the triangle source. ComputeOpenInertia<TTriangleSource>(ref TTriangleSource, float, out Symmetric3x3, out Vector3) Computes the inertia of an open mesh, treating it as a triangle soup. public static void ComputeOpenInertia<TTriangleSource>(ref TTriangleSource triangleSource, float mass, out Symmetric3x3 inertia, out Vector3 center) where TTriangleSource : ITriangleSource Parameters triangleSource TTriangleSource Source from which to retrieve a sequence of triangles. mass float Mass of the mesh to scale the inertia tensor with. inertia Symmetric3x3 Inertia tensor of the mesh. center Vector3 Center of mass of the mesh. Type Parameters TTriangleSource Type of the triangle source. ComputeTetrahedronContribution(Vector3, Vector3, Vector3, float, out Symmetric3x3) public static void ComputeTetrahedronContribution(Vector3 a, Vector3 b, Vector3 c, float mass, out Symmetric3x3 inertiaTensor) Parameters a Vector3 b Vector3 c Vector3 mass float inertiaTensor Symmetric3x3 ComputeTetrahedronContribution(Vector3, Vector3, Vector3, out float, out Symmetric3x3) Integrates the inertia contribution of a tetrahedron with vertices at a, b, c, and (0,0,0) assuming a density of 1. public static void ComputeTetrahedronContribution(Vector3 a, Vector3 b, Vector3 c, out float volume, out Symmetric3x3 inertiaTensor) Parameters a Vector3 First vertex of the tetrahedron. b Vector3 Second vertex of the tetrahedron. c Vector3 Third vertex of the tetrahedron. volume float Volume of the tetrahedron. inertiaTensor Symmetric3x3 Inertia tensor of this tetrahedron assuming a density of 1. ComputeTetrahedronVolume(Vector3, Vector3, Vector3) Computes the signed volume of a tetrahedron where the fourth vertex is at the origin. Triangles visible from outside the shape are assumed to have clockwise winding in right handed coordinates or counterclockwise winding in left handed coordinates. public static float ComputeTetrahedronVolume(Vector3 a, Vector3 b, Vector3 c) Parameters a Vector3 First vertex of the tetrahedron. b Vector3 Second vertex of the tetrahedron. c Vector3 Third vertex of the tetrahedron. Returns float Volume of the tetrahedron. ComputeTriangleArea(Vector3, Vector3, Vector3) Computes the area of a triangle. public static float ComputeTriangleArea(Vector3 a, Vector3 b, Vector3 c) Parameters a Vector3 First vertex in the triangle. b Vector3 Second vertex in the triangle. c Vector3 Third vertex in the triangle. Returns float Area of the triangle. ComputeTriangleContribution(Vector3, Vector3, Vector3, float, out Symmetric3x3) Integrates the inertia contribution from a single triangle. public static void ComputeTriangleContribution(Vector3 a, Vector3 b, Vector3 c, float mass, out Symmetric3x3 inertiaTensor) Parameters a Vector3 First vertex in the triangle. b Vector3 Second vertex in the triangle. c Vector3 Third vertex in the triangle. mass float Mass of the triangle. inertiaTensor Symmetric3x3 Inertia tensor of the triangle. ComputeTriangleContribution(Vector3, Vector3, Vector3, out float, out Symmetric3x3) Integrates the inertia contribution from a single triangle assuming a density of 1. public static void ComputeTriangleContribution(Vector3 a, Vector3 b, Vector3 c, out float area, out Symmetric3x3 inertiaTensor) Parameters a Vector3 First vertex in the triangle. b Vector3 Second vertex in the triangle. c Vector3 Third vertex in the triangle. area float Area of the triangle. inertiaTensor Symmetric3x3 Inertia tensor of the triangle assuming that the density is 1. GetInertiaOffset(float, Vector3, out Symmetric3x3) Computes an offset for an inertia tensor based on an offset frame of reference. public static void GetInertiaOffset(float mass, Vector3 offset, out Symmetric3x3 inertiaOffset) Parameters mass float Mass associated with the inertia tensor being moved. offset Vector3 Offset from the current inertia frame of reference to the new frame of reference. inertiaOffset Symmetric3x3 Modification to add to the inertia tensor to move it into the new reference frame."
  },
  "api/BepuPhysics.Collidables.RayWide.html": {
    "href": "api/BepuPhysics.Collidables.RayWide.html",
    "title": "Struct RayWide | Bepu API",
    "keywords": "Struct RayWide Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct RayWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Direction public Vector3Wide Direction Field Value Vector3Wide Origin public Vector3Wide Origin Field Value Vector3Wide Methods Gather(in RayData) public void Gather(in RayData ray) Parameters ray RayData"
  },
  "api/BepuPhysics.Collidables.ShapeBatch-1.html": {
    "href": "api/BepuPhysics.Collidables.ShapeBatch-1.html",
    "title": "Class ShapeBatch<TShape> | Bepu API",
    "keywords": "Class ShapeBatch<TShape> Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public abstract class ShapeBatch<TShape> : ShapeBatch where TShape : unmanaged, IShape Type Parameters TShape Inheritance object ShapeBatch ShapeBatch<TShape> Derived CompoundShapeBatch<TShape> ConvexShapeBatch<TShape, TShapeWide> HomogeneousCompoundShapeBatch<TShape, TChildShape, TChildShapeWide> Inherited Members ShapeBatch.shapesData ShapeBatch.shapeDataSize ShapeBatch.Capacity ShapeBatch.pool ShapeBatch.idPool ShapeBatch.TypeId ShapeBatch.Compound ShapeBatch.ShapeDataSize ShapeBatch.Dispose(int, BufferPool) ShapeBatch.RemoveAndDisposeChildren(int, Shapes, BufferPool) ShapeBatch.Remove(int) ShapeBatch.RemoveAndDispose(int, BufferPool) ShapeBatch.RecursivelyRemoveAndDispose(int, Shapes, BufferPool) ShapeBatch.ComputeBounds(ref BoundingBoxBatcher) ShapeBatch.ComputeBounds(int, Quaternion, out Vector3, out Vector3) ShapeBatch.ComputeBounds(int, Vector3, Quaternion, out Vector3, out Vector3) ShapeBatch.ComputeBounds(int, RigidPose, out Vector3, out Vector3) ShapeBatch.RayTest<TRayHitHandler>(int, in RigidPose, in RayData, ref float, ref TRayHitHandler) ShapeBatch.RayTest<TRayHitHandler>(int, in RigidPose, ref RaySource, ref TRayHitHandler) ShapeBatch.GetShapeData(int, out void*, out int) ShapeBatch.ResizeIdPool(int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ShapeBatch(BufferPool, int) protected ShapeBatch(BufferPool pool, int initialShapeCount) Parameters pool BufferPool initialShapeCount int Properties this[int] Gets a reference to the shape associated with an index. public ref TShape this[int shapeIndex] { get; } Parameters shapeIndex int Index of the shape reference to retrieve. Property Value TShape Reference to the shape at the given index. Methods Add(in TShape) public int Add(in TShape shape) Parameters shape TShape Returns int Clear() Frees all shape slots without returning any resources to the pool. public override void Clear() Dispose() Returns all backing resources to the pool, leaving the batch in an unusable state. public override void Dispose() EnsureCapacity(int) Increases the size of the type batch if necessary to hold the target capacity. public override void EnsureCapacity(int shapeCapacity) Parameters shapeCapacity int Target capacity. Resize(int) Changes the size of the type batch if the target capacity is different than the current capacity. Note that shrinking allocations is conservative; resizing will never allow an existing shape to point to unallocated memory. public override void Resize(int shapeCapacity) Parameters shapeCapacity int Target capacity."
  },
  "api/BepuPhysics.Collidables.ShapeBatch.html": {
    "href": "api/BepuPhysics.Collidables.ShapeBatch.html",
    "title": "Class ShapeBatch | Bepu API",
    "keywords": "Class ShapeBatch Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public abstract class ShapeBatch Inheritance object ShapeBatch Derived ShapeBatch<TShape> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields idPool protected IdPool idPool Field Value IdPool pool protected BufferPool pool Field Value BufferPool shapeDataSize protected int shapeDataSize Field Value int shapesData protected Buffer<byte> shapesData Field Value Buffer<byte> Properties Capacity Gets the number of shapes that the batch can currently hold without resizing. public int Capacity { get; } Property Value int Compound Gets whether this shape batch's contained type potentially contains children that require other shape batches. public bool Compound { get; protected set; } Property Value bool ShapeDataSize Gets the size of the shape type stored in this batch in bytes. public int ShapeDataSize { get; } Property Value int TypeId Gets the type id of the shape type in this batch. public int TypeId { get; protected set; } Property Value int Methods Clear() Frees all shape slots without returning any resources to the pool. public abstract void Clear() ComputeBounds(ref BoundingBoxBatcher) public abstract void ComputeBounds(ref BoundingBoxBatcher batcher) Parameters batcher BoundingBoxBatcher ComputeBounds(int, RigidPose, out Vector3, out Vector3) public void ComputeBounds(int shapeIndex, RigidPose pose, out Vector3 min, out Vector3 max) Parameters shapeIndex int pose RigidPose min Vector3 max Vector3 ComputeBounds(int, Quaternion, out Vector3, out Vector3) public abstract void ComputeBounds(int shapeIndex, Quaternion orientation, out Vector3 min, out Vector3 max) Parameters shapeIndex int orientation Quaternion min Vector3 max Vector3 ComputeBounds(int, Vector3, Quaternion, out Vector3, out Vector3) public void ComputeBounds(int shapeIndex, Vector3 position, Quaternion orientation, out Vector3 min, out Vector3 max) Parameters shapeIndex int position Vector3 orientation Quaternion min Vector3 max Vector3 Dispose() Returns all backing resources to the pool, leaving the batch in an unusable state. public abstract void Dispose() Dispose(int, BufferPool) protected abstract void Dispose(int index, BufferPool pool) Parameters index int pool BufferPool EnsureCapacity(int) Increases the size of the type batch if necessary to hold the target capacity. public abstract void EnsureCapacity(int shapeCapacity) Parameters shapeCapacity int Target capacity. GetShapeData(int, out void*, out int) Gets a raw untyped pointer to a shape's data. public void GetShapeData(int shapeIndex, out void* shapePointer, out int shapeSize) Parameters shapeIndex int Index of the shape to look up. shapePointer void* Pointer to the indexed shape data. shapeSize int Size of the shape data in bytes. RayTest<TRayHitHandler>(int, in RigidPose, in RayData, ref float, ref TRayHitHandler) public abstract void RayTest<TRayHitHandler>(int shapeIndex, in RigidPose pose, in RayData ray, ref float maximumT, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters shapeIndex int pose RigidPose ray RayData maximumT float hitHandler TRayHitHandler Type Parameters TRayHitHandler RayTest<TRayHitHandler>(int, in RigidPose, ref RaySource, ref TRayHitHandler) public abstract void RayTest<TRayHitHandler>(int shapeIndex, in RigidPose pose, ref RaySource rays, ref TRayHitHandler hitHandler) where TRayHitHandler : struct, IShapeRayHitHandler Parameters shapeIndex int pose RigidPose rays RaySource hitHandler TRayHitHandler Type Parameters TRayHitHandler RecursivelyRemoveAndDispose(int, Shapes, BufferPool) public void RecursivelyRemoveAndDispose(int index, Shapes shapes, BufferPool pool) Parameters index int shapes Shapes pool BufferPool Remove(int) public void Remove(int index) Parameters index int RemoveAndDispose(int, BufferPool) public void RemoveAndDispose(int index, BufferPool pool) Parameters index int pool BufferPool RemoveAndDisposeChildren(int, Shapes, BufferPool) protected abstract void RemoveAndDisposeChildren(int index, Shapes shapes, BufferPool pool) Parameters index int shapes Shapes pool BufferPool Resize(int) Changes the size of the type batch if the target capacity is different than the current capacity. Note that shrinking allocations is conservative; resizing will never allow an existing shape to point to unallocated memory. public abstract void Resize(int shapeCapacity) Parameters shapeCapacity int Target capacity. ResizeIdPool(int) Shrinks or expands the allocation of the batch's id pool. Note that shrinking allocations is conservative; resizing will never allow any pending ids to be lost. public void ResizeIdPool(int targetIdCapacity) Parameters targetIdCapacity int Number of slots to allocate space for in the id pool."
  },
  "api/BepuPhysics.Collidables.ShapeTreeOverlapEnumerator-1.html": {
    "href": "api/BepuPhysics.Collidables.ShapeTreeOverlapEnumerator-1.html",
    "title": "Struct ShapeTreeOverlapEnumerator<TSubpairOverlaps> | Bepu API",
    "keywords": "Struct ShapeTreeOverlapEnumerator<TSubpairOverlaps> Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct ShapeTreeOverlapEnumerator<TSubpairOverlaps> : IBreakableForEach<int> where TSubpairOverlaps : ICollisionTaskSubpairOverlaps Type Parameters TSubpairOverlaps Implements IBreakableForEach<int> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Overlaps public void* Overlaps Field Value void* Pool public BufferPool Pool Field Value BufferPool Methods LoopBody(int) Executes one execution of the loop body. public bool LoopBody(int i) Parameters i int Visited element. Returns bool True if the loop should continue, false otherwise."
  },
  "api/BepuPhysics.Collidables.ShapeTreeSweepLeafTester-1.html": {
    "href": "api/BepuPhysics.Collidables.ShapeTreeSweepLeafTester-1.html",
    "title": "Struct ShapeTreeSweepLeafTester<TOverlaps> | Bepu API",
    "keywords": "Struct ShapeTreeSweepLeafTester<TOverlaps> Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct ShapeTreeSweepLeafTester<TOverlaps> : ISweepLeafTester where TOverlaps : ICollisionTaskSubpairOverlaps Type Parameters TOverlaps Implements ISweepLeafTester Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Overlaps public void* Overlaps Field Value void* Pool public BufferPool Pool Field Value BufferPool Methods TestLeaf(int, ref float) public void TestLeaf(int leafIndex, ref float maximumT) Parameters leafIndex int maximumT float"
  },
  "api/BepuPhysics.Collidables.Shapes.html": {
    "href": "api/BepuPhysics.Collidables.Shapes.html",
    "title": "Class Shapes | Bepu API",
    "keywords": "Class Shapes Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public class Shapes Inheritance object Shapes Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Shapes(BufferPool, int) public Shapes(BufferPool pool, int initialCapacityPerTypeBatch) Parameters pool BufferPool initialCapacityPerTypeBatch int Properties InitialCapacityPerTypeBatch public int InitialCapacityPerTypeBatch { get; set; } Property Value int this[int] public ShapeBatch this[int typeIndex] { get; } Parameters typeIndex int Property Value ShapeBatch RegisteredTypeSpan public int RegisteredTypeSpan { get; } Property Value int Methods Add<TShape>(in TShape) public TypedIndex Add<TShape>(in TShape shape) where TShape : unmanaged, IShape Parameters shape TShape Returns TypedIndex Type Parameters TShape Clear() Clears all shapes from existing batches. Does not release any memory. public void Clear() Dispose() Releases all memory from existing batches. Leaves shapes set in an unusable state. public void Dispose() EnsureBatchCapacities(int) Ensures a minimum capacity for all existing shape batches. public void EnsureBatchCapacities(int shapeCapacity) Parameters shapeCapacity int Capacity to ensure for all existing shape batches. GetShape<TShape>(int) public ref TShape GetShape<TShape>(int shapeIndex) where TShape : unmanaged, IShape Parameters shapeIndex int Returns TShape Type Parameters TShape RecursivelyRemoveAndDispose(TypedIndex, BufferPool) Removes a shape and any existing children from the shapes collection and returns their resources to the given pool. public void RecursivelyRemoveAndDispose(TypedIndex shapeIndex, BufferPool pool) Parameters shapeIndex TypedIndex Index of the shape to remove. pool BufferPool Pool to return all shape resources to. Remove(TypedIndex) Removes a shape without removing its children or disposing any resources. public void Remove(TypedIndex shapeIndex) Parameters shapeIndex TypedIndex Index of the shape to remove. RemoveAndDispose(TypedIndex, BufferPool) Removes a shape from the shapes collection and returns its resources to the given pool. Does not remove or dispose any children. public void RemoveAndDispose(TypedIndex shapeIndex, BufferPool pool) Parameters shapeIndex TypedIndex Index of the shape to remove. pool BufferPool Pool to return all shape resources to. ResizeBatches(int) Resizes all existing batches for a target capacity. Note that this is conservative; it will never orphan an existing shape. public void ResizeBatches(int shapeCapacity) Parameters shapeCapacity int Capacity to target for all existing shape batches. UpdateBounds(RigidPose, TypedIndex, out BoundingBox) Computes a bounding box for a single shape. public void UpdateBounds(RigidPose pose, TypedIndex shapeIndex, out BoundingBox bounds) Parameters pose RigidPose Pose to calculate the bounding box of. shapeIndex TypedIndex Index of the shape. bounds BoundingBox Bounding box of the specified shape with the specified pose. UpdateBounds(Vector3, Quaternion, TypedIndex, out BoundingBox) Computes a bounding box for a single shape. public void UpdateBounds(Vector3 position, Quaternion orientation, TypedIndex shapeIndex, out BoundingBox bounds) Parameters position Vector3 Position of the shape. orientation Quaternion Orientation of the shape. shapeIndex TypedIndex Index of the shape. bounds BoundingBox Bounding box of the specified shape with the specified pose."
  },
  "api/BepuPhysics.Collidables.Sphere.html": {
    "href": "api/BepuPhysics.Collidables.Sphere.html",
    "title": "Struct Sphere | Bepu API",
    "keywords": "Struct Sphere Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct Sphere : IConvexShape, IShape Implements IConvexShape IShape Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Sphere(float) Creates a sphere shape. public Sphere(float radius) Parameters radius float Radius of the sphere. Fields Id Type id of sphere shapes. public const int Id = 0 Field Value int Radius Radius of the sphere. public float Radius Field Value float Properties TypeId Unique type id for this shape type. public static int TypeId { get; } Property Value int Methods ComputeAngularExpansionData(out float, out float) Computes information about how the bounding box should be expanded in response to angular velocity. public readonly void ComputeAngularExpansionData(out float maximumRadius, out float maximumAngularExpansion) Parameters maximumRadius float maximumAngularExpansion float Remarks This is typically used in the engine for predicting bounding boxes at the beginning of the frame. Velocities are used to expand the bounding box so that likely future collisions will be detected. Linear velocity expands the bounding box in a direct and simple way, but angular expansion requires more information about the shape. Imagine a long and thin capsule versus a sphere: high angular velocity may require significant expansion on the capsule, but spheres are rotationally invariant. ComputeBounds(Quaternion, out Vector3, out Vector3) Computes the bounding box of a shape given an orientation. public readonly void ComputeBounds(Quaternion orientation, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the shape to use when computing the bounding box. min Vector3 Minimum corner of the bounding box. max Vector3 Maximum corner of the bounding box. ComputeInertia(float) Computes the inertia for a body given a mass. public readonly BodyInertia ComputeInertia(float mass) Parameters mass float Mass to use to compute the body's inertia. Returns BodyInertia Inertia for the body. Remarks Note that the BodyInertia returned by this stores the inverse mass and inverse inertia tensor. This is because the most high frequency use of body inertia most naturally uses the inverse. CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapes) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapes Shapes Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine. RayTest(in RigidPose, Vector3, Vector3, out float, out Vector3) Tests a ray against the shape. public readonly bool RayTest(in RigidPose pose, Vector3 origin, Vector3 direction, out float t, out Vector3 normal) Parameters pose RigidPose Pose of the shape during the ray test. origin Vector3 Origin of the ray to test against the shape relative to the shape. direction Vector3 Direction of the ray to test against the shape. t float Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3 Normal of the impact surface, if any. Returns bool True if the ray intersected the shape, false otherwise."
  },
  "api/BepuPhysics.Collidables.SphereSupportFinder.html": {
    "href": "api/BepuPhysics.Collidables.SphereSupportFinder.html",
    "title": "Struct SphereSupportFinder | Bepu API",
    "keywords": "Struct SphereSupportFinder Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct SphereSupportFinder : ISupportFinder<Sphere, SphereWide> Implements ISupportFinder<Sphere, SphereWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties HasMargin Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape. public bool HasMargin { get; } Property Value bool Methods ComputeLocalSupport(in SphereWide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeLocalSupport(in SphereWide shape, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape SphereWide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide ComputeSupport(in SphereWide, in Matrix3x3Wide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeSupport(in SphereWide shape, in Matrix3x3Wide orientation, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape SphereWide orientation Matrix3x3Wide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide GetMargin(in SphereWide, out Vector<float>) Margin associated with the shape according to this support finder. public void GetMargin(in SphereWide shape, out Vector<float> margin) Parameters shape SphereWide Shape to find the margin of. margin Vector<float> Margin of the shape."
  },
  "api/BepuPhysics.Collidables.SphereWide.html": {
    "href": "api/BepuPhysics.Collidables.SphereWide.html",
    "title": "Struct SphereWide | Bepu API",
    "keywords": "Struct SphereWide Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct SphereWide : IShapeWide<Sphere> Implements IShapeWide<Sphere> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Radius public Vector<float> Radius Field Value Vector<float> Properties AllowOffsetMemoryAccess Gets whether this type supports accessing its memory by lane offsets. If false, WriteSlot must be used instead of WriteFirst. public bool AllowOffsetMemoryAccess { get; } Property Value bool InternalAllocationSize Gets the number of bytes required for allocations within the wide shape. public int InternalAllocationSize { get; } Property Value int MinimumWideRayCount Gets the lower bound on the number of rays to execute in a wide fashion. Ray bundles with fewer rays will fall back to the single ray code path. public static int MinimumWideRayCount { get; } Property Value int Methods Broadcast(in Sphere) Broadcasts a scalar shape into a bundle containing the same shape in every lane. public void Broadcast(in Sphere shape) Parameters shape Sphere Scalar shape to broadcast. GetBounds(ref QuaternionWide, int, out Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide) Computes the bounds of all shapes in the bundle. public void GetBounds(ref QuaternionWide orientations, int countInBundle, out Vector<float> maximumRadius, out Vector<float> maximumAngularExpansion, out Vector3Wide min, out Vector3Wide max) Parameters orientations QuaternionWide Orientations of the shapes in the bundle. countInBundle int Number of lanes filled in the bundle. maximumRadius Vector<float> Computed maximum radius of the shapes in the bundle. maximumAngularExpansion Vector<float> Computed maximum bounds expansion that can be caused by angular motion. min Vector3Wide Minimum bounds of the shapes. max Vector3Wide Maximum bounds of the shapes. Initialize(in Buffer<byte>) For types with a nonzero internal allocation size, provides memory to the shape for internal allocations. Memory should be assumed to be stack allocated. public void Initialize(in Buffer<byte> memory) Parameters memory Buffer<byte> Memory to use for internal allocations in the wide shape. RayTest(ref RigidPoseWide, ref RayWide, out Vector<int>, out Vector<float>, out Vector3Wide) Tests a ray against the shape. public void RayTest(ref RigidPoseWide pose, ref RayWide rayWide, out Vector<int> intersected, out Vector<float> t, out Vector3Wide normal) Parameters pose RigidPoseWide rayWide RayWide Ray to test against the shape bundle. intersected Vector<int> Mask representing hit state in each lane. -1 means the ray in that lane hit, 0 means a miss. t Vector<float> Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3Wide Normal of the impact surface, if any. WriteFirst(in Sphere) Places the specified AOS-formatted shape into the first lane of the wide 'this' reference. public void WriteFirst(in Sphere source) Parameters source Sphere AOS-formatted shape to gather from. Remarks Note that we are effectively using the TShapeWide as a stride. The base address is offset by the user of this function, so the implementation only ever considers the first slot. WriteSlot(int, in Sphere) Places the specified AOS-formatted shape into the selected slot of the wide 'this' reference. public void WriteSlot(int index, in Sphere source) Parameters index int Index of the slot to put the data into. source Sphere Source of the data to insert."
  },
  "api/BepuPhysics.Collidables.Triangle.html": {
    "href": "api/BepuPhysics.Collidables.Triangle.html",
    "title": "Struct Triangle | Bepu API",
    "keywords": "Struct Triangle Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Collision shape representing an individual triangle. Triangle collisions and ray tests are one-sided; only tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates will generate contacts. public struct Triangle : IConvexShape, IShape Implements IConvexShape IShape Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Triangle(Vector3, Vector3, Vector3) Creates a triangle shape. public Triangle(Vector3 a, Vector3 b, Vector3 c) Parameters a Vector3 First vertex of the triangle in local space. b Vector3 Second vertex of the triangle in local space. c Vector3 Third vertex of the triangle in local space. Fields A First vertex of the triangle in local space. public Vector3 A Field Value Vector3 B Second vertex of the triangle in local space. public Vector3 B Field Value Vector3 C Third vertex of the triangle in local space. public Vector3 C Field Value Vector3 Id Type id of triangle shapes. public const int Id = 3 Field Value int Properties TypeId Unique type id for this shape type. public static int TypeId { get; } Property Value int Methods ComputeAngularExpansionData(out float, out float) Computes information about how the bounding box should be expanded in response to angular velocity. public readonly void ComputeAngularExpansionData(out float maximumRadius, out float maximumAngularExpansion) Parameters maximumRadius float maximumAngularExpansion float Remarks This is typically used in the engine for predicting bounding boxes at the beginning of the frame. Velocities are used to expand the bounding box so that likely future collisions will be detected. Linear velocity expands the bounding box in a direct and simple way, but angular expansion requires more information about the shape. Imagine a long and thin capsule versus a sphere: high angular velocity may require significant expansion on the capsule, but spheres are rotationally invariant. ComputeBounds(Quaternion, out Vector3, out Vector3) Computes the bounding box of a shape given an orientation. public readonly void ComputeBounds(Quaternion orientation, out Vector3 min, out Vector3 max) Parameters orientation Quaternion Orientation of the shape to use when computing the bounding box. min Vector3 Minimum corner of the bounding box. max Vector3 Maximum corner of the bounding box. ComputeInertia(float) Computes the inertia for a body given a mass. public readonly BodyInertia ComputeInertia(float mass) Parameters mass float Mass to use to compute the body's inertia. Returns BodyInertia Inertia for the body. Remarks Note that the BodyInertia returned by this stores the inverse mass and inverse inertia tensor. This is because the most high frequency use of body inertia most naturally uses the inverse. CreateShapeBatch(BufferPool, int, Shapes) Creates a shape batch for this type of shape. public static ShapeBatch CreateShapeBatch(BufferPool pool, int initialCapacity, Shapes shapeBatches) Parameters pool BufferPool Buffer pool used to create the batch. initialCapacity int Initial capacity to allocate within the batch. shapeBatches Shapes The set of shapes to contain this batch. Returns ShapeBatch Shape batch for the shape type. Remarks This is typically used internally to initialize new shape collections in response to shapes being added. It is not likely to be useful outside of the engine. RayTest(in RigidPose, Vector3, Vector3, out float, out Vector3) Tests a ray against the shape. public readonly bool RayTest(in RigidPose pose, Vector3 origin, Vector3 direction, out float t, out Vector3 normal) Parameters pose RigidPose Pose of the shape during the ray test. origin Vector3 Origin of the ray to test against the shape relative to the shape. direction Vector3 Direction of the ray to test against the shape. t float Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3 Normal of the impact surface, if any. Returns bool True if the ray intersected the shape, false otherwise. RayTest(Vector3, Vector3, Vector3, Vector3, Vector3, out float, out Vector3) public static bool RayTest(Vector3 a, Vector3 b, Vector3 c, Vector3 origin, Vector3 direction, out float t, out Vector3 normal) Parameters a Vector3 b Vector3 c Vector3 origin Vector3 direction Vector3 t float normal Vector3 Returns bool"
  },
  "api/BepuPhysics.Collidables.TriangleSupportFinder.html": {
    "href": "api/BepuPhysics.Collidables.TriangleSupportFinder.html",
    "title": "Struct TriangleSupportFinder | Bepu API",
    "keywords": "Struct TriangleSupportFinder Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct TriangleSupportFinder : ISupportFinder<Triangle, TriangleWide> Implements ISupportFinder<Triangle, TriangleWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties HasMargin Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape. public bool HasMargin { get; } Property Value bool Methods ComputeLocalSupport(in TriangleWide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeLocalSupport(in TriangleWide shape, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape TriangleWide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide ComputeSupport(in TriangleWide, in Matrix3x3Wide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeSupport(in TriangleWide shape, in Matrix3x3Wide orientation, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape TriangleWide orientation Matrix3x3Wide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide GetMargin(in TriangleWide, out Vector<float>) Margin associated with the shape according to this support finder. public void GetMargin(in TriangleWide shape, out Vector<float> margin) Parameters shape TriangleWide Shape to find the margin of. margin Vector<float> Margin of the shape."
  },
  "api/BepuPhysics.Collidables.TriangleWide.html": {
    "href": "api/BepuPhysics.Collidables.TriangleWide.html",
    "title": "Struct TriangleWide | Bepu API",
    "keywords": "Struct TriangleWide Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll public struct TriangleWide : IShapeWide<Triangle> Implements IShapeWide<Triangle> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public Vector3Wide A Field Value Vector3Wide B public Vector3Wide B Field Value Vector3Wide BackfaceNormalDotRejectionThreshold Minimum dot product between the detected local normal and the face normal of a triangle necessary to create contacts. public const float BackfaceNormalDotRejectionThreshold = -0.01 Field Value float C public Vector3Wide C Field Value Vector3Wide DegenerateTriangleEpsilon Epsilon to apply to testing triangles for degeneracy (which will be scaled by a pair-determined epsilon scale). Degenerate triangles do not have well defined normals and should not contribute public const float DegenerateTriangleEpsilon = 1E-06 Field Value float Properties AllowOffsetMemoryAccess Gets whether this type supports accessing its memory by lane offsets. If false, WriteSlot must be used instead of WriteFirst. public bool AllowOffsetMemoryAccess { get; } Property Value bool InternalAllocationSize Gets the number of bytes required for allocations within the wide shape. public int InternalAllocationSize { get; } Property Value int MinimumWideRayCount Gets the lower bound on the number of rays to execute in a wide fashion. Ray bundles with fewer rays will fall back to the single ray code path. public static int MinimumWideRayCount { get; } Property Value int Methods Broadcast(in Triangle) Broadcasts a scalar shape into a bundle containing the same shape in every lane. public void Broadcast(in Triangle shape) Parameters shape Triangle Scalar shape to broadcast. ComputeDegenerateTriangleEpsilon(in Vector<float>, in Vector<float>, out Vector<float>, out Vector<float>) public static void ComputeDegenerateTriangleEpsilon(in Vector<float> abLengthSquared, in Vector<float> caLengthSquared, out Vector<float> epsilonScale, out Vector<float> epsilon) Parameters abLengthSquared Vector<float> caLengthSquared Vector<float> epsilonScale Vector<float> epsilon Vector<float> ComputeNondegenerateTriangleMask(in Vector3Wide, in Vector3Wide, in Vector<float>, out Vector<float>, out Vector<int>) public static void ComputeNondegenerateTriangleMask(in Vector3Wide ab, in Vector3Wide ca, in Vector<float> triangleNormalLength, out Vector<float> epsilonScale, out Vector<int> nondegenerateMask) Parameters ab Vector3Wide ca Vector3Wide triangleNormalLength Vector<float> epsilonScale Vector<float> nondegenerateMask Vector<int> ComputeNondegenerateTriangleMask(in Vector<float>, in Vector<float>, in Vector<float>, out Vector<float>, out Vector<int>) public static void ComputeNondegenerateTriangleMask(in Vector<float> abLengthSquared, in Vector<float> caLengthSquared, in Vector<float> triangleNormalLength, out Vector<float> epsilonScale, out Vector<int> nondegenerateMask) Parameters abLengthSquared Vector<float> caLengthSquared Vector<float> triangleNormalLength Vector<float> epsilonScale Vector<float> nondegenerateMask Vector<int> ComputeTriangleEpsilonScale(in Vector<float>, in Vector<float>, out Vector<float>) public static void ComputeTriangleEpsilonScale(in Vector<float> abLengthSquared, in Vector<float> caLengthSquared, out Vector<float> epsilonScale) Parameters abLengthSquared Vector<float> caLengthSquared Vector<float> epsilonScale Vector<float> GetBounds(ref QuaternionWide, int, out Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide) Computes the bounds of all shapes in the bundle. public void GetBounds(ref QuaternionWide orientations, int countInBundle, out Vector<float> maximumRadius, out Vector<float> maximumAngularExpansion, out Vector3Wide min, out Vector3Wide max) Parameters orientations QuaternionWide Orientations of the shapes in the bundle. countInBundle int Number of lanes filled in the bundle. maximumRadius Vector<float> Computed maximum radius of the shapes in the bundle. maximumAngularExpansion Vector<float> Computed maximum bounds expansion that can be caused by angular motion. min Vector3Wide Minimum bounds of the shapes. max Vector3Wide Maximum bounds of the shapes. Initialize(in Buffer<byte>) For types with a nonzero internal allocation size, provides memory to the shape for internal allocations. Memory should be assumed to be stack allocated. public void Initialize(in Buffer<byte> memory) Parameters memory Buffer<byte> Memory to use for internal allocations in the wide shape. RayTest(ref RigidPoseWide, ref RayWide, out Vector<int>, out Vector<float>, out Vector3Wide) Tests a ray against the shape. public void RayTest(ref RigidPoseWide pose, ref RayWide ray, out Vector<int> intersected, out Vector<float> t, out Vector3Wide normal) Parameters pose RigidPoseWide ray RayWide intersected Vector<int> Mask representing hit state in each lane. -1 means the ray in that lane hit, 0 means a miss. t Vector<float> Distance along the ray direction to the hit point, if any, in units of the ray direction's length. In other words, hitLocation = origin + direction * t. normal Vector3Wide Normal of the impact surface, if any. RayTest(ref Vector3Wide, ref Vector3Wide, ref Vector3Wide, ref Vector3Wide, ref Vector3Wide, out Vector<int>, out Vector<float>, out Vector3Wide) public static void RayTest(ref Vector3Wide a, ref Vector3Wide b, ref Vector3Wide c, ref Vector3Wide origin, ref Vector3Wide direction, out Vector<int> intersected, out Vector<float> t, out Vector3Wide normal) Parameters a Vector3Wide b Vector3Wide c Vector3Wide origin Vector3Wide direction Vector3Wide intersected Vector<int> t Vector<float> normal Vector3Wide WriteFirst(in Triangle) Places the specified AOS-formatted shape into the first lane of the wide 'this' reference. public void WriteFirst(in Triangle source) Parameters source Triangle AOS-formatted shape to gather from. Remarks Note that we are effectively using the TShapeWide as a stride. The base address is offset by the user of this function, so the implementation only ever considers the first slot. WriteSlot(int, in Triangle) Places the specified AOS-formatted shape into the selected slot of the wide 'this' reference. public void WriteSlot(int index, in Triangle source) Parameters index int Index of the slot to put the data into. source Triangle Source of the data to insert."
  },
  "api/BepuPhysics.Collidables.TypedIndex.html": {
    "href": "api/BepuPhysics.Collidables.TypedIndex.html",
    "title": "Struct TypedIndex | Bepu API",
    "keywords": "Struct TypedIndex Namespace BepuPhysics.Collidables Assembly BepuPhysics.dll Represents an index with an associated type packed into a single integer. public struct TypedIndex : IEquatable<TypedIndex> Implements IEquatable<TypedIndex> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors TypedIndex(int, int) public TypedIndex(int type, int index) Parameters type int index int Fields Packed Bit packed representation of the typed index. public uint Packed Field Value uint Properties Exists Gets whether this index actually refers to anything. The Type and Index should only be used if this is true. public bool Exists { get; } Property Value bool Index Gets the index of the object. public int Index { get; } Property Value int Type Gets the type index of the object. public int Type { get; } Property Value int Methods Equals(TypedIndex) Indicates whether the current object is equal to another object of the same type. public bool Equals(TypedIndex other) Parameters other TypedIndex An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object other) Parameters other object Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(TypedIndex, TypedIndex) public static bool operator ==(TypedIndex x, TypedIndex y) Parameters x TypedIndex y TypedIndex Returns bool operator !=(TypedIndex, TypedIndex) public static bool operator !=(TypedIndex x, TypedIndex y) Parameters x TypedIndex y TypedIndex Returns bool"
  },
  "api/BepuPhysics.Collidables.html": {
    "href": "api/BepuPhysics.Collidables.html",
    "title": "Namespace BepuPhysics.Collidables | Bepu API",
    "keywords": "Namespace BepuPhysics.Collidables Classes CompoundShapeBatch<TShape> ConvexHullHelper Helper methods to create and process convex hulls from point clouds. ConvexHullShapeBatch ConvexShapeBatch<TShape, TShapeWide> HomogeneousCompoundShapeBatch<TShape, TChildShape, TChildShapeWide> MeshInertiaHelper Provides helpers for computing the inertia of objects with triangular surfaces. ShapeBatch ShapeBatch<TShape> Shapes Structs BigCompound Compound shape containing a bunch of shapes accessible through a tree acceleration structure. Useful for compounds with lots of children. Box Collision shape representing a solid cuboid. BoxSupportFinder BoxWide Capsule Collision shape representing a sphere-expanded line segment. CapsuleSupportFinder CapsuleWide Collidable Description of a collidable used by a body living in the broad phase and able to generate collision pairs. Collidables with a ShapeIndex that points to nothing (a default constructed TypedIndex) are not capable of colliding with anything. This can be used for a body which needs no collidable representation. CollidableDescription Describes a collidable and how it should handle continuous collision detection. CollidableReference Uses a bitpacked representation to refer to a body or static collidable. CollidableReferenceComparer Compound Minimalist compound shape containing a list of child shapes. Does not make use of any internal acceleration structure; should be used only with small groups of shapes. CompoundBuilder Reusable convenience type for incrementally building compound shapes. CompoundBuilder.Child CompoundChild Shape and pose of a child within a compound shape. ContinuousDetection Defines how a collidable handles collisions with significant velocity. ConvexHull ConvexHull.ConvexHullTriangleSource ConvexHullHelper.EdgeEndpoints ConvexHullSupportFinder ConvexHullWide Cylinder Collision shape representing a cylinder. CylinderSupportFinder CylinderWide HullBoundingPlanes HullData Raw data representing a convex hull. HullFace Stores references to the points composing one of a convex hull's faces. HullVertexIndex Mesh Shape designed to contain a whole bunch of triangles. Triangle collisions and ray tests are one-sided; only tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates will generate contacts. Mesh.MeshTriangleSource RayWide ShapeTreeOverlapEnumerator<TSubpairOverlaps> ShapeTreeSweepLeafTester<TOverlaps> Sphere SphereSupportFinder SphereWide Triangle Collision shape representing an individual triangle. Triangle collisions and ray tests are one-sided; only tests which see the triangle as wound clockwise in right handed coordinates or counterclockwise in left handed coordinates will generate contacts. TriangleSupportFinder TriangleWide TypedIndex Represents an index with an associated type packed into a single integer. Interfaces ICompoundShape Defines a compound shape type that has children of potentially different types. IConvexShape Defines functions available on all convex shapes. Convex shapes have no hollowed out regions; any line passing through a convex shape will never enter and exit more than once. IConvexShapeBatch Defines a shape batch containing convex objects that support simple inertia calculations. IDisposableShape IHomogeneousCompoundShape<TChildShape, TChildShapeWide> Defines a compound shape type that has children of only one type. IShape Defines a type usable as a shape by collidables. IShapeWide<TShape> Defines a widely vectorized bundle representation of a shape. ITriangleSource Defines a type capable of providing a sequence of triangles. Enums CollidableMobility Represents how a collidable can interact and move. ContinuousDetectionMode Defines how a collidable will handle collision detection in the presence of velocity."
  },
  "api/BepuPhysics.CollisionDetection.BatcherContinuations-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.BatcherContinuations-1.html",
    "title": "Struct BatcherContinuations<T> | Bepu API",
    "keywords": "Struct BatcherContinuations<T> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct BatcherContinuations<T> where T : unmanaged, ICollisionTestContinuation Type Parameters T Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Continuations public Buffer<T> Continuations Field Value Buffer<T> IdPool public IdPool IdPool Field Value IdPool Methods ContributeChildToContinuation<TCallbacks>(ref PairContinuation, ref ConvexContactManifold, ref CollisionBatcher<TCallbacks>) public void ContributeChildToContinuation<TCallbacks>(ref PairContinuation continuation, ref ConvexContactManifold manifold, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters continuation PairContinuation manifold ConvexContactManifold batcher CollisionBatcher<TCallbacks> Type Parameters TCallbacks ContributeUntestedChildToContinuation<TCallbacks>(ref PairContinuation, ref CollisionBatcher<TCallbacks>) public void ContributeUntestedChildToContinuation<TCallbacks>(ref PairContinuation continuation, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters continuation PairContinuation batcher CollisionBatcher<TCallbacks> Type Parameters TCallbacks CreateContinuation(int, BufferPool, out int) public ref T CreateContinuation(int slotsInContinuation, BufferPool pool, out int index) Parameters slotsInContinuation int pool BufferPool index int Returns T"
  },
  "api/BepuPhysics.CollisionDetection.BroadPhase.RefinementScheduler.html": {
    "href": "api/BepuPhysics.CollisionDetection.BroadPhase.RefinementScheduler.html",
    "title": "Delegate BroadPhase.RefinementScheduler | Bepu API",
    "keywords": "Delegate BroadPhase.RefinementScheduler Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Returns the size and number of refinements to execute during the broad phase. public delegate void BroadPhase.RefinementScheduler(int frameIndex, in Tree tree, out int rootRefinementSize, out int subtreeRefinementCount, out int subtreeRefinementSize, out bool usePriorityQueue) Parameters frameIndex int Index of the frame as tracked by the broad phase. tree Tree Tree being considered for refinement. rootRefinementSize int Size of the root refinement. If zero or negative, no root refinement will be performed. subtreeRefinementCount int Number of subtree refinements to perform. Can be zero. subtreeRefinementSize int Target size of the subtree refinements. usePriorityQueue bool True if the root refinement should use a priority queue during subtree collection to find larger nodes, false if it should try to collect a more balanced tree."
  },
  "api/BepuPhysics.CollisionDetection.BroadPhase.html": {
    "href": "api/BepuPhysics.CollisionDetection.BroadPhase.html",
    "title": "Class BroadPhase | Bepu API",
    "keywords": "Class BroadPhase Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Manages scene acceleration structures for collision detection and queries. public class BroadPhase : IDisposable Inheritance object BroadPhase Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BroadPhase(BufferPool, int, int) public BroadPhase(BufferPool pool, int initialActiveLeafCapacity = 4096, int initialStaticLeafCapacity = 8192) Parameters pool BufferPool initialActiveLeafCapacity int initialStaticLeafCapacity int Fields ActiveLeaves Collidable references contained within the ActiveTree. Note that values at or beyond the ActiveTree.LeafCount are not defined. public Buffer<CollidableReference> ActiveLeaves Field Value Buffer<CollidableReference> ActiveTree Tree containing wakeful bodies. public Tree ActiveTree Field Value Tree StaticLeaves Collidable references contained within the StaticTree. Note that values at or beyond StaticTree.LeafCount are not defined. public Buffer<CollidableReference> StaticLeaves Field Value Buffer<CollidableReference> StaticTree Tree containing sleeping bodies and statics. public Tree StaticTree Field Value Tree Properties ActiveRefinementSchedule Gets or sets the refinement schedule to use for the active tree. public BroadPhase.RefinementScheduler ActiveRefinementSchedule { get; set; } Property Value BroadPhase.RefinementScheduler Pool Pool used by the broad phase. public BufferPool Pool { get; } Property Value BufferPool StaticRefinementSchedule Gets or sets the refinement schedule to use for the static tree. public BroadPhase.RefinementScheduler StaticRefinementSchedule { get; set; } Property Value BroadPhase.RefinementScheduler Methods AddActive(CollidableReference, ref BoundingBox) public int AddActive(CollidableReference collidable, ref BoundingBox bounds) Parameters collidable CollidableReference bounds BoundingBox Returns int AddStatic(CollidableReference, ref BoundingBox) public int AddStatic(CollidableReference collidable, ref BoundingBox bounds) Parameters collidable CollidableReference bounds BoundingBox Returns int Clear() Clears out the broad phase's structures without releasing any resources. public void Clear() DefaultActiveRefinementScheduler(int, in Tree, out int, out int, out int, out bool) Returns the size and number of refinements to execute for the active tree. Used by default. public static void DefaultActiveRefinementScheduler(int frameIndex, in Tree tree, out int rootRefinementSize, out int subtreeRefinementCount, out int subtreeRefinementSize, out bool usePriorityQueue) Parameters frameIndex int Index of the frame as tracked by the broad phase. tree Tree Tree being considered for refinement. rootRefinementSize int Size of the root refinement. If zero or negative, no root refinement will be performed. subtreeRefinementCount int Number of subtree refinements to perform. Can be zero. subtreeRefinementSize int Target size of the subtree refinements. usePriorityQueue bool True if the root refinement should use a priority queue during subtree collection to find larger nodes, false if it should try to collect a more balanced tree. DefaultRefinementScheduler(float, int, float, float, int, int, in Tree, out int, out int, out int, out bool) Returns the size and number of refinements to execute for the active tree. Used by default. public static void DefaultRefinementScheduler(float optimizationFraction, int rootRefinementPeriod, float rootRefinementSizeScale, float subtreeRefinementSizeScale, int nonpriorityPeriod, int frameIndex, in Tree tree, out int rootRefinementSize, out int subtreeRefinementCount, out int subtreeRefinementSize, out bool usePriorityQueue) Parameters optimizationFraction float Target fraction of the tree to be optimized. rootRefinementPeriod int Period, in timesteps, of refinements applied to the root. rootRefinementSizeScale float Multiplier to apply to the square root of the leaf count to get the target root refinement size. subtreeRefinementSizeScale float Multiplier to apply to the square root of the leaf count to get the target subtree refinement size. nonpriorityPeriod int The period between non-priority queue based root refinements, measured in units of root refinements. frameIndex int Index of the frame as tracked by the broad phase. tree Tree Tree being considered for refinement. rootRefinementSize int Size of the root refinement. If zero or negative, no root refinement will be performed. subtreeRefinementCount int Number of subtree refinements to perform. Can be zero. subtreeRefinementSize int Target size of the subtree refinements. usePriorityQueue bool True if the root refinement should use a priority queue during subtree collection to find larger nodes, false if it should try to collect a more balanced tree. DefaultStaticRefinementScheduler(int, in Tree, out int, out int, out int, out bool) Returns the size and number of refinements to execute for the active tree. Used by default. public static void DefaultStaticRefinementScheduler(int frameIndex, in Tree tree, out int rootRefinementSize, out int subtreeRefinementCount, out int subtreeRefinementSize, out bool usePriorityQueue) Parameters frameIndex int Index of the frame as tracked by the broad phase. tree Tree Tree being considered for refinement. rootRefinementSize int Size of the root refinement. If zero or negative, no root refinement will be performed. subtreeRefinementCount int Number of subtree refinements to perform. Can be zero. subtreeRefinementSize int Target size of the subtree refinements. usePriorityQueue bool True if the root refinement should use a priority queue during subtree collection to find larger nodes, false if it should try to collect a more balanced tree. Dispose() Releases memory used by the broad phase. Leaves the broad phase unusable. public void Dispose() EnsureCapacity(int, int) Ensures that the broad phase structures can hold at least the given number of leaves. public void EnsureCapacity(int activeCapacity, int staticCapacity) Parameters activeCapacity int Number of leaves to allocate space for in the active tree. staticCapacity int Number of leaves to allocate space for in the static tree. GetActiveBoundsPointers(int, out Vector3*, out Vector3*) Gets pointers to the leaf's bounds stored in the broad phase's active tree. public void GetActiveBoundsPointers(int index, out Vector3* minPointer, out Vector3* maxPointer) Parameters index int Index of the active collidable to examine. minPointer Vector3* Pointer to the minimum bounds in the tree. maxPointer Vector3* Pointer to the maximum bounds in the tree. GetOverlaps<TOverlapEnumerator>(in BoundingBox, ref TOverlapEnumerator) Finds any overlaps between a bounding box and leaf bounding boxes. public void GetOverlaps<TOverlapEnumerator>(in BoundingBox boundingBox, ref TOverlapEnumerator overlapEnumerator) where TOverlapEnumerator : IBreakableForEach<CollidableReference> Parameters boundingBox BoundingBox Query box bounds. overlapEnumerator TOverlapEnumerator Enumerator to call for overlaps. Type Parameters TOverlapEnumerator Type of the enumerator to call for overlaps. GetOverlaps<TOverlapEnumerator>(Vector3, Vector3, ref TOverlapEnumerator) Finds any overlaps between a bounding box and leaf bounding boxes. public void GetOverlaps<TOverlapEnumerator>(Vector3 min, Vector3 max, ref TOverlapEnumerator overlapEnumerator) where TOverlapEnumerator : IBreakableForEach<CollidableReference> Parameters min Vector3 Minimum bounds of the query box. max Vector3 Maximum bounds of the query box. overlapEnumerator TOverlapEnumerator Enumerator to call for overlaps. Type Parameters TOverlapEnumerator Type of the enumerator to call for overlaps. GetStaticBoundsPointers(int, out Vector3*, out Vector3*) Gets pointers to the leaf's bounds stored in the broad phase's static tree. public void GetStaticBoundsPointers(int index, out Vector3* minPointer, out Vector3* maxPointer) Parameters index int Index of the static to examine. minPointer Vector3* Pointer to the minimum bounds in the tree. maxPointer Vector3* Pointer to the maximum bounds in the tree. RayCast<TRayTester>(Vector3, Vector3, float, ref TRayTester, int) Finds any intersections between a ray and leaf bounding boxes. public void RayCast<TRayTester>(Vector3 origin, Vector3 direction, float maximumT, ref TRayTester rayTester, int id = 0) where TRayTester : IBroadPhaseRayTester Parameters origin Vector3 Origin of the ray to cast. direction Vector3 Direction of the ray to cast. maximumT float Maximum length of the ray traversal in units of the direction's length. rayTester TRayTester Callback to execute on ray-leaf bounding box intersections. id int User specified id of the ray. Type Parameters TRayTester Type of the callback to execute on ray-leaf bounding box intersections. RemoveActiveAt(int, out CollidableReference) public bool RemoveActiveAt(int index, out CollidableReference movedLeaf) Parameters index int movedLeaf CollidableReference Returns bool RemoveAt(int, ref Tree, ref Buffer<CollidableReference>, out CollidableReference) public static bool RemoveAt(int index, ref Tree tree, ref Buffer<CollidableReference> leaves, out CollidableReference movedLeaf) Parameters index int tree Tree leaves Buffer<CollidableReference> movedLeaf CollidableReference Returns bool RemoveStaticAt(int, out CollidableReference) public bool RemoveStaticAt(int index, out CollidableReference movedLeaf) Parameters index int movedLeaf CollidableReference Returns bool Resize(int, int) Resizes the broad phase structures to hold the given number of leaves. Note that this is conservative; it will never orphan any existing leaves. public void Resize(int activeCapacity, int staticCapacity) Parameters activeCapacity int Number of leaves to allocate space for in the active tree. staticCapacity int Number of leaves to allocate space for in the static tree. Sweep<TSweepTester>(in BoundingBox, Vector3, float, ref TSweepTester) Finds any intersections between a swept bounding box and leaf bounding boxes. public void Sweep<TSweepTester>(in BoundingBox boundingBox, Vector3 direction, float maximumT, ref TSweepTester sweepTester) where TSweepTester : IBroadPhaseSweepTester Parameters boundingBox BoundingBox Bounding box to sweep. direction Vector3 Direction along which to sweep the bounding box. maximumT float Maximum length of the sweep in units of the direction's length. sweepTester TSweepTester Callback to execute on sweep-leaf bounding box intersections. Type Parameters TSweepTester Type of the callback to execute on sweep-leaf bounding box intersections. Sweep<TSweepTester>(Vector3, Vector3, Vector3, float, ref TSweepTester) Finds any intersections between a swept bounding box and leaf bounding boxes. public void Sweep<TSweepTester>(Vector3 min, Vector3 max, Vector3 direction, float maximumT, ref TSweepTester sweepTester) where TSweepTester : IBroadPhaseSweepTester Parameters min Vector3 Minimum bounds of the box to sweep. max Vector3 Maximum bounds of the box to sweep. direction Vector3 Direction along which to sweep the bounding box. maximumT float Maximum length of the sweep in units of the direction's length. sweepTester TSweepTester Callback to execute on sweep-leaf bounding box intersections. Type Parameters TSweepTester Type of the callback to execute on sweep-leaf bounding box intersections. Update(IThreadDispatcher) public void Update(IThreadDispatcher threadDispatcher = null) Parameters threadDispatcher IThreadDispatcher Update2(IThreadDispatcher, bool) public void Update2(IThreadDispatcher threadDispatcher = null, bool deterministic = false) Parameters threadDispatcher IThreadDispatcher deterministic bool UpdateActiveBounds(int, Vector3, Vector3) Applies updated bounds to the given active leaf index, refitting the tree to match. public void UpdateActiveBounds(int broadPhaseIndex, Vector3 min, Vector3 max) Parameters broadPhaseIndex int Index of the leaf to update. min Vector3 New minimum bounds for the leaf. max Vector3 New maximum bounds for the leaf. UpdateStaticBounds(int, Vector3, Vector3) Applies updated bounds to the given active leaf index, refitting the tree to match. public void UpdateStaticBounds(int broadPhaseIndex, Vector3 min, Vector3 max) Parameters broadPhaseIndex int Index of the leaf to update. min Vector3 New minimum bounds for the leaf. max Vector3 New maximum bounds for the leaf."
  },
  "api/BepuPhysics.CollisionDetection.BroadPhaseRayBatcher-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.BroadPhaseRayBatcher-1.html",
    "title": "Struct BroadPhaseRayBatcher<TRayTester> | Bepu API",
    "keywords": "Struct BroadPhaseRayBatcher<TRayTester> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Helps test the broad phase's active and static trees with a custom leaf tester. public struct BroadPhaseRayBatcher<TRayTester> : IDisposable where TRayTester : struct, IBroadPhaseBatchedRayTester Type Parameters TRayTester Type used to test rays against leaves. Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BroadPhaseRayBatcher(BufferPool, BroadPhase, TRayTester, int) Constructs a ray batcher for the broad phase and initializes its backing resources. public BroadPhaseRayBatcher(BufferPool pool, BroadPhase broadPhase, TRayTester rayTester, int batcherRayCapacity = 2048) Parameters pool BufferPool Pool to pull resources from. broadPhase BroadPhase Broad phase to be tested. rayTester TRayTester Ray tester used to test leaves found by the broad phase tree traversals. batcherRayCapacity int Maximum number of rays to execute in each traversal. This should typically be chosen as the highest value which avoids spilling data out of L2 cache. Methods Add(ref Vector3, ref Vector3, float, int) Adds a ray to the batcher to test against the broad phase trees. If the underlying ray batcher hits its maximum capacity, all the accumulated rays will be tested against the broad phase trees and the accumulator will be reset. public void Add(ref Vector3 origin, ref Vector3 direction, float maximumT, int id = 0) Parameters origin Vector3 Origin of the ray to test against the tree. direction Vector3 Direction of the ray to test against the tree. maximumT float Maximum distance that the ray will travel in units of the ray's length. id int Identifier value for the ray. Leaf tests will have access to the id. Dispose() Disposes the underlying batcher resources. public void Dispose() Flush() Tests any accumulated rays against the broad phase trees and then resets the batcher. public void Flush()"
  },
  "api/BepuPhysics.CollisionDetection.CCDContinuationIndex.html": {
    "href": "api/BepuPhysics.CollisionDetection.CCDContinuationIndex.html",
    "title": "Struct CCDContinuationIndex | Bepu API",
    "keywords": "Struct CCDContinuationIndex Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct CCDContinuationIndex Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CCDContinuationIndex(int) public CCDContinuationIndex(int packed) Parameters packed int CCDContinuationIndex(int, int) public CCDContinuationIndex(int type, int index) Parameters type int index int Fields Packed public uint Packed Field Value uint Properties Exists Gets whether this index actually refers to anything. The Type and Index should only be used if this is true. public bool Exists { get; } Property Value bool Index Gets the index of the continuation. public int Index { get; } Property Value int Type Gets the type index of the continuation. public int Type { get; } Property Value int Methods ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/BepuPhysics.CollisionDetection.CollidableOverlapFinder-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollidableOverlapFinder-1.html",
    "title": "Class CollidableOverlapFinder<TCallbacks> | Bepu API",
    "keywords": "Class CollidableOverlapFinder<TCallbacks> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public class CollidableOverlapFinder<TCallbacks> : CollidableOverlapFinder where TCallbacks : struct, INarrowPhaseCallbacks Type Parameters TCallbacks Inheritance object CollidableOverlapFinder CollidableOverlapFinder<TCallbacks> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CollidableOverlapFinder(NarrowPhase<TCallbacks>, BroadPhase) public CollidableOverlapFinder(NarrowPhase<TCallbacks> narrowPhase, BroadPhase broadPhase) Parameters narrowPhase NarrowPhase<TCallbacks> broadPhase BroadPhase Methods DispatchOverlaps(float, IThreadDispatcher) public override void DispatchOverlaps(float dt, IThreadDispatcher threadDispatcher = null) Parameters dt float threadDispatcher IThreadDispatcher"
  },
  "api/BepuPhysics.CollisionDetection.CollidableOverlapFinder.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollidableOverlapFinder.html",
    "title": "Class CollidableOverlapFinder | Bepu API",
    "keywords": "Class CollidableOverlapFinder Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public abstract class CollidableOverlapFinder Inheritance object CollidableOverlapFinder Derived CollidableOverlapFinder<TCallbacks> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DispatchOverlaps(float, IThreadDispatcher) public abstract void DispatchOverlaps(float dt, IThreadDispatcher threadDispatcher = null) Parameters dt float threadDispatcher IThreadDispatcher"
  },
  "api/BepuPhysics.CollisionDetection.CollidablePair.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollidablePair.html",
    "title": "Struct CollidablePair | Bepu API",
    "keywords": "Struct CollidablePair Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct CollidablePair Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CollidablePair(CollidableReference, CollidableReference) public CollidablePair(CollidableReference a, CollidableReference b) Parameters a CollidableReference b CollidableReference Fields A public CollidableReference A Field Value CollidableReference B public CollidableReference B Field Value CollidableReference Methods ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/BepuPhysics.CollisionDetection.CollidablePairComparer.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollidablePairComparer.html",
    "title": "Struct CollidablePairComparer | Bepu API",
    "keywords": "Struct CollidablePairComparer Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct CollidablePairComparer : IEqualityComparerRef<CollidablePair> Implements IEqualityComparerRef<CollidablePair> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Equals(ref CollidablePair, ref CollidablePair) public bool Equals(ref CollidablePair a, ref CollidablePair b) Parameters a CollidablePair b CollidablePair Returns bool Hash(ref CollidablePair) public int Hash(ref CollidablePair item) Parameters item CollidablePair Returns int"
  },
  "api/BepuPhysics.CollisionDetection.CollisionBatcher-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionBatcher-1.html",
    "title": "Struct CollisionBatcher<TCallbacks> | Bepu API",
    "keywords": "Struct CollisionBatcher<TCallbacks> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct CollisionBatcher<TCallbacks> where TCallbacks : struct, ICollisionCallbacks Type Parameters TCallbacks Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CollisionBatcher(BufferPool, Shapes, CollisionTaskRegistry, float, TCallbacks) public CollisionBatcher(BufferPool pool, Shapes shapes, CollisionTaskRegistry collisionTypeMatrix, float dt, TCallbacks callbacks) Parameters pool BufferPool shapes Shapes collisionTypeMatrix CollisionTaskRegistry dt float callbacks TCallbacks Fields Callbacks public TCallbacks Callbacks Field Value TCallbacks CompoundMeshReductions public BatcherContinuations<CompoundMeshReduction> CompoundMeshReductions Field Value BatcherContinuations<CompoundMeshReduction> Dt Timestep duration used by pairs which rely on velocity to compute local bounding boxes for pruning. public float Dt Field Value float MeshReductions public BatcherContinuations<MeshReduction> MeshReductions Field Value BatcherContinuations<MeshReduction> NonconvexReductions public BatcherContinuations<NonconvexReduction> NonconvexReductions Field Value BatcherContinuations<NonconvexReduction> Pool public BufferPool Pool Field Value BufferPool Shapes public Shapes Shapes Field Value Shapes Methods Add(TypedIndex, TypedIndex, Vector3, Quaternion, Quaternion, in BodyVelocity, in BodyVelocity, float, float, in PairContinuation) public void Add(TypedIndex shapeIndexA, TypedIndex shapeIndexB, Vector3 offsetB, Quaternion orientationA, Quaternion orientationB, in BodyVelocity velocityA, in BodyVelocity velocityB, float speculativeMargin, float maximumExpansion, in PairContinuation continuation) Parameters shapeIndexA TypedIndex shapeIndexB TypedIndex offsetB Vector3 orientationA Quaternion orientationB Quaternion velocityA BodyVelocity velocityB BodyVelocity speculativeMargin float maximumExpansion float continuation PairContinuation Add(TypedIndex, TypedIndex, Vector3, Quaternion, Quaternion, float, in PairContinuation) public void Add(TypedIndex shapeIndexA, TypedIndex shapeIndexB, Vector3 offsetB, Quaternion orientationA, Quaternion orientationB, float speculativeMargin, in PairContinuation continuation) Parameters shapeIndexA TypedIndex shapeIndexB TypedIndex offsetB Vector3 orientationA Quaternion orientationB Quaternion speculativeMargin float continuation PairContinuation Add(int, int, int, int, void*, void*, Vector3, Quaternion, Quaternion, float, int) public void Add(int shapeTypeA, int shapeTypeB, int shapeSizeA, int shapeSizeB, void* shapeA, void* shapeB, Vector3 offsetB, Quaternion orientationA, Quaternion orientationB, float speculativeMargin, int pairId) Parameters shapeTypeA int shapeTypeB int shapeSizeA int shapeSizeB int shapeA void* shapeB void* offsetB Vector3 orientationA Quaternion orientationB Quaternion speculativeMargin float pairId int AddDirectly(int, int, void*, void*, Vector3, Quaternion, Quaternion, in BodyVelocity, in BodyVelocity, float, float, in PairContinuation) public void AddDirectly(int shapeTypeA, int shapeTypeB, void* shapeA, void* shapeB, Vector3 offsetB, Quaternion orientationA, Quaternion orientationB, in BodyVelocity velocityA, in BodyVelocity velocityB, float speculativeMargin, float maximumExpansion, in PairContinuation pairContinuation) Parameters shapeTypeA int shapeTypeB int shapeA void* shapeB void* offsetB Vector3 orientationA Quaternion orientationB Quaternion velocityA BodyVelocity velocityB BodyVelocity speculativeMargin float maximumExpansion float pairContinuation PairContinuation AddDirectly(int, int, void*, void*, Vector3, Quaternion, Quaternion, float, in PairContinuation) public void AddDirectly(int shapeTypeA, int shapeTypeB, void* shapeA, void* shapeB, Vector3 offsetB, Quaternion orientationA, Quaternion orientationB, float speculativeMargin, in PairContinuation pairContinuation) Parameters shapeTypeA int shapeTypeB int shapeA void* shapeB void* offsetB Vector3 orientationA Quaternion orientationB Quaternion speculativeMargin float pairContinuation PairContinuation Add<TShapeA, TShapeB>(TShapeA, TShapeB, Vector3, Quaternion, Quaternion, float, int) public void Add<TShapeA, TShapeB>(TShapeA shapeA, TShapeB shapeB, Vector3 offsetB, Quaternion orientationA, Quaternion orientationB, float speculativeMargin, int pairId) where TShapeA : struct, IShape where TShapeB : struct, IShape Parameters shapeA TShapeA shapeB TShapeB offsetB Vector3 orientationA Quaternion orientationB Quaternion speculativeMargin float pairId int Type Parameters TShapeA TShapeB CacheShapeB(int, int, void*, int, out void*) public void CacheShapeB(int shapeTypeA, int shapeTypeB, void* shapeDataB, int shapeSizeB, out void* cachedShapeDataB) Parameters shapeTypeA int shapeTypeB int shapeDataB void* shapeSizeB int cachedShapeDataB void* Flush() Forces any remaining partial batches to execute and disposes the batcher. public void Flush() ProcessConvexResult(ref ConvexContactManifold, ref PairContinuation) Reports the result of a convex collision test to the callbacks and, if necessary, to any continuations for postprocessing. public void ProcessConvexResult(ref ConvexContactManifold manifold, ref PairContinuation continuation) Parameters manifold ConvexContactManifold Contacts detected for the pair. continuation PairContinuation Continuation describing the pair and what to do with it. Remarks Unless you're building custom compound collision pairs or adding new contact processing continuations, you can safely ignore this. ProcessEmptyResult(ref PairContinuation) Reports the zero result of a convex collision test to the callbacks and, if necessary, to any continuations for postprocessing. public void ProcessEmptyResult(ref PairContinuation continuation) Parameters continuation PairContinuation Continuation describing the pair and what to do with it. Remarks Unless you're building custom compound collision pairs or adding new contact processing continuations, you can safely ignore this. ProcessUntestedSubpairConvexResult(ref PairContinuation) Submits a subpair whose testing was blocked by user callback as complete to any relevant continuations. public void ProcessUntestedSubpairConvexResult(ref PairContinuation continuation) Parameters continuation PairContinuation Continuation describing the pair and what to do with it. Remarks Unless you're building custom compound collision pairs or adding new contact processing continuations, you can safely ignore this."
  },
  "api/BepuPhysics.CollisionDetection.CollisionContinuationType.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionContinuationType.html",
    "title": "Enum CollisionContinuationType | Bepu API",
    "keywords": "Enum CollisionContinuationType Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Describes the flow control to apply to a convex-convex pair report. public enum CollisionContinuationType : byte Fields CompoundMeshReduction = 3 Marks a pair as a part of a set of mesh-convex collisions spawned by a mesh-compound pair, potentially requiring mesh boundary smoothing. Direct = 0 Marks a pair as requiring no further processing before being reported to the user supplied continuations. MeshReduction = 2 Marks a pair as a part of a set of mesh-convex collisions, potentially requiring mesh boundary smoothing. NonconvexReduction = 1 Marks a pair as part of a set of a higher (potentially multi-manifold) pair, potentially requiring contact reduction."
  },
  "api/BepuPhysics.CollisionDetection.CollisionTask.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTask.html",
    "title": "Class CollisionTask | Bepu API",
    "keywords": "Class CollisionTask Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Parent type of tasks which handle collision tests between batches of shapes of a particular type. public abstract class CollisionTask Inheritance object CollisionTask Derived CompoundPairCollisionTask<TCompoundA, TCompoundB, TOverlapFinder, TContinuationHandler, TContinuation> ConvexCollisionTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide, TManifoldWide, TPairTester> ConvexCompoundCollisionTask<TConvex, TCompound, TOverlapFinder, TContinuationHandler, TContinuation> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties BatchSize Gets the number of tasks to batch together before executing this task. public int BatchSize { get; protected set; } Property Value int PairType Gets the pair type that the ExecuteBatch call requires. public CollisionTaskPairType PairType { get; protected set; } Property Value CollisionTaskPairType ShapeTypeIndexA Gets the first shape type index associated with the task. Shape pairs provided to the task for execution should be in the order defined by these type two indices. If a collision task isn't a top level shape pair task, this should be -1. public int ShapeTypeIndexA { get; protected set; } Property Value int ShapeTypeIndexB Gets the second shape type index associated with the task. Shape pairs provided to the task for execution should be in the order defined by these type two indices. If a collision task isn't a top level shape pair task, this should be -1. public int ShapeTypeIndexB { get; protected set; } Property Value int SubtaskGenerator Gets whether the task is capable of generating subtasks. Note that subtask generators cannot generate subtasks that are themselves subtask generators. public bool SubtaskGenerator { get; protected set; } Property Value bool Methods ExecuteBatch<TCallbacks>(ref UntypedList, ref CollisionBatcher<TCallbacks>) Executes the task on the given input. public abstract void ExecuteBatch<TCallbacks>(ref UntypedList batch, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters batch UntypedList Batch of pairs to test. batcher CollisionBatcher<TCallbacks> Batcher responsible for the invocation. Type Parameters TCallbacks Type of the callbacks used to handle results of collision tasks."
  },
  "api/BepuPhysics.CollisionDetection.CollisionTaskPairType.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTaskPairType.html",
    "title": "Enum CollisionTaskPairType | Bepu API",
    "keywords": "Enum CollisionTaskPairType Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Describes the data requirements for a collision pair type in a CollisionBatcher<TCallbacks>. public enum CollisionTaskPairType Fields BoundsTestedPair = 4 Pair that requires computing local bounding boxes, and so requires extra information like velocity. FliplessPair = 1 Pair specialized for convex pairs between two shapes of the same type. SphereIncludingPair = 3 Pair specialized for convex pairs that involve one sphere which requires no orientation. SpherePair = 2 Pair specialized for two spheres, requiring no flip mask or orientations. StandardPair = 0 General pair for two shapes with full pose and flip mask, but no bounds related data."
  },
  "api/BepuPhysics.CollisionDetection.CollisionTaskReference.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTaskReference.html",
    "title": "Struct CollisionTaskReference | Bepu API",
    "keywords": "Struct CollisionTaskReference Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Metadata about a collision task. public struct CollisionTaskReference Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields BatchSize Number of pairs to accumulate in a batch before dispatching tests. public int BatchSize Field Value int ExpectedFirstTypeId The type id that is expected to come first in the collision pair. public int ExpectedFirstTypeId Field Value int PairType Data requirements for the collision pair type in a CollisionBatcher<TCallbacks>. public CollisionTaskPairType PairType Field Value CollisionTaskPairType TaskIndex Index of the task in the registry. public int TaskIndex Field Value int"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTaskRegistry.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTaskRegistry.html",
    "title": "Class CollisionTaskRegistry | Bepu API",
    "keywords": "Class CollisionTaskRegistry Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Registry of collision tasks used to handle various shape pair types. public class CollisionTaskRegistry Inheritance object CollisionTaskRegistry Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CollisionTaskRegistry(int) Creates a new collision task registry. public CollisionTaskRegistry(int initialShapeCount = 9) Parameters initialShapeCount int Initial number of shape types to allocate space for in the registry. Properties this[int] Gets the collision task associated with a task index. public CollisionTask this[int taskIndex] { get; } Parameters taskIndex int Task index to look up. Property Value CollisionTask Task associated with the task index. Methods GetTaskReference(int, int) Gets metadata about the task associated with a shape type pair. public ref CollisionTaskReference GetTaskReference(int topLevelTypeA, int topLevelTypeB) Parameters topLevelTypeA int Type index of the first shape. topLevelTypeB int Type index of the second shape. Returns CollisionTaskReference Reference to the metadata for the task. GetTaskReference<TShapeA, TShapeB>() Gets metadata about the task associated with a shape type pair. public ref CollisionTaskReference GetTaskReference<TShapeA, TShapeB>() where TShapeA : unmanaged, IShape where TShapeB : unmanaged, IShape Returns CollisionTaskReference Reference to the metadata for the task. Type Parameters TShapeA Type of the first shape. TShapeB Type of the second shape. Register(CollisionTask) Registers a collision task. public int Register(CollisionTask task) Parameters task CollisionTask Task to register. Returns int Index of the task in the registry."
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.BoundsTestedPair.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.BoundsTestedPair.html",
    "title": "Struct BoundsTestedPair | Bepu API",
    "keywords": "Struct BoundsTestedPair Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll Pair of objects awaiting collision processing that involves velocities for bounds calculation. public struct BoundsTestedPair : ICollisionPair<BoundsTestedPair> Implements ICollisionPair<BoundsTestedPair> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public void* A Field Value void* AngularVelocityA public Vector3 AngularVelocityA Field Value Vector3 AngularVelocityB public Vector3 AngularVelocityB Field Value Vector3 B public void* B Field Value void* Continuation public PairContinuation Continuation Field Value PairContinuation FlipMask public int FlipMask Field Value int MaximumExpansion public float MaximumExpansion Field Value float OffsetB public Vector3 OffsetB Field Value Vector3 OrientationA public Quaternion OrientationA Field Value Quaternion OrientationB public Quaternion OrientationB Field Value Quaternion RelativeLinearVelocityA public Vector3 RelativeLinearVelocityA Field Value Vector3 SpeculativeMargin public float SpeculativeMargin Field Value float Properties PairType Gets the enumeration type associated with this pair type. public static CollisionTaskPairType PairType { get; } Property Value CollisionTaskPairType Methods GetContinuation(ref BoundsTestedPair) public static ref PairContinuation GetContinuation(ref BoundsTestedPair pair) Parameters pair BoundsTestedPair Returns PairContinuation"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.BoxConvexHullTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.BoxConvexHullTester.html",
    "title": "Struct BoxConvexHullTester | Bepu API",
    "keywords": "Struct BoxConvexHullTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct BoxConvexHullTester : IPairTester<BoxWide, ConvexHullWide, Convex4ContactManifoldWide> Implements IPairTester<BoxWide, ConvexHullWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref BoxWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref BoxWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref BoxWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.BoxCylinderTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.BoxCylinderTester.html",
    "title": "Struct BoxCylinderTester | Bepu API",
    "keywords": "Struct BoxCylinderTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct BoxCylinderTester : IPairTester<BoxWide, CylinderWide, Convex4ContactManifoldWide> Implements IPairTester<BoxWide, CylinderWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref BoxWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref BoxWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref BoxWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.BoxPairTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.BoxPairTester.html",
    "title": "Struct BoxPairTester | Bepu API",
    "keywords": "Struct BoxPairTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct BoxPairTester : IPairTester<BoxWide, BoxWide, Convex4ContactManifoldWide> Implements IPairTester<BoxWide, BoxWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref BoxWide, ref BoxWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref BoxWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b BoxWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref BoxWide, ref BoxWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref BoxWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b BoxWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref BoxWide, ref BoxWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref BoxWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b BoxWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.BoxTriangleTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.BoxTriangleTester.html",
    "title": "Struct BoxTriangleTester | Bepu API",
    "keywords": "Struct BoxTriangleTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct BoxTriangleTester : IPairTester<BoxWide, TriangleWide, Convex4ContactManifoldWide> Implements IPairTester<BoxWide, TriangleWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref BoxWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref BoxWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref BoxWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref BoxWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a BoxWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsuleBoxTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsuleBoxTester.html",
    "title": "Struct CapsuleBoxTester | Bepu API",
    "keywords": "Struct CapsuleBoxTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CapsuleBoxTester : IPairTester<CapsuleWide, BoxWide, Convex2ContactManifoldWide> Implements IPairTester<CapsuleWide, BoxWide, Convex2ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref CapsuleWide, ref BoxWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref BoxWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b BoxWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref BoxWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref BoxWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b BoxWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref BoxWide, ref Vector<float>, ref Vector3Wide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref BoxWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b BoxWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex2ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsuleConvexHullTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsuleConvexHullTester.html",
    "title": "Struct CapsuleConvexHullTester | Bepu API",
    "keywords": "Struct CapsuleConvexHullTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CapsuleConvexHullTester : IPairTester<CapsuleWide, ConvexHullWide, Convex2ContactManifoldWide> Implements IPairTester<CapsuleWide, ConvexHullWide, Convex2ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref CapsuleWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex2ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsuleCylinderTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsuleCylinderTester.html",
    "title": "Struct CapsuleCylinderTester | Bepu API",
    "keywords": "Struct CapsuleCylinderTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CapsuleCylinderTester : IPairTester<CapsuleWide, CylinderWide, Convex2ContactManifoldWide> Implements IPairTester<CapsuleWide, CylinderWide, Convex2ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods GetClosestPointBetweenLineSegmentAndCylinder(in Vector3Wide, in Vector3Wide, in Vector<float>, in CylinderWide, in Vector<int>, out Vector<float>, out Vector3Wide) public static void GetClosestPointBetweenLineSegmentAndCylinder(in Vector3Wide lineOrigin, in Vector3Wide lineDirection, in Vector<float> halfLength, in CylinderWide b, in Vector<int> inactiveLanes, out Vector<float> t, out Vector3Wide offsetFromCylinderToLineSegment) Parameters lineOrigin Vector3Wide lineDirection Vector3Wide halfLength Vector<float> b CylinderWide inactiveLanes Vector<int> t Vector<float> offsetFromCylinderToLineSegment Vector3Wide GetClosestPointsBetweenSegments(in Vector3Wide, in Vector3Wide, in Vector<float>, in Vector<float>, out Vector<float>, out Vector<float>, out Vector<float>, out Vector<float>, out Vector<float>, out Vector<float>) public static void GetClosestPointsBetweenSegments(in Vector3Wide da, in Vector3Wide localOffsetB, in Vector<float> aHalfLength, in Vector<float> bHalfLength, out Vector<float> ta, out Vector<float> taMin, out Vector<float> taMax, out Vector<float> tb, out Vector<float> tbMin, out Vector<float> tbMax) Parameters da Vector3Wide localOffsetB Vector3Wide aHalfLength Vector<float> bHalfLength Vector<float> ta Vector<float> taMin Vector<float> taMax Vector<float> tb Vector<float> tbMin Vector<float> tbMax Vector<float> GetContactIntervalBetweenSegments(in Vector<float>, in Vector<float>, in Vector3Wide, in Vector3Wide, in Vector<float>, in Vector3Wide, out Vector<float>, out Vector<float>) public static void GetContactIntervalBetweenSegments(in Vector<float> aHalfLength, in Vector<float> bHalfLength, in Vector3Wide axisA, in Vector3Wide localNormal, in Vector<float> inverseHorizontalNormalLengthSquaredB, in Vector3Wide offsetB, out Vector<float> contactTMin, out Vector<float> contactTMax) Parameters aHalfLength Vector<float> bHalfLength Vector<float> axisA Vector3Wide localNormal Vector3Wide inverseHorizontalNormalLengthSquaredB Vector<float> offsetB Vector3Wide contactTMin Vector<float> contactTMax Vector<float> Test(ref CapsuleWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex2ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsulePairTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsulePairTester.html",
    "title": "Struct CapsulePairTester | Bepu API",
    "keywords": "Struct CapsulePairTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CapsulePairTester : IPairTester<CapsuleWide, CapsuleWide, Convex2ContactManifoldWide> Implements IPairTester<CapsuleWide, CapsuleWide, Convex2ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref CapsuleWide, ref CapsuleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref CapsuleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b CapsuleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref CapsuleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref CapsuleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b CapsuleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref CapsuleWide, ref Vector<float>, ref Vector3Wide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref CapsuleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b CapsuleWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex2ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsuleTriangleTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CapsuleTriangleTester.html",
    "title": "Struct CapsuleTriangleTester | Bepu API",
    "keywords": "Struct CapsuleTriangleTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CapsuleTriangleTester : IPairTester<CapsuleWide, TriangleWide, Convex2ContactManifoldWide> Implements IPairTester<CapsuleWide, TriangleWide, Convex2ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods ClipAgainstEdgePlane(in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector3Wide, out Vector<float>, out Vector<float>) public static void ClipAgainstEdgePlane(in Vector3Wide edgeStart, in Vector3Wide edgeOffset, in Vector3Wide faceNormal, in Vector3Wide capsuleCenter, in Vector3Wide capsuleAxis, out Vector<float> entry, out Vector<float> exit) Parameters edgeStart Vector3Wide edgeOffset Vector3Wide faceNormal Vector3Wide capsuleCenter Vector3Wide capsuleAxis Vector3Wide entry Vector<float> exit Vector<float> Test(ref CapsuleWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex2ContactManifoldWide Test(ref CapsuleWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, int, out Convex2ContactManifoldWide) public static void Test(ref CapsuleWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex2ContactManifoldWide manifold) Parameters a CapsuleWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex2ContactManifoldWide TestEdge(in TriangleWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector<float>, out Vector3Wide, out Vector<float>, out Vector<float>, out Vector<float>, out Vector<float>, out Vector<float>, out Vector3Wide) public static void TestEdge(in TriangleWide triangle, in Vector3Wide triangleNormal, in Vector3Wide edgeStart, in Vector3Wide edgeOffset, in Vector3Wide capsuleCenter, in Vector3Wide capsuleAxis, in Vector<float> capsuleHalfLength, out Vector3Wide edgeDirection, out Vector<float> ta, out Vector<float> tb, out Vector<float> bMin, out Vector<float> bMax, out Vector<float> depth, out Vector3Wide normal) Parameters triangle TriangleWide triangleNormal Vector3Wide edgeStart Vector3Wide edgeOffset Vector3Wide capsuleCenter Vector3Wide capsuleAxis Vector3Wide capsuleHalfLength Vector<float> edgeDirection Vector3Wide ta Vector<float> tb Vector<float> bMin Vector<float> bMax Vector<float> depth Vector<float> normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ChildOverlapsCollection.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ChildOverlapsCollection.html",
    "title": "Struct ChildOverlapsCollection | Bepu API",
    "keywords": "Struct ChildOverlapsCollection Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ChildOverlapsCollection : ICollisionTaskSubpairOverlaps Implements ICollisionTaskSubpairOverlaps Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ChildIndex public int ChildIndex Field Value int Count public int Count Field Value int Overlaps public Buffer<int> Overlaps Field Value Buffer<int> Methods Allocate(BufferPool) public ref int Allocate(BufferPool pool) Parameters pool BufferPool Returns int Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CollisionPair.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CollisionPair.html",
    "title": "Struct CollisionPair | Bepu API",
    "keywords": "Struct CollisionPair Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CollisionPair : ICollisionPair<CollisionPair> Implements ICollisionPair<CollisionPair> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public void* A Field Value void* B public void* B Field Value void* Continuation public PairContinuation Continuation Field Value PairContinuation FlipMask Stores whether the types involved in pair require that the resulting contact manifold be flipped to be consistent with the user-requested pair order. public int FlipMask Field Value int OffsetB public Vector3 OffsetB Field Value Vector3 OrientationA public Quaternion OrientationA Field Value Quaternion OrientationB public Quaternion OrientationB Field Value Quaternion SpeculativeMargin public float SpeculativeMargin Field Value float Properties PairType Gets the enumeration type associated with this pair type. public static CollisionTaskPairType PairType { get; } Property Value CollisionTaskPairType Methods GetContinuation(ref CollisionPair) public static ref PairContinuation GetContinuation(ref CollisionPair pair) Parameters pair CollisionPair Returns PairContinuation"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundMeshContinuations-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundMeshContinuations-2.html",
    "title": "Struct CompoundMeshContinuations<TCompound, TMesh> | Bepu API",
    "keywords": "Struct CompoundMeshContinuations<TCompound, TMesh> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CompoundMeshContinuations<TCompound, TMesh> : ICompoundPairContinuationHandler<CompoundMeshReduction> where TCompound : ICompoundShape where TMesh : IHomogeneousCompoundShape<Triangle, TriangleWide> Type Parameters TCompound TMesh Implements ICompoundPairContinuationHandler<CompoundMeshReduction> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties CollisionContinuationType public CollisionContinuationType CollisionContinuationType { get; } Property Value CollisionContinuationType Methods ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref CompoundMeshReduction, int, in BoundsTestedPair, int, int, int, in RigidPose, out RigidPose, out int, out void*) public void ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref CompoundMeshReduction continuation, int continuationChildIndex, in BoundsTestedPair pair, int childIndexA, int childTypeA, int childIndexB, in RigidPose childPoseA, out RigidPose childPoseB, out int childTypeB, out void* childShapeDataB) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation CompoundMeshReduction continuationChildIndex int pair BoundsTestedPair childIndexA int childTypeA int childIndexB int childPoseA RigidPose childPoseB RigidPose childTypeB int childShapeDataB void* Type Parameters TCallbacks CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks>, int, ref Buffer<ChildOverlapsCollection>, ref Buffer<OverlapQueryForPair>, in BoundsTestedPair, out int) public ref CompoundMeshReduction CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, int totalChildCount, ref Buffer<ChildOverlapsCollection> pairOverlaps, ref Buffer<OverlapQueryForPair> pairQueries, in BoundsTestedPair pair, out int continuationIndex) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> totalChildCount int pairOverlaps Buffer<ChildOverlapsCollection> pairQueries Buffer<OverlapQueryForPair> pair BoundsTestedPair continuationIndex int Returns CompoundMeshReduction Type Parameters TCallbacks GetChildAData<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref CompoundMeshReduction, in BoundsTestedPair, int, out RigidPose, out int, out void*) public void GetChildAData<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref CompoundMeshReduction continuation, in BoundsTestedPair pair, int childIndexA, out RigidPose childPoseA, out int childTypeA, out void* childShapeDataA) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation CompoundMeshReduction pair BoundsTestedPair childIndexA int childPoseA RigidPose childTypeA int childShapeDataA void* Type Parameters TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundPairCollisionTask-5.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundPairCollisionTask-5.html",
    "title": "Class CompoundPairCollisionTask<TCompoundA, TCompoundB, TOverlapFinder, TContinuationHandler, TContinuation> | Bepu API",
    "keywords": "Class CompoundPairCollisionTask<TCompoundA, TCompoundB, TOverlapFinder, TContinuationHandler, TContinuation> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public class CompoundPairCollisionTask<TCompoundA, TCompoundB, TOverlapFinder, TContinuationHandler, TContinuation> : CollisionTask where TCompoundA : unmanaged, IShape, IBoundsQueryableCompound where TCompoundB : unmanaged, IShape, IBoundsQueryableCompound where TOverlapFinder : struct, ICompoundPairOverlapFinder where TContinuationHandler : struct, ICompoundPairContinuationHandler<TContinuation> where TContinuation : struct, ICollisionTestContinuation Type Parameters TCompoundA TCompoundB TOverlapFinder TContinuationHandler TContinuation Inheritance object CollisionTask CompoundPairCollisionTask<TCompoundA, TCompoundB, TOverlapFinder, TContinuationHandler, TContinuation> Inherited Members CollisionTask.BatchSize CollisionTask.ShapeTypeIndexA CollisionTask.ShapeTypeIndexB CollisionTask.SubtaskGenerator CollisionTask.PairType object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CompoundPairCollisionTask() public CompoundPairCollisionTask() Methods ExecuteBatch<TCallbacks>(ref UntypedList, ref CollisionBatcher<TCallbacks>) Executes the task on the given input. public override void ExecuteBatch<TCallbacks>(ref UntypedList batch, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters batch UntypedList Batch of pairs to test. batcher CollisionBatcher<TCallbacks> Batcher responsible for the invocation. Type Parameters TCallbacks Type of the callbacks used to handle results of collision tasks."
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundPairContinuations-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundPairContinuations-2.html",
    "title": "Struct CompoundPairContinuations<TCompoundA, TCompoundB> | Bepu API",
    "keywords": "Struct CompoundPairContinuations<TCompoundA, TCompoundB> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CompoundPairContinuations<TCompoundA, TCompoundB> : ICompoundPairContinuationHandler<NonconvexReduction> where TCompoundA : ICompoundShape where TCompoundB : ICompoundShape Type Parameters TCompoundA TCompoundB Implements ICompoundPairContinuationHandler<NonconvexReduction> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties CollisionContinuationType public CollisionContinuationType CollisionContinuationType { get; } Property Value CollisionContinuationType Methods ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref NonconvexReduction, int, in BoundsTestedPair, int, int, int, in RigidPose, out RigidPose, out int, out void*) public void ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref NonconvexReduction continuation, int continuationChildIndex, in BoundsTestedPair pair, int childIndexA, int childTypeA, int childIndexB, in RigidPose childPoseA, out RigidPose childPoseB, out int childTypeB, out void* childShapeDataB) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation NonconvexReduction continuationChildIndex int pair BoundsTestedPair childIndexA int childTypeA int childIndexB int childPoseA RigidPose childPoseB RigidPose childTypeB int childShapeDataB void* Type Parameters TCallbacks CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks>, int, ref Buffer<ChildOverlapsCollection>, ref Buffer<OverlapQueryForPair>, in BoundsTestedPair, out int) public ref NonconvexReduction CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, int totalChildCount, ref Buffer<ChildOverlapsCollection> pairOverlaps, ref Buffer<OverlapQueryForPair> pairQueries, in BoundsTestedPair pair, out int continuationIndex) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> totalChildCount int pairOverlaps Buffer<ChildOverlapsCollection> pairQueries Buffer<OverlapQueryForPair> pair BoundsTestedPair continuationIndex int Returns NonconvexReduction Type Parameters TCallbacks GetChildAData<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref NonconvexReduction, in BoundsTestedPair, int, out RigidPose, out int, out void*) public void GetChildAData<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref NonconvexReduction continuation, in BoundsTestedPair pair, int childIndexA, out RigidPose childPoseA, out int childTypeA, out void* childShapeDataA) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation NonconvexReduction pair BoundsTestedPair childIndexA int childPoseA RigidPose childTypeA int childShapeDataA void* Type Parameters TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundPairOverlapFinder-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundPairOverlapFinder-2.html",
    "title": "Struct CompoundPairOverlapFinder<TCompoundA, TCompoundB> | Bepu API",
    "keywords": "Struct CompoundPairOverlapFinder<TCompoundA, TCompoundB> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CompoundPairOverlapFinder<TCompoundA, TCompoundB> : ICompoundPairOverlapFinder where TCompoundA : struct, ICompoundShape where TCompoundB : struct, IBoundsQueryableCompound Type Parameters TCompoundA TCompoundB Implements ICompoundPairOverlapFinder Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods FindLocalOverlaps(ref Buffer<BoundsTestedPair>, int, BufferPool, Shapes, float, out CompoundPairOverlaps) public static void FindLocalOverlaps(ref Buffer<BoundsTestedPair> pairs, int pairCount, BufferPool pool, Shapes shapes, float dt, out CompoundPairOverlaps overlaps) Parameters pairs Buffer<BoundsTestedPair> pairCount int pool BufferPool shapes Shapes dt float overlaps CompoundPairOverlaps"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundPairOverlaps.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CompoundPairOverlaps.html",
    "title": "Struct CompoundPairOverlaps | Bepu API",
    "keywords": "Struct CompoundPairOverlaps Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CompoundPairOverlaps : ICollisionTaskOverlaps<ChildOverlapsCollection> Implements ICollisionTaskOverlaps<ChildOverlapsCollection> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CompoundPairOverlaps(BufferPool, int, int) public CompoundPairOverlaps(BufferPool pool, int pairCapacity, int subpairCapacity) Parameters pool BufferPool pairCapacity int subpairCapacity int Methods CreatePairOverlaps(int) public void CreatePairOverlaps(int childrenInPair) Parameters childrenInPair int Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool GetOverlapsForPair(int) public ref ChildOverlapsCollection GetOverlapsForPair(int subpairIndex) Parameters subpairIndex int Returns ChildOverlapsCollection GetPairOverlaps(int, out Buffer<ChildOverlapsCollection>, out Buffer<OverlapQueryForPair>) public void GetPairOverlaps(int pairIndex, out Buffer<ChildOverlapsCollection> pairOverlaps, out Buffer<OverlapQueryForPair> pairQueries) Parameters pairIndex int pairOverlaps Buffer<ChildOverlapsCollection> pairQueries Buffer<OverlapQueryForPair>"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCollisionTask-8.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCollisionTask-8.html",
    "title": "Class ConvexCollisionTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide, TManifoldWide, TPairTester> | Bepu API",
    "keywords": "Class ConvexCollisionTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide, TManifoldWide, TPairTester> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public class ConvexCollisionTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide, TManifoldWide, TPairTester> : CollisionTask where TShapeA : unmanaged, IShape where TShapeWideA : unmanaged, IShapeWide<TShapeA> where TShapeB : unmanaged, IShape where TShapeWideB : unmanaged, IShapeWide<TShapeB> where TPair : unmanaged, ICollisionPair<TPair> where TPairWide : unmanaged, ICollisionPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide> where TManifoldWide : unmanaged, IContactManifoldWide where TPairTester : struct, IPairTester<TShapeWideA, TShapeWideB, TManifoldWide> Type Parameters TShapeA TShapeWideA TShapeB TShapeWideB TPair TPairWide TManifoldWide TPairTester Inheritance object CollisionTask ConvexCollisionTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide, TManifoldWide, TPairTester> Inherited Members CollisionTask.BatchSize CollisionTask.ShapeTypeIndexA CollisionTask.ShapeTypeIndexB CollisionTask.SubtaskGenerator CollisionTask.PairType object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConvexCollisionTask() public ConvexCollisionTask() Methods ExecuteBatch<TCallbacks>(ref UntypedList, ref CollisionBatcher<TCallbacks>) Executes the task on the given input. public override void ExecuteBatch<TCallbacks>(ref UntypedList batch, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters batch UntypedList Batch of pairs to test. batcher CollisionBatcher<TCallbacks> Batcher responsible for the invocation. Type Parameters TCallbacks Type of the callbacks used to handle results of collision tasks."
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundCollisionTask-5.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundCollisionTask-5.html",
    "title": "Class ConvexCompoundCollisionTask<TConvex, TCompound, TOverlapFinder, TContinuationHandler, TContinuation> | Bepu API",
    "keywords": "Class ConvexCompoundCollisionTask<TConvex, TCompound, TOverlapFinder, TContinuationHandler, TContinuation> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public class ConvexCompoundCollisionTask<TConvex, TCompound, TOverlapFinder, TContinuationHandler, TContinuation> : CollisionTask where TConvex : unmanaged, IConvexShape where TCompound : unmanaged, IShape, IBoundsQueryableCompound where TOverlapFinder : struct, IConvexCompoundOverlapFinder where TContinuationHandler : struct, IConvexCompoundContinuationHandler<TContinuation> where TContinuation : struct, ICollisionTestContinuation Type Parameters TConvex TCompound TOverlapFinder TContinuationHandler TContinuation Inheritance object CollisionTask ConvexCompoundCollisionTask<TConvex, TCompound, TOverlapFinder, TContinuationHandler, TContinuation> Inherited Members CollisionTask.BatchSize CollisionTask.ShapeTypeIndexA CollisionTask.ShapeTypeIndexB CollisionTask.SubtaskGenerator CollisionTask.PairType object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConvexCompoundCollisionTask() public ConvexCompoundCollisionTask() Methods ExecuteBatch<TCallbacks>(ref UntypedList, ref CollisionBatcher<TCallbacks>) Executes the task on the given input. public override void ExecuteBatch<TCallbacks>(ref UntypedList batch, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters batch UntypedList Batch of pairs to test. batcher CollisionBatcher<TCallbacks> Batcher responsible for the invocation. Type Parameters TCallbacks Type of the callbacks used to handle results of collision tasks."
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundContinuations-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundContinuations-1.html",
    "title": "Struct ConvexCompoundContinuations<TCompound> | Bepu API",
    "keywords": "Struct ConvexCompoundContinuations<TCompound> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ConvexCompoundContinuations<TCompound> : IConvexCompoundContinuationHandler<NonconvexReduction> where TCompound : ICompoundShape Type Parameters TCompound Implements IConvexCompoundContinuationHandler<NonconvexReduction> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties CollisionContinuationType public CollisionContinuationType CollisionContinuationType { get; } Property Value CollisionContinuationType Methods ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref NonconvexReduction, int, in BoundsTestedPair, int, int, out RigidPose, out int, out void*) public void ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref NonconvexReduction continuation, int continuationChildIndex, in BoundsTestedPair pair, int shapeTypeA, int childIndex, out RigidPose childPoseB, out int childTypeB, out void* childShapeDataB) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation NonconvexReduction continuationChildIndex int pair BoundsTestedPair shapeTypeA int childIndex int childPoseB RigidPose childTypeB int childShapeDataB void* Type Parameters TCallbacks CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks>, int, in BoundsTestedPair, in OverlapQueryForPair, out int) public ref NonconvexReduction CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, int childCount, in BoundsTestedPair pair, in OverlapQueryForPair pairQuery, out int continuationIndex) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> childCount int pair BoundsTestedPair pairQuery OverlapQueryForPair continuationIndex int Returns NonconvexReduction Type Parameters TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundOverlapFinder-3.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundOverlapFinder-3.html",
    "title": "Struct ConvexCompoundOverlapFinder<TConvex, TConvexWide, TCompound> | Bepu API",
    "keywords": "Struct ConvexCompoundOverlapFinder<TConvex, TConvexWide, TCompound> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ConvexCompoundOverlapFinder<TConvex, TConvexWide, TCompound> : IConvexCompoundOverlapFinder where TConvex : struct, IConvexShape where TConvexWide : struct, IShapeWide<TConvex> where TCompound : struct, IBoundsQueryableCompound Type Parameters TConvex TConvexWide TCompound Implements IConvexCompoundOverlapFinder Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods FindLocalOverlaps(ref Buffer<BoundsTestedPair>, int, BufferPool, Shapes, float, out ConvexCompoundTaskOverlaps) public void FindLocalOverlaps(ref Buffer<BoundsTestedPair> pairs, int pairCount, BufferPool pool, Shapes shapes, float dt, out ConvexCompoundTaskOverlaps overlaps) Parameters pairs Buffer<BoundsTestedPair> pairCount int pool BufferPool shapes Shapes dt float overlaps ConvexCompoundTaskOverlaps"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundOverlaps.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundOverlaps.html",
    "title": "Struct ConvexCompoundOverlaps | Bepu API",
    "keywords": "Struct ConvexCompoundOverlaps Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ConvexCompoundOverlaps : ICollisionTaskSubpairOverlaps Implements ICollisionTaskSubpairOverlaps Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Count public int Count Field Value int Overlaps public Buffer<int> Overlaps Field Value Buffer<int> Methods Allocate(BufferPool) public ref int Allocate(BufferPool pool) Parameters pool BufferPool Returns int Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundTaskOverlaps.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexCompoundTaskOverlaps.html",
    "title": "Struct ConvexCompoundTaskOverlaps | Bepu API",
    "keywords": "Struct ConvexCompoundTaskOverlaps Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ConvexCompoundTaskOverlaps : ICollisionTaskOverlaps<ConvexCompoundOverlaps> Implements ICollisionTaskOverlaps<ConvexCompoundOverlaps> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ConvexCompoundTaskOverlaps(BufferPool, int) public ConvexCompoundTaskOverlaps(BufferPool pool, int pairCount) Parameters pool BufferPool pairCount int Methods Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool GetOverlapsForPair(int) public ref ConvexCompoundOverlaps GetOverlapsForPair(int pairIndex) Parameters pairIndex int Returns ConvexCompoundOverlaps GetQueryForPair(int) public ref OverlapQueryForPair GetQueryForPair(int pairIndex) Parameters pairIndex int Returns OverlapQueryForPair"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexHullPairTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexHullPairTester.html",
    "title": "Struct ConvexHullPairTester | Bepu API",
    "keywords": "Struct ConvexHullPairTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ConvexHullPairTester : IPairTester<ConvexHullWide, ConvexHullWide, Convex4ContactManifoldWide> Implements IPairTester<ConvexHullWide, ConvexHullWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref ConvexHullWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref ConvexHullWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a ConvexHullWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref ConvexHullWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref ConvexHullWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a ConvexHullWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref ConvexHullWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref ConvexHullWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a ConvexHullWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexHullTestHelper.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexHullTestHelper.html",
    "title": "Class ConvexHullTestHelper | Bepu API",
    "keywords": "Class ConvexHullTestHelper Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public static class ConvexHullTestHelper Inheritance object ConvexHullTestHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods PickRepresentativeFace(ref ConvexHull, int, ref Vector3Wide, in Vector3Wide, in Vector<int>, ref Vector<float>, out Vector3, out Vector3, out int) public static void PickRepresentativeFace(ref ConvexHull hull, int slotIndex, ref Vector3Wide localNormal, in Vector3Wide closestOnHull, in Vector<int> slotOffsetIndices, ref Vector<float> boundingPlaneEpsilon, out Vector3 slotFaceNormal, out Vector3 slotLocalNormal, out int bestFaceIndex) Parameters hull ConvexHull slotIndex int localNormal Vector3Wide closestOnHull Vector3Wide slotOffsetIndices Vector<int> boundingPlaneEpsilon Vector<float> slotFaceNormal Vector3 slotLocalNormal Vector3 bestFaceIndex int"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexMeshContinuations-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexMeshContinuations-1.html",
    "title": "Struct ConvexMeshContinuations<TMesh> | Bepu API",
    "keywords": "Struct ConvexMeshContinuations<TMesh> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ConvexMeshContinuations<TMesh> : IConvexCompoundContinuationHandler<MeshReduction> where TMesh : IHomogeneousCompoundShape<Triangle, TriangleWide> Type Parameters TMesh Implements IConvexCompoundContinuationHandler<MeshReduction> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties CollisionContinuationType public CollisionContinuationType CollisionContinuationType { get; } Property Value CollisionContinuationType Methods ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref MeshReduction, int, in BoundsTestedPair, int, int, out RigidPose, out int, out void*) public void ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref MeshReduction continuation, int continuationChildIndex, in BoundsTestedPair pair, int shapeTypeA, int childIndex, out RigidPose childPoseB, out int childTypeB, out void* childShapeDataB) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation MeshReduction continuationChildIndex int pair BoundsTestedPair shapeTypeA int childIndex int childPoseB RigidPose childTypeB int childShapeDataB void* Type Parameters TCallbacks CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks>, int, in BoundsTestedPair, in OverlapQueryForPair, out int) public ref MeshReduction CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, int childCount, in BoundsTestedPair pair, in OverlapQueryForPair pairQuery, out int continuationIndex) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> childCount int pair BoundsTestedPair pairQuery OverlapQueryForPair continuationIndex int Returns MeshReduction Type Parameters TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexPairWide-4.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ConvexPairWide-4.html",
    "title": "Struct ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> | Bepu API",
    "keywords": "Struct ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> : ICollisionPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB, CollisionPair, ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB>> where TShapeA : struct, IConvexShape where TShapeWideA : struct, IShapeWide<TShapeA> where TShapeB : struct, IConvexShape where TShapeWideB : struct, IShapeWide<TShapeB> Type Parameters TShapeA TShapeWideA TShapeB TShapeWideB Implements ICollisionPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB, CollisionPair, ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public TShapeWideA A Field Value TShapeWideA B public TShapeWideB B Field Value TShapeWideB FlipMask public Vector<int> FlipMask Field Value Vector<int> OffsetB public Vector3Wide OffsetB Field Value Vector3Wide OrientationA public QuaternionWide OrientationA Field Value QuaternionWide OrientationB public QuaternionWide OrientationB Field Value QuaternionWide SpeculativeMargin public Vector<float> SpeculativeMargin Field Value Vector<float> Properties HasFlipMask public static bool HasFlipMask { get; } Property Value bool OrientationCount public static int OrientationCount { get; } Property Value int Methods GetFlipMask(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB>) public static ref Vector<int> GetFlipMask(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> pair) Parameters pair ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> Returns Vector<int> GetOffsetB(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB>) public static ref Vector3Wide GetOffsetB(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> pair) Parameters pair ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> Returns Vector3Wide GetOrientationA(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB>) public static ref QuaternionWide GetOrientationA(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> pair) Parameters pair ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> Returns QuaternionWide GetOrientationB(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB>) public static ref QuaternionWide GetOrientationB(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> pair) Parameters pair ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> Returns QuaternionWide GetShapeA(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB>) public static ref TShapeWideA GetShapeA(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> pair) Parameters pair ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> Returns TShapeWideA GetShapeB(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB>) public static ref TShapeWideB GetShapeB(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> pair) Parameters pair ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> Returns TShapeWideB GetSpeculativeMargin(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB>) public static ref Vector<float> GetSpeculativeMargin(ref ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> pair) Parameters pair ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> Returns Vector<float> WriteSlot(int, in CollisionPair) public void WriteSlot(int index, in CollisionPair source) Parameters index int source CollisionPair"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CylinderConvexHullTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CylinderConvexHullTester.html",
    "title": "Struct CylinderConvexHullTester | Bepu API",
    "keywords": "Struct CylinderConvexHullTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CylinderConvexHullTester : IPairTester<CylinderWide, ConvexHullWide, Convex4ContactManifoldWide> Implements IPairTester<CylinderWide, ConvexHullWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref CylinderWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref CylinderWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a CylinderWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref CylinderWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref CylinderWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a CylinderWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref CylinderWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref CylinderWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a CylinderWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.CylinderPairTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.CylinderPairTester.html",
    "title": "Struct CylinderPairTester | Bepu API",
    "keywords": "Struct CylinderPairTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct CylinderPairTester : IPairTester<CylinderWide, CylinderWide, Convex4ContactManifoldWide> Implements IPairTester<CylinderWide, CylinderWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref CylinderWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref CylinderWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a CylinderWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref CylinderWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref CylinderWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a CylinderWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref CylinderWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref CylinderWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a CylinderWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.FliplessPair.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.FliplessPair.html",
    "title": "Struct FliplessPair | Bepu API",
    "keywords": "Struct FliplessPair Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct FliplessPair : ICollisionPair<FliplessPair> Implements ICollisionPair<FliplessPair> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public void* A Field Value void* B public void* B Field Value void* Continuation public PairContinuation Continuation Field Value PairContinuation OffsetB public Vector3 OffsetB Field Value Vector3 OrientationA public Quaternion OrientationA Field Value Quaternion OrientationB public Quaternion OrientationB Field Value Quaternion SpeculativeMargin public float SpeculativeMargin Field Value float Properties PairType Gets the enumeration type associated with this pair type. public static CollisionTaskPairType PairType { get; } Property Value CollisionTaskPairType Methods GetContinuation(ref FliplessPair) public static ref PairContinuation GetContinuation(ref FliplessPair pair) Parameters pair FliplessPair Returns PairContinuation"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.FliplessPairWide-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.FliplessPairWide-2.html",
    "title": "Struct FliplessPairWide<TShape, TShapeWide> | Bepu API",
    "keywords": "Struct FliplessPairWide<TShape, TShapeWide> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct FliplessPairWide<TShape, TShapeWide> : ICollisionPairWide<TShape, TShapeWide, TShape, TShapeWide, FliplessPair, FliplessPairWide<TShape, TShapeWide>> where TShape : struct, IConvexShape where TShapeWide : struct, IShapeWide<TShape> Type Parameters TShape TShapeWide Implements ICollisionPairWide<TShape, TShapeWide, TShape, TShapeWide, FliplessPair, FliplessPairWide<TShape, TShapeWide>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public TShapeWide A Field Value TShapeWide B public TShapeWide B Field Value TShapeWide OffsetB public Vector3Wide OffsetB Field Value Vector3Wide OrientationA public QuaternionWide OrientationA Field Value QuaternionWide OrientationB public QuaternionWide OrientationB Field Value QuaternionWide SpeculativeMargin public Vector<float> SpeculativeMargin Field Value Vector<float> Properties HasFlipMask public static bool HasFlipMask { get; } Property Value bool OrientationCount public static int OrientationCount { get; } Property Value int Methods GetFlipMask(ref FliplessPairWide<TShape, TShapeWide>) public static ref Vector<int> GetFlipMask(ref FliplessPairWide<TShape, TShapeWide> pair) Parameters pair FliplessPairWide<TShape, TShapeWide> Returns Vector<int> GetOffsetB(ref FliplessPairWide<TShape, TShapeWide>) public static ref Vector3Wide GetOffsetB(ref FliplessPairWide<TShape, TShapeWide> pair) Parameters pair FliplessPairWide<TShape, TShapeWide> Returns Vector3Wide GetOrientationA(ref FliplessPairWide<TShape, TShapeWide>) public static ref QuaternionWide GetOrientationA(ref FliplessPairWide<TShape, TShapeWide> pair) Parameters pair FliplessPairWide<TShape, TShapeWide> Returns QuaternionWide GetOrientationB(ref FliplessPairWide<TShape, TShapeWide>) public static ref QuaternionWide GetOrientationB(ref FliplessPairWide<TShape, TShapeWide> pair) Parameters pair FliplessPairWide<TShape, TShapeWide> Returns QuaternionWide GetShapeA(ref FliplessPairWide<TShape, TShapeWide>) public static ref TShapeWide GetShapeA(ref FliplessPairWide<TShape, TShapeWide> pair) Parameters pair FliplessPairWide<TShape, TShapeWide> Returns TShapeWide GetShapeB(ref FliplessPairWide<TShape, TShapeWide>) public static ref TShapeWide GetShapeB(ref FliplessPairWide<TShape, TShapeWide> pair) Parameters pair FliplessPairWide<TShape, TShapeWide> Returns TShapeWide GetSpeculativeMargin(ref FliplessPairWide<TShape, TShapeWide>) public static ref Vector<float> GetSpeculativeMargin(ref FliplessPairWide<TShape, TShapeWide> pair) Parameters pair FliplessPairWide<TShape, TShapeWide> Returns Vector<float> WriteSlot(int, in FliplessPair) public void WriteSlot(int index, in FliplessPair source) Parameters index int source FliplessPair"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.IBoundsQueryableCompound.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.IBoundsQueryableCompound.html",
    "title": "Interface IBoundsQueryableCompound | Bepu API",
    "keywords": "Interface IBoundsQueryableCompound Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface IBoundsQueryableCompound Methods FindLocalOverlaps<TOverlaps>(Vector3, Vector3, Vector3, float, BufferPool, Shapes, void*) void FindLocalOverlaps<TOverlaps>(Vector3 min, Vector3 max, Vector3 sweep, float maximumT, BufferPool pool, Shapes shapes, void* overlaps) where TOverlaps : ICollisionTaskSubpairOverlaps Parameters min Vector3 max Vector3 sweep Vector3 maximumT float pool BufferPool shapes Shapes overlaps void* Type Parameters TOverlaps FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair>, BufferPool, Shapes, ref TOverlaps) void FindLocalOverlaps<TOverlaps, TSubpairOverlaps>(ref Buffer<OverlapQueryForPair> pairs, BufferPool pool, Shapes shapes, ref TOverlaps overlaps) where TOverlaps : struct, ICollisionTaskOverlaps<TSubpairOverlaps> where TSubpairOverlaps : struct, ICollisionTaskSubpairOverlaps Parameters pairs Buffer<OverlapQueryForPair> pool BufferPool shapes Shapes overlaps TOverlaps Type Parameters TOverlaps TSubpairOverlaps"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ICollisionPair-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ICollisionPair-1.html",
    "title": "Interface ICollisionPair<TPair> | Bepu API",
    "keywords": "Interface ICollisionPair<TPair> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll Defines a type that holds scalar data for the collision batcher. public interface ICollisionPair<TPair> where TPair : ICollisionPair<TPair> Type Parameters TPair Properties PairType Gets the enumeration type associated with this pair type. public static abstract CollisionTaskPairType PairType { get; } Property Value CollisionTaskPairType Methods GetContinuation(ref TPair) public static abstract ref PairContinuation GetContinuation(ref TPair pair) Parameters pair TPair Returns PairContinuation"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ICollisionPairWide-6.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ICollisionPairWide-6.html",
    "title": "Interface ICollisionPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide> | Bepu API",
    "keywords": "Interface ICollisionPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface ICollisionPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide> where TShapeA : struct, IShape where TShapeWideA : struct, IShapeWide<TShapeA> where TShapeB : struct, IShape where TShapeWideB : struct, IShapeWide<TShapeB> Type Parameters TShapeA TShapeWideA TShapeB TShapeWideB TPair TPairWide Properties HasFlipMask public static abstract bool HasFlipMask { get; } Property Value bool OrientationCount public static abstract int OrientationCount { get; } Property Value int Methods GetFlipMask(ref TPairWide) public static abstract ref Vector<int> GetFlipMask(ref TPairWide pair) Parameters pair TPairWide Returns Vector<int> GetOffsetB(ref TPairWide) public static abstract ref Vector3Wide GetOffsetB(ref TPairWide pair) Parameters pair TPairWide Returns Vector3Wide GetOrientationA(ref TPairWide) public static abstract ref QuaternionWide GetOrientationA(ref TPairWide pair) Parameters pair TPairWide Returns QuaternionWide GetOrientationB(ref TPairWide) public static abstract ref QuaternionWide GetOrientationB(ref TPairWide pair) Parameters pair TPairWide Returns QuaternionWide GetShapeA(ref TPairWide) public static abstract ref TShapeWideA GetShapeA(ref TPairWide pair) Parameters pair TPairWide Returns TShapeWideA GetShapeB(ref TPairWide) public static abstract ref TShapeWideB GetShapeB(ref TPairWide pair) Parameters pair TPairWide Returns TShapeWideB GetSpeculativeMargin(ref TPairWide) public static abstract ref Vector<float> GetSpeculativeMargin(ref TPairWide pair) Parameters pair TPairWide Returns Vector<float> WriteSlot(int, in TPair) void WriteSlot(int index, in TPair source) Parameters index int source TPair"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ICollisionTaskOverlaps-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ICollisionTaskOverlaps-1.html",
    "title": "Interface ICollisionTaskOverlaps<TSubpairOverlaps> | Bepu API",
    "keywords": "Interface ICollisionTaskOverlaps<TSubpairOverlaps> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface ICollisionTaskOverlaps<TSubpairOverlaps> where TSubpairOverlaps : struct, ICollisionTaskSubpairOverlaps Type Parameters TSubpairOverlaps Methods GetOverlapsForPair(int) ref TSubpairOverlaps GetOverlapsForPair(int subpairIndex) Parameters subpairIndex int Returns TSubpairOverlaps"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ICollisionTaskSubpairOverlaps.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ICollisionTaskSubpairOverlaps.html",
    "title": "Interface ICollisionTaskSubpairOverlaps | Bepu API",
    "keywords": "Interface ICollisionTaskSubpairOverlaps Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface ICollisionTaskSubpairOverlaps Methods Allocate(BufferPool) ref int Allocate(BufferPool pool) Parameters pool BufferPool Returns int"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ICompoundPairContinuationHandler-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ICompoundPairContinuationHandler-1.html",
    "title": "Interface ICompoundPairContinuationHandler<TContinuation> | Bepu API",
    "keywords": "Interface ICompoundPairContinuationHandler<TContinuation> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface ICompoundPairContinuationHandler<TContinuation> where TContinuation : struct, ICollisionTestContinuation Type Parameters TContinuation Properties CollisionContinuationType CollisionContinuationType CollisionContinuationType { get; } Property Value CollisionContinuationType Methods ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref TContinuation, int, in BoundsTestedPair, int, int, int, in RigidPose, out RigidPose, out int, out void*) void ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref TContinuation continuation, int continuationChildIndex, in BoundsTestedPair pair, int childIndexA, int childTypeA, int childIndexB, in RigidPose childPoseA, out RigidPose childPoseB, out int childTypeB, out void* childShapeDataB) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation TContinuation continuationChildIndex int pair BoundsTestedPair childIndexA int childTypeA int childIndexB int childPoseA RigidPose childPoseB RigidPose childTypeB int childShapeDataB void* Type Parameters TCallbacks CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks>, int, ref Buffer<ChildOverlapsCollection>, ref Buffer<OverlapQueryForPair>, in BoundsTestedPair, out int) ref TContinuation CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, int childCount, ref Buffer<ChildOverlapsCollection> pairOverlaps, ref Buffer<OverlapQueryForPair> pairQueries, in BoundsTestedPair pair, out int continuationIndex) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> childCount int pairOverlaps Buffer<ChildOverlapsCollection> pairQueries Buffer<OverlapQueryForPair> pair BoundsTestedPair continuationIndex int Returns TContinuation Type Parameters TCallbacks GetChildAData<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref TContinuation, in BoundsTestedPair, int, out RigidPose, out int, out void*) void GetChildAData<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref TContinuation continuation, in BoundsTestedPair pair, int childIndexA, out RigidPose childPoseA, out int childTypeA, out void* childShapeDataA) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation TContinuation pair BoundsTestedPair childIndexA int childPoseA RigidPose childTypeA int childShapeDataA void* Type Parameters TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ICompoundPairOverlapFinder.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ICompoundPairOverlapFinder.html",
    "title": "Interface ICompoundPairOverlapFinder | Bepu API",
    "keywords": "Interface ICompoundPairOverlapFinder Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface ICompoundPairOverlapFinder Methods FindLocalOverlaps(ref Buffer<BoundsTestedPair>, int, BufferPool, Shapes, float, out CompoundPairOverlaps) public static abstract void FindLocalOverlaps(ref Buffer<BoundsTestedPair> pairs, int pairCount, BufferPool pool, Shapes shapes, float dt, out CompoundPairOverlaps overlaps) Parameters pairs Buffer<BoundsTestedPair> pairCount int pool BufferPool shapes Shapes dt float overlaps CompoundPairOverlaps"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.IContactManifoldWide.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.IContactManifoldWide.html",
    "title": "Interface IContactManifoldWide | Bepu API",
    "keywords": "Interface IContactManifoldWide Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface IContactManifoldWide Methods ApplyFlipMask(ref Vector3Wide, in Vector<int>) void ApplyFlipMask(ref Vector3Wide offsetB, in Vector<int> flipMask) Parameters offsetB Vector3Wide flipMask Vector<int> ReadFirst(in Vector3Wide, ref ConvexContactManifold) void ReadFirst(in Vector3Wide offsetB, ref ConvexContactManifold target) Parameters offsetB Vector3Wide target ConvexContactManifold"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.IConvexCompoundContinuationHandler-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.IConvexCompoundContinuationHandler-1.html",
    "title": "Interface IConvexCompoundContinuationHandler<TContinuation> | Bepu API",
    "keywords": "Interface IConvexCompoundContinuationHandler<TContinuation> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface IConvexCompoundContinuationHandler<TContinuation> where TContinuation : struct, ICollisionTestContinuation Type Parameters TContinuation Properties CollisionContinuationType CollisionContinuationType CollisionContinuationType { get; } Property Value CollisionContinuationType Methods ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref TContinuation, int, in BoundsTestedPair, int, int, out RigidPose, out int, out void*) void ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref TContinuation continuation, int continuationChildIndex, in BoundsTestedPair pair, int shapeTypeA, int childIndex, out RigidPose childPoseB, out int childTypeB, out void* childShapeDataB) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation TContinuation continuationChildIndex int pair BoundsTestedPair shapeTypeA int childIndex int childPoseB RigidPose childTypeB int childShapeDataB void* Type Parameters TCallbacks CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks>, int, in BoundsTestedPair, in OverlapQueryForPair, out int) ref TContinuation CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, int childCount, in BoundsTestedPair pair, in OverlapQueryForPair queryForPair, out int continuationIndex) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> childCount int pair BoundsTestedPair queryForPair OverlapQueryForPair continuationIndex int Returns TContinuation Type Parameters TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.IConvexCompoundOverlapFinder.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.IConvexCompoundOverlapFinder.html",
    "title": "Interface IConvexCompoundOverlapFinder | Bepu API",
    "keywords": "Interface IConvexCompoundOverlapFinder Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface IConvexCompoundOverlapFinder Methods FindLocalOverlaps(ref Buffer<BoundsTestedPair>, int, BufferPool, Shapes, float, out ConvexCompoundTaskOverlaps) void FindLocalOverlaps(ref Buffer<BoundsTestedPair> pairs, int pairCount, BufferPool pool, Shapes shapes, float dt, out ConvexCompoundTaskOverlaps overlaps) Parameters pairs Buffer<BoundsTestedPair> pairCount int pool BufferPool shapes Shapes dt float overlaps ConvexCompoundTaskOverlaps"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.IPairTester-3.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.IPairTester-3.html",
    "title": "Interface IPairTester<TShapeWideA, TShapeWideB, TManifoldWideType> | Bepu API",
    "keywords": "Interface IPairTester<TShapeWideA, TShapeWideB, TManifoldWideType> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public interface IPairTester<TShapeWideA, TShapeWideB, TManifoldWideType> Type Parameters TShapeWideA TShapeWideB TManifoldWideType Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static abstract int BatchSize { get; } Property Value int Methods Test(ref TShapeWideA, ref TShapeWideB, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out TManifoldWideType) public static abstract void Test(ref TShapeWideA a, ref TShapeWideB b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out TManifoldWideType manifold) Parameters a TShapeWideA b TShapeWideB speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold TManifoldWideType Test(ref TShapeWideA, ref TShapeWideB, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out TManifoldWideType) public static abstract void Test(ref TShapeWideA a, ref TShapeWideB b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out TManifoldWideType manifold) Parameters a TShapeWideA b TShapeWideB speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold TManifoldWideType Test(ref TShapeWideA, ref TShapeWideB, ref Vector<float>, ref Vector3Wide, int, out TManifoldWideType) public static abstract void Test(ref TShapeWideA a, ref TShapeWideB b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out TManifoldWideType manifold) Parameters a TShapeWideA b TShapeWideB speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold TManifoldWideType"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ManifoldCandidate.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ManifoldCandidate.html",
    "title": "Struct ManifoldCandidate | Bepu API",
    "keywords": "Struct ManifoldCandidate Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ManifoldCandidate Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Depth public Vector<float> Depth Field Value Vector<float> FeatureId public Vector<int> FeatureId Field Value Vector<int> X public Vector<float> X Field Value Vector<float> Y public Vector<float> Y Field Value Vector<float>"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ManifoldCandidateHelper.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ManifoldCandidateHelper.html",
    "title": "Class ManifoldCandidateHelper | Bepu API",
    "keywords": "Class ManifoldCandidateHelper Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public static class ManifoldCandidateHelper Inheritance object ManifoldCandidateHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddCandidate(ref ManifoldCandidate, ref Vector<int>, in ManifoldCandidate, in Vector<int>, int) public static void AddCandidate(ref ManifoldCandidate candidates, ref Vector<int> count, in ManifoldCandidate candidate, in Vector<int> newContactExists, int pairCount) Parameters candidates ManifoldCandidate count Vector<int> candidate ManifoldCandidate newContactExists Vector<int> pairCount int AddCandidateWithDepth(ref ManifoldCandidate, ref Vector<int>, in ManifoldCandidate, in Vector<int>, int) public static void AddCandidateWithDepth(ref ManifoldCandidate candidates, ref Vector<int> count, in ManifoldCandidate candidate, in Vector<int> newContactExists, int pairCount) Parameters candidates ManifoldCandidate count Vector<int> candidate ManifoldCandidate newContactExists Vector<int> pairCount int Reduce(ref ManifoldCandidate, Vector<int>, int, in Vector3Wide, Vector<float>, in Vector3Wide, in Vector3Wide, in Vector3Wide, Vector<float>, Vector<float>, int, out ManifoldCandidate, out ManifoldCandidate, out ManifoldCandidate, out ManifoldCandidate, out Vector<int>, out Vector<int>, out Vector<int>, out Vector<int>) public static void Reduce(ref ManifoldCandidate candidates, Vector<int> rawContactCount, int maxCandidateCount, in Vector3Wide faceNormalA, Vector<float> inverseFaceNormalDotNormal, in Vector3Wide faceCenterBToFaceCenterA, in Vector3Wide tangentBX, in Vector3Wide tangentBY, Vector<float> epsilonScale, Vector<float> minimumDepth, int pairCount, out ManifoldCandidate contact0, out ManifoldCandidate contact1, out ManifoldCandidate contact2, out ManifoldCandidate contact3, out Vector<int> contact0Exists, out Vector<int> contact1Exists, out Vector<int> contact2Exists, out Vector<int> contact3Exists) Parameters candidates ManifoldCandidate rawContactCount Vector<int> maxCandidateCount int faceNormalA Vector3Wide inverseFaceNormalDotNormal Vector<float> faceCenterBToFaceCenterA Vector3Wide tangentBX Vector3Wide tangentBY Vector3Wide epsilonScale Vector<float> minimumDepth Vector<float> pairCount int contact0 ManifoldCandidate contact1 ManifoldCandidate contact2 ManifoldCandidate contact3 ManifoldCandidate contact0Exists Vector<int> contact1Exists Vector<int> contact2Exists Vector<int> contact3Exists Vector<int> Reduce(ManifoldCandidateScalar*, int, Vector3, float, Vector3, Vector3, Vector3, Vector3, float, float, in Matrix3x3, Vector3, int, ref Convex4ContactManifoldWide) public static void Reduce(ManifoldCandidateScalar* candidates, int candidateCount, Vector3 faceNormalA, float inverseFaceNormalADotLocalNormal, Vector3 faceCenterA, Vector3 faceCenterB, Vector3 tangentBX, Vector3 tangentBY, float epsilonScale, float minimumDepth, in Matrix3x3 rotationToWorld, Vector3 worldOffsetB, int slotIndex, ref Convex4ContactManifoldWide manifoldWide) Parameters candidates ManifoldCandidateScalar* candidateCount int faceNormalA Vector3 inverseFaceNormalADotLocalNormal float faceCenterA Vector3 faceCenterB Vector3 tangentBX Vector3 tangentBY Vector3 epsilonScale float minimumDepth float rotationToWorld Matrix3x3 worldOffsetB Vector3 slotIndex int manifoldWide Convex4ContactManifoldWide ReduceWithoutComputingDepths(ref ManifoldCandidate, Vector<int>, int, Vector<float>, Vector<float>, int, out ManifoldCandidate, out ManifoldCandidate, out ManifoldCandidate, out ManifoldCandidate, out Vector<int>, out Vector<int>, out Vector<int>, out Vector<int>) public static void ReduceWithoutComputingDepths(ref ManifoldCandidate candidates, Vector<int> rawContactCount, int maxCandidateCount, Vector<float> epsilonScale, Vector<float> minimumDepth, int pairCount, out ManifoldCandidate contact0, out ManifoldCandidate contact1, out ManifoldCandidate contact2, out ManifoldCandidate contact3, out Vector<int> contact0Exists, out Vector<int> contact1Exists, out Vector<int> contact2Exists, out Vector<int> contact3Exists) Parameters candidates ManifoldCandidate rawContactCount Vector<int> maxCandidateCount int epsilonScale Vector<float> minimumDepth Vector<float> pairCount int contact0 ManifoldCandidate contact1 ManifoldCandidate contact2 ManifoldCandidate contact3 ManifoldCandidate contact0Exists Vector<int> contact1Exists Vector<int> contact2Exists Vector<int> contact3Exists Vector<int>"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.ManifoldCandidateScalar.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.ManifoldCandidateScalar.html",
    "title": "Struct ManifoldCandidateScalar | Bepu API",
    "keywords": "Struct ManifoldCandidateScalar Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct ManifoldCandidateScalar Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields FeatureId public int FeatureId Field Value int X public float X Field Value float Y public float Y Field Value float"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.MeshPairContinuations-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.MeshPairContinuations-2.html",
    "title": "Struct MeshPairContinuations<TMeshA, TMeshB> | Bepu API",
    "keywords": "Struct MeshPairContinuations<TMeshA, TMeshB> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct MeshPairContinuations<TMeshA, TMeshB> : ICompoundPairContinuationHandler<CompoundMeshReduction> where TMeshA : IHomogeneousCompoundShape<Triangle, TriangleWide> where TMeshB : IHomogeneousCompoundShape<Triangle, TriangleWide> Type Parameters TMeshA TMeshB Implements ICompoundPairContinuationHandler<CompoundMeshReduction> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties CollisionContinuationType public CollisionContinuationType CollisionContinuationType { get; } Property Value CollisionContinuationType Methods ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref CompoundMeshReduction, int, in BoundsTestedPair, int, int, int, in RigidPose, out RigidPose, out int, out void*) public void ConfigureContinuationChild<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref CompoundMeshReduction continuation, int continuationChildIndex, in BoundsTestedPair pair, int childIndexA, int childTypeA, int childIndexB, in RigidPose childPoseA, out RigidPose childPoseB, out int childTypeB, out void* childShapeDataB) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation CompoundMeshReduction continuationChildIndex int pair BoundsTestedPair childIndexA int childTypeA int childIndexB int childPoseA RigidPose childPoseB RigidPose childTypeB int childShapeDataB void* Type Parameters TCallbacks CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks>, int, ref Buffer<ChildOverlapsCollection>, ref Buffer<OverlapQueryForPair>, in BoundsTestedPair, out int) public ref CompoundMeshReduction CreateContinuation<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, int totalChildCount, ref Buffer<ChildOverlapsCollection> pairOverlaps, ref Buffer<OverlapQueryForPair> pairQueries, in BoundsTestedPair pair, out int continuationIndex) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> totalChildCount int pairOverlaps Buffer<ChildOverlapsCollection> pairQueries Buffer<OverlapQueryForPair> pair BoundsTestedPair continuationIndex int Returns CompoundMeshReduction Type Parameters TCallbacks GetChildAData<TCallbacks>(ref CollisionBatcher<TCallbacks>, ref CompoundMeshReduction, in BoundsTestedPair, int, out RigidPose, out int, out void*) public void GetChildAData<TCallbacks>(ref CollisionBatcher<TCallbacks> collisionBatcher, ref CompoundMeshReduction continuation, in BoundsTestedPair pair, int childIndexA, out RigidPose childPoseA, out int childTypeA, out void* childShapeDataA) where TCallbacks : struct, ICollisionCallbacks Parameters collisionBatcher CollisionBatcher<TCallbacks> continuation CompoundMeshReduction pair BoundsTestedPair childIndexA int childPoseA RigidPose childTypeA int childShapeDataA void* Type Parameters TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.MeshPairOverlapFinder-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.MeshPairOverlapFinder-2.html",
    "title": "Struct MeshPairOverlapFinder<TMeshA, TMeshB> | Bepu API",
    "keywords": "Struct MeshPairOverlapFinder<TMeshA, TMeshB> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct MeshPairOverlapFinder<TMeshA, TMeshB> : ICompoundPairOverlapFinder where TMeshA : struct, IHomogeneousCompoundShape<Triangle, TriangleWide> where TMeshB : struct, IHomogeneousCompoundShape<Triangle, TriangleWide> Type Parameters TMeshA TMeshB Implements ICompoundPairOverlapFinder Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods FindLocalOverlaps(ref Buffer<BoundsTestedPair>, int, BufferPool, Shapes, float, out CompoundPairOverlaps) public static void FindLocalOverlaps(ref Buffer<BoundsTestedPair> pairs, int pairCount, BufferPool pool, Shapes shapes, float dt, out CompoundPairOverlaps overlaps) Parameters pairs Buffer<BoundsTestedPair> pairCount int pool BufferPool shapes Shapes dt float overlaps CompoundPairOverlaps"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.OverlapQueryForPair.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.OverlapQueryForPair.html",
    "title": "Struct OverlapQueryForPair | Bepu API",
    "keywords": "Struct OverlapQueryForPair Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct OverlapQueryForPair Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Container public void* Container Field Value void* Max public Vector3 Max Field Value Vector3 Min public Vector3 Min Field Value Vector3"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.PretransformedTriangleSupportFinder.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.PretransformedTriangleSupportFinder.html",
    "title": "Struct PretransformedTriangleSupportFinder | Bepu API",
    "keywords": "Struct PretransformedTriangleSupportFinder Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct PretransformedTriangleSupportFinder : ISupportFinder<Triangle, TriangleWide> Implements ISupportFinder<Triangle, TriangleWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties HasMargin Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape. public bool HasMargin { get; } Property Value bool Methods ComputeLocalSupport(in TriangleWide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeLocalSupport(in TriangleWide shape, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape TriangleWide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide ComputeSupport(in TriangleWide, in Matrix3x3Wide, in Vector3Wide, in Vector<int>, out Vector3Wide) public void ComputeSupport(in TriangleWide shape, in Matrix3x3Wide orientation, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape TriangleWide orientation Matrix3x3Wide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide GetMargin(in TriangleWide, out Vector<float>) Margin associated with the shape according to this support finder. public void GetMargin(in TriangleWide shape, out Vector<float> margin) Parameters shape TriangleWide Shape to find the margin of. margin Vector<float> Margin of the shape."
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereBoxTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereBoxTester.html",
    "title": "Struct SphereBoxTester | Bepu API",
    "keywords": "Struct SphereBoxTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SphereBoxTester : IPairTester<SphereWide, BoxWide, Convex1ContactManifoldWide> Implements IPairTester<SphereWide, BoxWide, Convex1ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref SphereWide, ref BoxWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref BoxWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b BoxWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref BoxWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref BoxWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b BoxWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref BoxWide, ref Vector<float>, ref Vector3Wide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref BoxWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b BoxWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex1ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereCapsuleTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereCapsuleTester.html",
    "title": "Struct SphereCapsuleTester | Bepu API",
    "keywords": "Struct SphereCapsuleTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SphereCapsuleTester : IPairTester<SphereWide, CapsuleWide, Convex1ContactManifoldWide> Implements IPairTester<SphereWide, CapsuleWide, Convex1ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref SphereWide, ref CapsuleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref CapsuleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b CapsuleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref CapsuleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref CapsuleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b CapsuleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref CapsuleWide, ref Vector<float>, ref Vector3Wide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref CapsuleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b CapsuleWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex1ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereConvexHullTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereConvexHullTester.html",
    "title": "Struct SphereConvexHullTester | Bepu API",
    "keywords": "Struct SphereConvexHullTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SphereConvexHullTester : IPairTester<SphereWide, ConvexHullWide, Convex1ContactManifoldWide> Implements IPairTester<SphereWide, ConvexHullWide, Convex1ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref SphereWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex1ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereCylinderTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereCylinderTester.html",
    "title": "Struct SphereCylinderTester | Bepu API",
    "keywords": "Struct SphereCylinderTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SphereCylinderTester : IPairTester<SphereWide, CylinderWide, Convex1ContactManifoldWide> Implements IPairTester<SphereWide, CylinderWide, Convex1ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods ComputeSphereToClosest(in CylinderWide, in Vector3Wide, in Matrix3x3Wide, out Vector3Wide, out Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide) public static void ComputeSphereToClosest(in CylinderWide b, in Vector3Wide offsetB, in Matrix3x3Wide orientationMatrixB, out Vector3Wide cylinderLocalOffsetA, out Vector<float> horizontalOffsetLength, out Vector<float> inverseHorizontalOffsetLength, out Vector3Wide sphereToClosestLocalB, out Vector3Wide sphereToClosest) Parameters b CylinderWide offsetB Vector3Wide orientationMatrixB Matrix3x3Wide cylinderLocalOffsetA Vector3Wide horizontalOffsetLength Vector<float> inverseHorizontalOffsetLength Vector<float> sphereToClosestLocalB Vector3Wide sphereToClosest Vector3Wide Test(ref SphereWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex1ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereIncludingPair.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereIncludingPair.html",
    "title": "Struct SphereIncludingPair | Bepu API",
    "keywords": "Struct SphereIncludingPair Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SphereIncludingPair : ICollisionPair<SphereIncludingPair> Implements ICollisionPair<SphereIncludingPair> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public Sphere A Field Value Sphere B public void* B Field Value void* Continuation public PairContinuation Continuation Field Value PairContinuation FlipMask Stores whether the types involved in pair require that the resulting contact manifold be flipped to be consistent with the user-requested pair order. public int FlipMask Field Value int OffsetB public Vector3 OffsetB Field Value Vector3 OrientationB public Quaternion OrientationB Field Value Quaternion SpeculativeMargin public float SpeculativeMargin Field Value float Properties PairType Gets the enumeration type associated with this pair type. public static CollisionTaskPairType PairType { get; } Property Value CollisionTaskPairType Methods GetContinuation(ref SphereIncludingPair) public static ref PairContinuation GetContinuation(ref SphereIncludingPair pair) Parameters pair SphereIncludingPair Returns PairContinuation"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereIncludingPairWide-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereIncludingPairWide-2.html",
    "title": "Struct SphereIncludingPairWide<TShape, TShapeWide> | Bepu API",
    "keywords": "Struct SphereIncludingPairWide<TShape, TShapeWide> Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SphereIncludingPairWide<TShape, TShapeWide> : ICollisionPairWide<Sphere, SphereWide, TShape, TShapeWide, SphereIncludingPair, SphereIncludingPairWide<TShape, TShapeWide>> where TShape : struct, IConvexShape where TShapeWide : struct, IShapeWide<TShape> Type Parameters TShape TShapeWide Implements ICollisionPairWide<Sphere, SphereWide, TShape, TShapeWide, SphereIncludingPair, SphereIncludingPairWide<TShape, TShapeWide>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public SphereWide A Field Value SphereWide B public TShapeWide B Field Value TShapeWide FlipMask public Vector<int> FlipMask Field Value Vector<int> OffsetB public Vector3Wide OffsetB Field Value Vector3Wide OrientationB public QuaternionWide OrientationB Field Value QuaternionWide SpeculativeMargin public Vector<float> SpeculativeMargin Field Value Vector<float> Properties HasFlipMask public static bool HasFlipMask { get; } Property Value bool OrientationCount public static int OrientationCount { get; } Property Value int Methods GetFlipMask(ref SphereIncludingPairWide<TShape, TShapeWide>) public static ref Vector<int> GetFlipMask(ref SphereIncludingPairWide<TShape, TShapeWide> pair) Parameters pair SphereIncludingPairWide<TShape, TShapeWide> Returns Vector<int> GetOffsetB(ref SphereIncludingPairWide<TShape, TShapeWide>) public static ref Vector3Wide GetOffsetB(ref SphereIncludingPairWide<TShape, TShapeWide> pair) Parameters pair SphereIncludingPairWide<TShape, TShapeWide> Returns Vector3Wide GetOrientationA(ref SphereIncludingPairWide<TShape, TShapeWide>) public static ref QuaternionWide GetOrientationA(ref SphereIncludingPairWide<TShape, TShapeWide> pair) Parameters pair SphereIncludingPairWide<TShape, TShapeWide> Returns QuaternionWide GetOrientationB(ref SphereIncludingPairWide<TShape, TShapeWide>) public static ref QuaternionWide GetOrientationB(ref SphereIncludingPairWide<TShape, TShapeWide> pair) Parameters pair SphereIncludingPairWide<TShape, TShapeWide> Returns QuaternionWide GetShapeA(ref SphereIncludingPairWide<TShape, TShapeWide>) public static ref SphereWide GetShapeA(ref SphereIncludingPairWide<TShape, TShapeWide> pair) Parameters pair SphereIncludingPairWide<TShape, TShapeWide> Returns SphereWide GetShapeB(ref SphereIncludingPairWide<TShape, TShapeWide>) public static ref TShapeWide GetShapeB(ref SphereIncludingPairWide<TShape, TShapeWide> pair) Parameters pair SphereIncludingPairWide<TShape, TShapeWide> Returns TShapeWide GetSpeculativeMargin(ref SphereIncludingPairWide<TShape, TShapeWide>) public static ref Vector<float> GetSpeculativeMargin(ref SphereIncludingPairWide<TShape, TShapeWide> pair) Parameters pair SphereIncludingPairWide<TShape, TShapeWide> Returns Vector<float> WriteSlot(int, in SphereIncludingPair) public void WriteSlot(int index, in SphereIncludingPair source) Parameters index int source SphereIncludingPair"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SpherePair.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SpherePair.html",
    "title": "Struct SpherePair | Bepu API",
    "keywords": "Struct SpherePair Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SpherePair : ICollisionPair<SpherePair> Implements ICollisionPair<SpherePair> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public Sphere A Field Value Sphere B public Sphere B Field Value Sphere Continuation public PairContinuation Continuation Field Value PairContinuation OffsetB public Vector3 OffsetB Field Value Vector3 SpeculativeMargin public float SpeculativeMargin Field Value float Properties PairType Gets the enumeration type associated with this pair type. public static CollisionTaskPairType PairType { get; } Property Value CollisionTaskPairType Methods GetContinuation(ref SpherePair) public static ref PairContinuation GetContinuation(ref SpherePair pair) Parameters pair SpherePair Returns PairContinuation"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SpherePairTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SpherePairTester.html",
    "title": "Struct SpherePairTester | Bepu API",
    "keywords": "Struct SpherePairTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SpherePairTester : IPairTester<SphereWide, SphereWide, Convex1ContactManifoldWide> Implements IPairTester<SphereWide, SphereWide, Convex1ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref SphereWide, ref SphereWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref SphereWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b SphereWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref SphereWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref SphereWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b SphereWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref SphereWide, ref Vector<float>, ref Vector3Wide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref SphereWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b SphereWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex1ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SpherePairWide.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SpherePairWide.html",
    "title": "Struct SpherePairWide | Bepu API",
    "keywords": "Struct SpherePairWide Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SpherePairWide : ICollisionPairWide<Sphere, SphereWide, Sphere, SphereWide, SpherePair, SpherePairWide> Implements ICollisionPairWide<Sphere, SphereWide, Sphere, SphereWide, SpherePair, SpherePairWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public SphereWide A Field Value SphereWide B public SphereWide B Field Value SphereWide OffsetB public Vector3Wide OffsetB Field Value Vector3Wide SpeculativeMargin public Vector<float> SpeculativeMargin Field Value Vector<float> Properties HasFlipMask public static bool HasFlipMask { get; } Property Value bool OrientationCount public static int OrientationCount { get; } Property Value int Methods GetFlipMask(ref SpherePairWide) public static ref Vector<int> GetFlipMask(ref SpherePairWide pair) Parameters pair SpherePairWide Returns Vector<int> GetOffsetB(ref SpherePairWide) public static ref Vector3Wide GetOffsetB(ref SpherePairWide pair) Parameters pair SpherePairWide Returns Vector3Wide GetOrientationA(ref SpherePairWide) public static ref QuaternionWide GetOrientationA(ref SpherePairWide pair) Parameters pair SpherePairWide Returns QuaternionWide GetOrientationB(ref SpherePairWide) public static ref QuaternionWide GetOrientationB(ref SpherePairWide pair) Parameters pair SpherePairWide Returns QuaternionWide GetShapeA(ref SpherePairWide) public static ref SphereWide GetShapeA(ref SpherePairWide pair) Parameters pair SpherePairWide Returns SphereWide GetShapeB(ref SpherePairWide) public static ref SphereWide GetShapeB(ref SpherePairWide pair) Parameters pair SpherePairWide Returns SphereWide GetSpeculativeMargin(ref SpherePairWide) public static ref Vector<float> GetSpeculativeMargin(ref SpherePairWide pair) Parameters pair SpherePairWide Returns Vector<float> WriteSlot(int, in SpherePair) public void WriteSlot(int index, in SpherePair source) Parameters index int source SpherePair"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereTriangleTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.SphereTriangleTester.html",
    "title": "Struct SphereTriangleTester | Bepu API",
    "keywords": "Struct SphereTriangleTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct SphereTriangleTester : IPairTester<SphereWide, TriangleWide, Convex1ContactManifoldWide> Implements IPairTester<SphereWide, TriangleWide, Convex1ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref SphereWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex1ContactManifoldWide Test(ref SphereWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, int, out Convex1ContactManifoldWide) public static void Test(ref SphereWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex1ContactManifoldWide manifold) Parameters a SphereWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex1ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.TriangleConvexHullTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.TriangleConvexHullTester.html",
    "title": "Struct TriangleConvexHullTester | Bepu API",
    "keywords": "Struct TriangleConvexHullTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct TriangleConvexHullTester : IPairTester<TriangleWide, ConvexHullWide, Convex4ContactManifoldWide> Implements IPairTester<TriangleWide, ConvexHullWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref TriangleWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref TriangleWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a TriangleWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref TriangleWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref TriangleWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a TriangleWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref TriangleWide, ref ConvexHullWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref TriangleWide a, ref ConvexHullWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a TriangleWide b ConvexHullWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.TriangleCylinderTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.TriangleCylinderTester.html",
    "title": "Struct TriangleCylinderTester | Bepu API",
    "keywords": "Struct TriangleCylinderTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct TriangleCylinderTester : IPairTester<TriangleWide, CylinderWide, Convex4ContactManifoldWide> Implements IPairTester<TriangleWide, CylinderWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods CreateEffectiveTriangleFaceNormal(in Vector3Wide, in Vector3Wide, Vector<float>, Vector<int>, out Vector3Wide, out Vector<float>) public static void CreateEffectiveTriangleFaceNormal(in Vector3Wide triangleNormal, in Vector3Wide normal, Vector<float> faceNormalADotNormal, Vector<int> inactiveLanes, out Vector3Wide effectiveFaceNormal, out Vector<float> inverseEffectiveFaceNormalDotNormal) Parameters triangleNormal Vector3Wide normal Vector3Wide faceNormalADotNormal Vector<float> inactiveLanes Vector<int> effectiveFaceNormal Vector3Wide inverseEffectiveFaceNormalDotNormal Vector<float> Test(ref TriangleWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref TriangleWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a TriangleWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref TriangleWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref TriangleWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a TriangleWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref TriangleWide, ref CylinderWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref TriangleWide a, ref CylinderWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a TriangleWide b CylinderWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.TrianglePairTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.TrianglePairTester.html",
    "title": "Struct TrianglePairTester | Bepu API",
    "keywords": "Struct TrianglePairTester Namespace BepuPhysics.CollisionDetection.CollisionTasks Assembly BepuPhysics.dll public struct TrianglePairTester : IPairTester<TriangleWide, TriangleWide, Convex4ContactManifoldWide> Implements IPairTester<TriangleWide, TriangleWide, Convex4ContactManifoldWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BatchSize Gets the nubmer of pairs which would ideally be gathered together before executing a wide test. public static int BatchSize { get; } Property Value int Methods Test(ref TriangleWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref TriangleWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationA, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a TriangleWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref TriangleWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, ref QuaternionWide, int, out Convex4ContactManifoldWide) public static void Test(ref TriangleWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, ref QuaternionWide orientationB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a TriangleWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide orientationB QuaternionWide pairCount int manifold Convex4ContactManifoldWide Test(ref TriangleWide, ref TriangleWide, ref Vector<float>, ref Vector3Wide, int, out Convex4ContactManifoldWide) public static void Test(ref TriangleWide a, ref TriangleWide b, ref Vector<float> speculativeMargin, ref Vector3Wide offsetB, int pairCount, out Convex4ContactManifoldWide manifold) Parameters a TriangleWide b TriangleWide speculativeMargin Vector<float> offsetB Vector3Wide pairCount int manifold Convex4ContactManifoldWide"
  },
  "api/BepuPhysics.CollisionDetection.CollisionTasks.html": {
    "href": "api/BepuPhysics.CollisionDetection.CollisionTasks.html",
    "title": "Namespace BepuPhysics.CollisionDetection.CollisionTasks | Bepu API",
    "keywords": "Namespace BepuPhysics.CollisionDetection.CollisionTasks Classes CompoundPairCollisionTask<TCompoundA, TCompoundB, TOverlapFinder, TContinuationHandler, TContinuation> ConvexCollisionTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide, TManifoldWide, TPairTester> ConvexCompoundCollisionTask<TConvex, TCompound, TOverlapFinder, TContinuationHandler, TContinuation> ConvexHullTestHelper ManifoldCandidateHelper Structs BoundsTestedPair Pair of objects awaiting collision processing that involves velocities for bounds calculation. BoxConvexHullTester BoxCylinderTester BoxPairTester BoxTriangleTester CapsuleBoxTester CapsuleConvexHullTester CapsuleCylinderTester CapsulePairTester CapsuleTriangleTester ChildOverlapsCollection CollisionPair CompoundMeshContinuations<TCompound, TMesh> CompoundPairContinuations<TCompoundA, TCompoundB> CompoundPairOverlapFinder<TCompoundA, TCompoundB> CompoundPairOverlaps ConvexCompoundContinuations<TCompound> ConvexCompoundOverlapFinder<TConvex, TConvexWide, TCompound> ConvexCompoundOverlaps ConvexCompoundTaskOverlaps ConvexHullPairTester ConvexMeshContinuations<TMesh> ConvexPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB> CylinderConvexHullTester CylinderPairTester FliplessPair FliplessPairWide<TShape, TShapeWide> ManifoldCandidate ManifoldCandidateScalar MeshPairContinuations<TMeshA, TMeshB> MeshPairOverlapFinder<TMeshA, TMeshB> OverlapQueryForPair PretransformedTriangleSupportFinder SphereBoxTester SphereCapsuleTester SphereConvexHullTester SphereCylinderTester SphereIncludingPair SphereIncludingPairWide<TShape, TShapeWide> SpherePair SpherePairTester SpherePairWide SphereTriangleTester TriangleConvexHullTester TriangleCylinderTester TrianglePairTester Interfaces IBoundsQueryableCompound ICollisionPairWide<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPair, TPairWide> ICollisionPair<TPair> Defines a type that holds scalar data for the collision batcher. ICollisionTaskOverlaps<TSubpairOverlaps> ICollisionTaskSubpairOverlaps ICompoundPairContinuationHandler<TContinuation> ICompoundPairOverlapFinder IContactManifoldWide IConvexCompoundContinuationHandler<TContinuation> IConvexCompoundOverlapFinder IPairTester<TShapeWideA, TShapeWideB, TManifoldWideType>"
  },
  "api/BepuPhysics.CollisionDetection.CompoundMeshReduction.html": {
    "href": "api/BepuPhysics.CollisionDetection.CompoundMeshReduction.html",
    "title": "Struct CompoundMeshReduction | Bepu API",
    "keywords": "Struct CompoundMeshReduction Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct CompoundMeshReduction : ICollisionTestContinuation Implements ICollisionTestContinuation Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ChildManifoldRegions public Buffer<(int Start, int Count)> ChildManifoldRegions Field Value Buffer<(int Start, int Count)> Inner public NonconvexReduction Inner Field Value NonconvexReduction Mesh public Mesh* Mesh Field Value Mesh* MeshOrientation public Quaternion MeshOrientation Field Value Quaternion QueryBounds public Buffer<BoundingBox> QueryBounds Field Value Buffer<BoundingBox> RegionCount public int RegionCount Field Value int RequiresFlip public bool RequiresFlip Field Value bool Triangles public Buffer<Triangle> Triangles Field Value Buffer<Triangle> Methods Create(int, BufferPool) Creates a collision test continuation with the given number of slots for subpairs. public void Create(int childManifoldCount, BufferPool pool) Parameters childManifoldCount int pool BufferPool Pool to take resources from. OnChildCompleted<TCallbacks>(ref PairContinuation, ref ConvexContactManifold, ref CollisionBatcher<TCallbacks>) Handles what to do next when the child pair has finished execution and the resulting manifold is available. public void OnChildCompleted<TCallbacks>(ref PairContinuation report, ref ConvexContactManifold manifold, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters report PairContinuation Continuation instance being considered. manifold ConvexContactManifold Contact manifold for the child pair. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Type Parameters TCallbacks Type of the callbacks used in the batcher. OnUntestedChildCompleted<TCallbacks>(ref PairContinuation, ref CollisionBatcher<TCallbacks>) Handles what to do next when the child pair was rejected for testing, and no manifold exists. public void OnUntestedChildCompleted<TCallbacks>(ref PairContinuation report, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters report PairContinuation Continuation instance being considered. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Type Parameters TCallbacks Type of the callbacks used in the batcher. TryFlush<TCallbacks>(int, ref CollisionBatcher<TCallbacks>) Checks if the parent pair is complete and should be flushed. public bool TryFlush<TCallbacks>(int pairId, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters pairId int Id of the pair to attempt to flush. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Returns bool True if the pair was done and got flushed, false otherwise. Type Parameters TCallbacks Type of the callbacks used in the batcher."
  },
  "api/BepuPhysics.CollisionDetection.ConstraintCache.html": {
    "href": "api/BepuPhysics.CollisionDetection.ConstraintCache.html",
    "title": "Struct ConstraintCache | Bepu API",
    "keywords": "Struct ConstraintCache Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Stores information about a contact constraint from the previous timestep. public struct ConstraintCache Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ConstraintHandle Handle of the contact constraint associated with this cache. public ConstraintHandle ConstraintHandle Field Value ConstraintHandle FeatureId0 Feature id of the first contact in the constraint associated with this cache. public int FeatureId0 Field Value int FeatureId1 Feature id of the second contact in the constraint associated with this cache. public int FeatureId1 Field Value int FeatureId2 Feature id of the third contact in the constraint associated with this cache. public int FeatureId2 Field Value int FeatureId3 Feature id of the fourth contact in the constraint associated with this cache. public int FeatureId3 Field Value int"
  },
  "api/BepuPhysics.CollisionDetection.ConstraintRemover.html": {
    "href": "api/BepuPhysics.CollisionDetection.ConstraintRemover.html",
    "title": "Class ConstraintRemover | Bepu API",
    "keywords": "Class ConstraintRemover Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Accumulates constraints to remove from multiple threads, and efficiently removes them all as a batch. public class ConstraintRemover Inheritance object ConstraintRemover Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConstraintRemover(BufferPool, Bodies, Solver, int, int, float) public ConstraintRemover(BufferPool pool, Bodies bodies, Solver solver, int minimumTypeCapacity = 4, int minimumRemovalCapacity = 128, float previousCapacityMultiplier = 1.25) Parameters pool BufferPool bodies Bodies solver Solver minimumTypeCapacity int minimumRemovalCapacity int previousCapacityMultiplier float Methods CreateFlushJobs(bool) Processes enqueued constraint removals and prepares removal jobs. public int CreateFlushJobs(bool deterministic) Parameters deterministic bool True if the constraint remover should maintain determinism at an added cost, false otherwise. Returns int The number of removal jobs created. To complete the jobs, execute RemoveConstraintsFromTypeBatch for every index from 0 to the returned job count. EnqueueRemoval(int, ConstraintHandle) public void EnqueueRemoval(int workerIndex, ConstraintHandle constraintHandle) Parameters workerIndex int constraintHandle ConstraintHandle MarkAffectedConstraintsAsRemovedFromSolver() For uses of the ConstraintRemover that fully remove a constraint from the simulation (rather than simply moving it somewhere else), the handle->constraint mapping must be updated. This has to wait until after the multithreaded operations actually complete to avoid corrupting parallel operations. public void MarkAffectedConstraintsAsRemovedFromSolver() Postflush() public void Postflush() Prepare(IThreadDispatcher) public void Prepare(IThreadDispatcher dispatcher) Parameters dispatcher IThreadDispatcher RemoveConstraintsFromBatchReferencedHandles() public void RemoveConstraintsFromBatchReferencedHandles() RemoveConstraintsFromBodyLists() public void RemoveConstraintsFromBodyLists() RemoveConstraintsFromFallbackBatchReferencedHandles() public void RemoveConstraintsFromFallbackBatchReferencedHandles() RemoveConstraintsFromTypeBatch(int) public void RemoveConstraintsFromTypeBatch(int index) Parameters index int ReturnConstraintHandles() Returns the handles associated with all removed constraints to the solver's handle pool. public void ReturnConstraintHandles() TryRemoveBodyFromConstrainedKinematicsAndRemoveAllConstraintsForBodyFromFallbackBatch(BodyHandle, int) public void TryRemoveBodyFromConstrainedKinematicsAndRemoveAllConstraintsForBodyFromFallbackBatch(BodyHandle bodyHandle, int bodyIndex) Parameters bodyHandle BodyHandle bodyIndex int"
  },
  "api/BepuPhysics.CollisionDetection.Contact.html": {
    "href": "api/BepuPhysics.CollisionDetection.Contact.html",
    "title": "Struct Contact | Bepu API",
    "keywords": "Struct Contact Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Information about a single contact. public struct Contact Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This type contains a field for the normal; it can be used to represent contacts within nonconvex contact manifolds or convex manifolds. Fields Depth Penetration depth between the two collidables at this contact. Negative values represent separation. public float Depth Field Value float FeatureId Id of the features involved in the collision that generated this contact. If a contact has the same feature id as in a previous frame, it is an indication that the same parts of the shape contributed to its creation. This is useful for carrying information from frame to frame. public int FeatureId Field Value int Normal Surface basis of the contact. If transformed into a rotation matrix, X and Z represent tangent directions and Y represents the contact normal. Points from collidable B to collidable A. public Vector3 Normal Field Value Vector3 Offset Offset from the position of collidable A to the contact position. public Vector3 Offset Field Value Vector3"
  },
  "api/BepuPhysics.CollisionDetection.ContactConstraintAccessor-5.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactConstraintAccessor-5.html",
    "title": "Class ContactConstraintAccessor<TConstraintDescription, TBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> | Bepu API",
    "keywords": "Class ContactConstraintAccessor<TConstraintDescription, TBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public abstract class ContactConstraintAccessor<TConstraintDescription, TBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> : ContactConstraintAccessor where TConstraintDescription : unmanaged, IConstraintDescription<TConstraintDescription> where TBodyHandles : unmanaged where TPrestepData : unmanaged where TContactImpulses : unmanaged Type Parameters TConstraintDescription TBodyHandles TPrestepData TAccumulatedImpulses TContactImpulses Inheritance object ContactConstraintAccessor ContactConstraintAccessor<TConstraintDescription, TBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> Derived ConvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> ConvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> NonconvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> NonconvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> Inherited Members ContactConstraintAccessor.ConstraintTypeId ContactConstraintAccessor.AccumulatedImpulseBundleStrideInBytes ContactConstraintAccessor.ContactCount ContactConstraintAccessor.Convex ContactConstraintAccessor.GatherOldImpulses(ref ConstraintReference, float*) ContactConstraintAccessor.ScatterNewImpulses<TContactImpulses>(ref ConstraintReference, ref TContactImpulses) ContactConstraintAccessor.UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref TContactManifold, ref PairMaterialProperties, TCallBodyHandles) ContactConstraintAccessor.ExtractContactData<TExtractor>(ConstraintHandle, Solver, ref TExtractor) ContactConstraintAccessor.ExtractContactData<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) ContactConstraintAccessor.ExtractContactPrestepAndImpulses<TExtractor>(ConstraintHandle, Solver, ref TExtractor) ContactConstraintAccessor.ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ContactConstraintAccessor() protected ContactConstraintAccessor() Methods CopyContactData(ref ConvexContactManifold, out ConstraintCache, out TConstraintDescription) protected static void CopyContactData(ref ConvexContactManifold manifold, out ConstraintCache constraintCache, out TConstraintDescription description) Parameters manifold ConvexContactManifold constraintCache ConstraintCache description TConstraintDescription CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref ConstraintContactData) protected static void CopyContactData(ref NonconvexContactManifold manifold, ref ConstraintCache constraintCache, ref ConstraintContactData targetContacts) Parameters manifold NonconvexContactManifold constraintCache ConstraintCache targetContacts ConstraintContactData CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref NonconvexConstraintContactData) protected static void CopyContactData(ref NonconvexContactManifold manifold, ref ConstraintCache constraintCache, ref NonconvexConstraintContactData targetContacts) Parameters manifold NonconvexContactManifold constraintCache ConstraintCache targetContacts NonconvexConstraintContactData DeterministicallyAdd<TCallbacks>(int, OverlapWorker[], ref QuickList<SortConstraintTarget>, Simulation, PairCache) public override void DeterministicallyAdd<TCallbacks>(int typeIndex, NarrowPhase<TCallbacks>.OverlapWorker[] overlapWorkers, ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget> constraintsOfType, Simulation simulation, PairCache pairCache) where TCallbacks : struct, INarrowPhaseCallbacks Parameters typeIndex int overlapWorkers OverlapWorker[] constraintsOfType QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget> simulation Simulation pairCache PairCache Type Parameters TCallbacks FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) public override void FlushSequentially<TCallbacks>(ref UntypedList list, int narrowPhaseConstraintTypeId, Simulation simulation, PairCache pairCache) where TCallbacks : struct, INarrowPhaseCallbacks Parameters list UntypedList narrowPhaseConstraintTypeId int simulation Simulation pairCache PairCache Type Parameters TCallbacks FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) public override void FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList list, int narrowPhaseConstraintTypeId, ref Buffer<Buffer<ushort>> speculativeBatchIndices, Simulation simulation, PairCache pairCache) where TCallbacks : struct, INarrowPhaseCallbacks Parameters list UntypedList narrowPhaseConstraintTypeId int speculativeBatchIndices Buffer<Buffer<ushort>> simulation Simulation pairCache PairCache Type Parameters TCallbacks UpdateConstraint<TCallbacks, TCallBodyHandles>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref ConstraintCache, int, ref TConstraintDescription, TCallBodyHandles) protected static void UpdateConstraint<TCallbacks, TCallBodyHandles>(NarrowPhase<TCallbacks> narrowPhase, int manifoldTypeAsConstraintType, int workerIndex, ref CollidablePair pair, ref ConstraintCache constraintCache, int newContactCount, ref TConstraintDescription description, TCallBodyHandles bodyHandles) where TCallbacks : struct, INarrowPhaseCallbacks Parameters narrowPhase NarrowPhase<TCallbacks> manifoldTypeAsConstraintType int workerIndex int pair CollidablePair constraintCache ConstraintCache newContactCount int description TConstraintDescription bodyHandles TCallBodyHandles Type Parameters TCallbacks TCallBodyHandles"
  },
  "api/BepuPhysics.CollisionDetection.ContactConstraintAccessor.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactConstraintAccessor.html",
    "title": "Class ContactConstraintAccessor | Bepu API",
    "keywords": "Class ContactConstraintAccessor Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Provides indirection for reading from and updating constraints in the narrow phase. public abstract class ContactConstraintAccessor Inheritance object ContactConstraintAccessor Derived ContactConstraintAccessor<TConstraintDescription, TBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This, like many other similar constructions in the engine, could conceptually be replaced by static function pointers and a few supplementary data fields. We probably will do exactly that at some point. Fields AccumulatedImpulseBundleStrideInBytes protected int AccumulatedImpulseBundleStrideInBytes Field Value int Convex protected bool Convex Field Value bool Properties ConstraintTypeId public int ConstraintTypeId { get; protected set; } Property Value int ContactCount public int ContactCount { get; protected set; } Property Value int Methods DeterministicallyAdd<TCallbacks>(int, OverlapWorker[], ref QuickList<SortConstraintTarget>, Simulation, PairCache) public abstract void DeterministicallyAdd<TCallbacks>(int typeIndex, NarrowPhase<TCallbacks>.OverlapWorker[] overlapWorkers, ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget> constraintsOfType, Simulation simulation, PairCache pairCache) where TCallbacks : struct, INarrowPhaseCallbacks Parameters typeIndex int overlapWorkers OverlapWorker[] constraintsOfType QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget> simulation Simulation pairCache PairCache Type Parameters TCallbacks ExtractContactData<TExtractor>(ConstraintHandle, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public void ExtractContactData<TExtractor>(ConstraintHandle constraintHandle, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactDataExtractor Parameters constraintHandle ConstraintHandle Handle of the contact constraint to extract. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. ExtractContactData<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public abstract void ExtractContactData<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactDataExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. ExtractContactPrestepAndImpulses<TExtractor>(ConstraintHandle, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public void ExtractContactPrestepAndImpulses<TExtractor>(ConstraintHandle constraintHandle, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactPrestepAndImpulsesExtractor Parameters constraintHandle ConstraintHandle Handle of the contact constraint to extract. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public abstract void ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactPrestepAndImpulsesExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) public abstract void FlushSequentially<TCallbacks>(ref UntypedList list, int narrowPhaseConstraintTypeId, Simulation simulation, PairCache pairCache) where TCallbacks : struct, INarrowPhaseCallbacks Parameters list UntypedList narrowPhaseConstraintTypeId int simulation Simulation pairCache PairCache Type Parameters TCallbacks FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) public abstract void FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList list, int narrowPhaseConstraintTypeId, ref Buffer<Buffer<ushort>> speculativeBatchIndices, Simulation simulation, PairCache pairCache) where TCallbacks : struct, INarrowPhaseCallbacks Parameters list UntypedList narrowPhaseConstraintTypeId int speculativeBatchIndices Buffer<Buffer<ushort>> simulation Simulation pairCache PairCache Type Parameters TCallbacks GatherOldImpulses(ref ConstraintReference, float*) public void GatherOldImpulses(ref ConstraintReference constraintReference, float* oldImpulses) Parameters constraintReference ConstraintReference oldImpulses float* ScatterNewImpulses<TContactImpulses>(ref ConstraintReference, ref TContactImpulses) public void ScatterNewImpulses<TContactImpulses>(ref ConstraintReference constraintReference, ref TContactImpulses contactImpulses) Parameters constraintReference ConstraintReference contactImpulses TContactImpulses Type Parameters TContactImpulses UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref TContactManifold, ref PairMaterialProperties, TCallBodyHandles) public abstract void UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks> narrowPhase, int manifoldTypeAsConstraintType, int workerIndex, ref CollidablePair pair, ref TContactManifold manifoldPointer, ref PairMaterialProperties material, TCallBodyHandles bodyHandles) where TCallbacks : struct, INarrowPhaseCallbacks Parameters narrowPhase NarrowPhase<TCallbacks> manifoldTypeAsConstraintType int workerIndex int pair CollidablePair manifoldPointer TContactManifold material PairMaterialProperties bodyHandles TCallBodyHandles Type Parameters TContactManifold TCallBodyHandles TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.ContactImpulses1.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactImpulses1.html",
    "title": "Struct ContactImpulses1 | Bepu API",
    "keywords": "Struct ContactImpulses1 Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct ContactImpulses1 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Impulse0 public float Impulse0 Field Value float"
  },
  "api/BepuPhysics.CollisionDetection.ContactImpulses2.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactImpulses2.html",
    "title": "Struct ContactImpulses2 | Bepu API",
    "keywords": "Struct ContactImpulses2 Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct ContactImpulses2 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Impulse0 public float Impulse0 Field Value float Impulse1 public float Impulse1 Field Value float"
  },
  "api/BepuPhysics.CollisionDetection.ContactImpulses3.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactImpulses3.html",
    "title": "Struct ContactImpulses3 | Bepu API",
    "keywords": "Struct ContactImpulses3 Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct ContactImpulses3 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Impulse0 public float Impulse0 Field Value float Impulse1 public float Impulse1 Field Value float Impulse2 public float Impulse2 Field Value float"
  },
  "api/BepuPhysics.CollisionDetection.ContactImpulses4.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactImpulses4.html",
    "title": "Struct ContactImpulses4 | Bepu API",
    "keywords": "Struct ContactImpulses4 Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct ContactImpulses4 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Impulse0 public float Impulse0 Field Value float Impulse1 public float Impulse1 Field Value float Impulse2 public float Impulse2 Field Value float Impulse3 public float Impulse3 Field Value float"
  },
  "api/BepuPhysics.CollisionDetection.ContactImpulses5.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactImpulses5.html",
    "title": "Struct ContactImpulses5 | Bepu API",
    "keywords": "Struct ContactImpulses5 Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct ContactImpulses5 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Impulse0 public float Impulse0 Field Value float Impulse1 public float Impulse1 Field Value float Impulse2 public float Impulse2 Field Value float Impulse3 public float Impulse3 Field Value float Impulse4 public float Impulse4 Field Value float"
  },
  "api/BepuPhysics.CollisionDetection.ContactImpulses6.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactImpulses6.html",
    "title": "Struct ContactImpulses6 | Bepu API",
    "keywords": "Struct ContactImpulses6 Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct ContactImpulses6 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Impulse0 public float Impulse0 Field Value float Impulse1 public float Impulse1 Field Value float Impulse2 public float Impulse2 Field Value float Impulse3 public float Impulse3 Field Value float Impulse4 public float Impulse4 Field Value float Impulse5 public float Impulse5 Field Value float"
  },
  "api/BepuPhysics.CollisionDetection.ContactImpulses7.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactImpulses7.html",
    "title": "Struct ContactImpulses7 | Bepu API",
    "keywords": "Struct ContactImpulses7 Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct ContactImpulses7 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Impulse0 public float Impulse0 Field Value float Impulse1 public float Impulse1 Field Value float Impulse2 public float Impulse2 Field Value float Impulse3 public float Impulse3 Field Value float Impulse4 public float Impulse4 Field Value float Impulse5 public float Impulse5 Field Value float Impulse6 public float Impulse6 Field Value float"
  },
  "api/BepuPhysics.CollisionDetection.ContactImpulses8.html": {
    "href": "api/BepuPhysics.CollisionDetection.ContactImpulses8.html",
    "title": "Struct ContactImpulses8 | Bepu API",
    "keywords": "Struct ContactImpulses8 Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct ContactImpulses8 Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Impulse0 public float Impulse0 Field Value float Impulse1 public float Impulse1 Field Value float Impulse2 public float Impulse2 Field Value float Impulse3 public float Impulse3 Field Value float Impulse4 public float Impulse4 Field Value float Impulse5 public float Impulse5 Field Value float Impulse6 public float Impulse6 Field Value float Impulse7 public float Impulse7 Field Value float"
  },
  "api/BepuPhysics.CollisionDetection.Convex1ContactManifoldWide.html": {
    "href": "api/BepuPhysics.CollisionDetection.Convex1ContactManifoldWide.html",
    "title": "Struct Convex1ContactManifoldWide | Bepu API",
    "keywords": "Struct Convex1ContactManifoldWide Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct Convex1ContactManifoldWide : IContactManifoldWide Implements IContactManifoldWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ContactExists public Vector<int> ContactExists Field Value Vector<int> Depth public Vector<float> Depth Field Value Vector<float> FeatureId public Vector<int> FeatureId Field Value Vector<int> Normal public Vector3Wide Normal Field Value Vector3Wide OffsetA public Vector3Wide OffsetA Field Value Vector3Wide Methods ApplyFlipMask(ref Vector3Wide, in Vector<int>) public void ApplyFlipMask(ref Vector3Wide offsetB, in Vector<int> flipMask) Parameters offsetB Vector3Wide flipMask Vector<int> ReadFirst(in Vector3Wide, ref ConvexContactManifold) public void ReadFirst(in Vector3Wide offsetB, ref ConvexContactManifold target) Parameters offsetB Vector3Wide target ConvexContactManifold"
  },
  "api/BepuPhysics.CollisionDetection.Convex2ContactManifoldWide.html": {
    "href": "api/BepuPhysics.CollisionDetection.Convex2ContactManifoldWide.html",
    "title": "Struct Convex2ContactManifoldWide | Bepu API",
    "keywords": "Struct Convex2ContactManifoldWide Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct Convex2ContactManifoldWide : IContactManifoldWide Implements IContactManifoldWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0Exists public Vector<int> Contact0Exists Field Value Vector<int> Contact1Exists public Vector<int> Contact1Exists Field Value Vector<int> Depth0 public Vector<float> Depth0 Field Value Vector<float> Depth1 public Vector<float> Depth1 Field Value Vector<float> FeatureId0 public Vector<int> FeatureId0 Field Value Vector<int> FeatureId1 public Vector<int> FeatureId1 Field Value Vector<int> Normal public Vector3Wide Normal Field Value Vector3Wide OffsetA0 public Vector3Wide OffsetA0 Field Value Vector3Wide OffsetA1 public Vector3Wide OffsetA1 Field Value Vector3Wide Methods ApplyFlipMask(ref Vector3Wide, in Vector<int>) public void ApplyFlipMask(ref Vector3Wide offsetB, in Vector<int> flipMask) Parameters offsetB Vector3Wide flipMask Vector<int> ReadFirst(in Vector3Wide, ref ConvexContactManifold) public void ReadFirst(in Vector3Wide offsetB, ref ConvexContactManifold target) Parameters offsetB Vector3Wide target ConvexContactManifold"
  },
  "api/BepuPhysics.CollisionDetection.Convex4ContactManifoldWide.html": {
    "href": "api/BepuPhysics.CollisionDetection.Convex4ContactManifoldWide.html",
    "title": "Struct Convex4ContactManifoldWide | Bepu API",
    "keywords": "Struct Convex4ContactManifoldWide Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct Convex4ContactManifoldWide : IContactManifoldWide Implements IContactManifoldWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0Exists public Vector<int> Contact0Exists Field Value Vector<int> Contact1Exists public Vector<int> Contact1Exists Field Value Vector<int> Contact2Exists public Vector<int> Contact2Exists Field Value Vector<int> Contact3Exists public Vector<int> Contact3Exists Field Value Vector<int> Depth0 public Vector<float> Depth0 Field Value Vector<float> Depth1 public Vector<float> Depth1 Field Value Vector<float> Depth2 public Vector<float> Depth2 Field Value Vector<float> Depth3 public Vector<float> Depth3 Field Value Vector<float> FeatureId0 public Vector<int> FeatureId0 Field Value Vector<int> FeatureId1 public Vector<int> FeatureId1 Field Value Vector<int> FeatureId2 public Vector<int> FeatureId2 Field Value Vector<int> FeatureId3 public Vector<int> FeatureId3 Field Value Vector<int> Normal public Vector3Wide Normal Field Value Vector3Wide OffsetA0 public Vector3Wide OffsetA0 Field Value Vector3Wide OffsetA1 public Vector3Wide OffsetA1 Field Value Vector3Wide OffsetA2 public Vector3Wide OffsetA2 Field Value Vector3Wide OffsetA3 public Vector3Wide OffsetA3 Field Value Vector3Wide Methods ApplyFlipMask(ref Vector3Wide, in Vector<int>) public void ApplyFlipMask(ref Vector3Wide offsetB, in Vector<int> flipMask) Parameters offsetB Vector3Wide flipMask Vector<int> ReadFirst(in Vector3Wide, ref ConvexContactManifold) public void ReadFirst(in Vector3Wide offsetB, ref ConvexContactManifold target) Parameters offsetB Vector3Wide target ConvexContactManifold"
  },
  "api/BepuPhysics.CollisionDetection.ConvexContact.html": {
    "href": "api/BepuPhysics.CollisionDetection.ConvexContact.html",
    "title": "Struct ConvexContact | Bepu API",
    "keywords": "Struct ConvexContact Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Information about a single contact in a convex collidable pair. Convex collidable pairs share one surface basis across the manifold, since the contact surface is guaranteed to be a plane. public struct ConvexContact Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Depth Penetration depth between the two collidables at this contact. Negative values represent separation. public float Depth Field Value float FeatureId Id of the features involved in the collision that generated this contact. If a contact has the same feature id as in a previous frame, it is an indication that the same parts of the shape contributed to its creation. This is useful for carrying information from frame to frame. public int FeatureId Field Value int Offset Offset from the position of collidable A to the contact position. public Vector3 Offset Field Value Vector3"
  },
  "api/BepuPhysics.CollisionDetection.ConvexContactManifold.html": {
    "href": "api/BepuPhysics.CollisionDetection.ConvexContactManifold.html",
    "title": "Struct ConvexContactManifold | Bepu API",
    "keywords": "Struct ConvexContactManifold Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Contains the data associated with a convex contact manifold. public struct ConvexContactManifold : IContactManifold<ConvexContactManifold> Implements IContactManifold<ConvexContactManifold> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConvexContact Contact0 Field Value ConvexContact Contact1 public ConvexContact Contact1 Field Value ConvexContact Contact2 public ConvexContact Contact2 Field Value ConvexContact Contact3 public ConvexContact Contact3 Field Value ConvexContact Count public int Count Field Value int Normal Surface normal shared by all contacts. Points from collidable B to collidable A. public Vector3 Normal Field Value Vector3 OffsetB Offset from collidable A to collidable B. public Vector3 OffsetB Field Value Vector3 Properties this[int] Gets or sets the contact at the given index in the manifold. public Contact this[int contactIndex] { get; set; } Parameters contactIndex int Index of the contact to get or set. Property Value Contact Contact at the specified index. Remarks Note that contact normals are shared across a ConvexContactManifold. Setting one contact in a convex manifold will change the entire convex manifold's normal. Methods FastRemoveAt(ref ConvexContactManifold, int) public static void FastRemoveAt(ref ConvexContactManifold manifold, int index) Parameters manifold ConvexContactManifold index int GetContact(int, out Contact) Gets a copy of a contact's data. public void GetContact(int contactIndex, out Contact contactData) Parameters contactIndex int Index of the contact to copy data from. contactData Contact Data associated with the contact. GetContact(int, out Vector3, out Vector3, out float, out int) Retrieves a copy of a contact's data. public void GetContact(int contactIndex, out Vector3 offset, out Vector3 normal, out float depth, out int featureId) Parameters contactIndex int Index of the contact to copy data from. offset Vector3 Offset from the first collidable's position to the contact position. normal Vector3 Normal of the contact surface at the requested contact. Points from collidable B to collidable A. depth float Penetration depth at the requested contact. featureId int Feature id of the requested contact. Feature ids represent which parts of the collidables formed the contact and can be used to track unique contacts across frames. GetConvexContactReference(ref ConvexContactManifold, int) Gets a reference to a convex manifold's contact. public static ref ConvexContact GetConvexContactReference(ref ConvexContactManifold manifold, int contactIndex) Parameters manifold ConvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns ConvexContact Reference to the requested contact. Remarks This is a helper that avoids manual casting. If the manifold is not a ConvexContactManifold, the function will throw an NotSupportedException. GetDepth(int) Gets the depth associated with a requested contact. public float GetDepth(int contactIndex) Parameters contactIndex int Index of the contact to grab the depth of. Returns float Depth of the requested contact. GetDepthReference(ref ConvexContactManifold, int) Gets a reference to a contact's depth. public static ref float GetDepthReference(ref ConvexContactManifold manifold, int contactIndex) Parameters manifold ConvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns float Reference to a contact's depth. GetFeatureId(int) Gets the feature id associated with a requested contact. public int GetFeatureId(int contactIndex) Parameters contactIndex int Index of the contact to grab the feature id of. Returns int Feature id of the requested contact. GetFeatureIdReference(ref ConvexContactManifold, int) Gets a reference to a contact's feature id. public static ref int GetFeatureIdReference(ref ConvexContactManifold manifold, int contactIndex) Parameters manifold ConvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns int Reference to a contact's feature id. GetNonconvexContactReference(ref ConvexContactManifold, int) Gets a reference to a nonconvex manifold's contact. public static ref Contact GetNonconvexContactReference(ref ConvexContactManifold manifold, int contactIndex) Parameters manifold ConvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns Contact Reference to the requested contact. Remarks This is a helper that avoids manual casting. If the manifold is not a NonconvexContactManifold, the function will throw an NotSupportedException. GetNormal(int) Gets a contact's normal. public Vector3 GetNormal(int contactIndex) Parameters contactIndex int Index of the contact to grab the normal of. Returns Vector3 Normal of the requested contact. Remarks Points from collidable B to collidable A. In convex manifolds, all contacts share a normal and will return the same value. GetNormalReference(ref ConvexContactManifold, int) Gets a reference to a contact's normal. Points from collidable B to collidable A. For convex manifolds that share a normal, all contact indices will simply return a reference to the manifold-wide normal. public static ref Vector3 GetNormalReference(ref ConvexContactManifold manifold, int contactIndex) Parameters manifold ConvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns Vector3 Reference to a contact's normal (or the manifold-wide normal in a convex manifold). GetOffset(int) Gets the offset from collidable A to the requested contact. public Vector3 GetOffset(int contactIndex) Parameters contactIndex int Index of the contact to grab the offset of. Returns Vector3 Offset to a contact's offset. GetOffsetReference(ref ConvexContactManifold, int) Gets a reference to the offset from collidable A to the requested contact. public static ref Vector3 GetOffsetReference(ref ConvexContactManifold manifold, int contactIndex) Parameters manifold ConvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns Vector3 Reference to a contact's offset."
  },
  "api/BepuPhysics.CollisionDetection.ConvexOneBodyAccessor-4.html": {
    "href": "api/BepuPhysics.CollisionDetection.ConvexOneBodyAccessor-4.html",
    "title": "Class ConvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> | Bepu API",
    "keywords": "Class ConvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public class ConvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> : ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses> where TConstraintDescription : unmanaged, IConvexOneBodyContactConstraintDescription<TConstraintDescription> where TPrestepData : unmanaged, IConvexContactPrestep<TPrestepData> where TAccumulatedImpulses : unmanaged, IConvexContactAccumulatedImpulses<TAccumulatedImpulses> where TContactImpulses : unmanaged Type Parameters TConstraintDescription TPrestepData TAccumulatedImpulses TContactImpulses Inheritance object ContactConstraintAccessor ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses> ConvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> Inherited Members ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.DeterministicallyAdd<TCallbacks>(int, NarrowPhase<TCallbacks>.OverlapWorker[], ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget>, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.UpdateConstraint<TCallbacks, TCallBodyHandles>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref ConstraintCache, int, ref TConstraintDescription, TCallBodyHandles) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref ConvexContactManifold, out ConstraintCache, out TConstraintDescription) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref NonconvexConstraintContactData) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref ConstraintContactData) ContactConstraintAccessor.ConstraintTypeId ContactConstraintAccessor.AccumulatedImpulseBundleStrideInBytes ContactConstraintAccessor.ContactCount ContactConstraintAccessor.Convex ContactConstraintAccessor.GatherOldImpulses(ref ConstraintReference, float*) ContactConstraintAccessor.ScatterNewImpulses<TContactImpulses>(ref ConstraintReference, ref TContactImpulses) ContactConstraintAccessor.DeterministicallyAdd<TCallbacks>(int, NarrowPhase<TCallbacks>.OverlapWorker[], ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget>, Simulation, PairCache) ContactConstraintAccessor.FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) ContactConstraintAccessor.FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) ContactConstraintAccessor.ExtractContactData<TExtractor>(ConstraintHandle, Solver, ref TExtractor) ContactConstraintAccessor.ExtractContactPrestepAndImpulses<TExtractor>(ConstraintHandle, Solver, ref TExtractor) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExtractContactData<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public override void ExtractContactData<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactDataExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public override void ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactPrestepAndImpulsesExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref TContactManifold, ref PairMaterialProperties, TCallBodyHandles) public override void UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks> narrowPhase, int manifoldTypeAsConstraintType, int workerIndex, ref CollidablePair pair, ref TContactManifold manifoldPointer, ref PairMaterialProperties material, TCallBodyHandles bodyHandles) where TCallbacks : struct, INarrowPhaseCallbacks Parameters narrowPhase NarrowPhase<TCallbacks> manifoldTypeAsConstraintType int workerIndex int pair CollidablePair manifoldPointer TContactManifold material PairMaterialProperties bodyHandles TCallBodyHandles Type Parameters TContactManifold TCallBodyHandles TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.ConvexTwoBodyAccessor-4.html": {
    "href": "api/BepuPhysics.CollisionDetection.ConvexTwoBodyAccessor-4.html",
    "title": "Class ConvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> | Bepu API",
    "keywords": "Class ConvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public class ConvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> : ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> where TConstraintDescription : unmanaged, IConvexTwoBodyContactConstraintDescription<TConstraintDescription> where TPrestepData : unmanaged, ITwoBodyConvexContactPrestep<TPrestepData> where TAccumulatedImpulses : unmanaged, IConvexContactAccumulatedImpulses<TAccumulatedImpulses> where TContactImpulses : unmanaged Type Parameters TConstraintDescription TPrestepData TAccumulatedImpulses TContactImpulses Inheritance object ContactConstraintAccessor ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> ConvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> Inherited Members ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.DeterministicallyAdd<TCallbacks>(int, NarrowPhase<TCallbacks>.OverlapWorker[], ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget>, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.UpdateConstraint<TCallbacks, TCallBodyHandles>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref ConstraintCache, int, ref TConstraintDescription, TCallBodyHandles) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref ConvexContactManifold, out ConstraintCache, out TConstraintDescription) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref NonconvexConstraintContactData) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref ConstraintContactData) ContactConstraintAccessor.ConstraintTypeId ContactConstraintAccessor.AccumulatedImpulseBundleStrideInBytes ContactConstraintAccessor.ContactCount ContactConstraintAccessor.Convex ContactConstraintAccessor.GatherOldImpulses(ref ConstraintReference, float*) ContactConstraintAccessor.ScatterNewImpulses<TContactImpulses>(ref ConstraintReference, ref TContactImpulses) ContactConstraintAccessor.DeterministicallyAdd<TCallbacks>(int, NarrowPhase<TCallbacks>.OverlapWorker[], ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget>, Simulation, PairCache) ContactConstraintAccessor.FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) ContactConstraintAccessor.FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) ContactConstraintAccessor.ExtractContactData<TExtractor>(ConstraintHandle, Solver, ref TExtractor) ContactConstraintAccessor.ExtractContactPrestepAndImpulses<TExtractor>(ConstraintHandle, Solver, ref TExtractor) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExtractContactData<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public override void ExtractContactData<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactDataExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public override void ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactPrestepAndImpulsesExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref TContactManifold, ref PairMaterialProperties, TCallBodyHandles) public override void UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks> narrowPhase, int manifoldTypeAsConstraintType, int workerIndex, ref CollidablePair pair, ref TContactManifold manifoldPointer, ref PairMaterialProperties material, TCallBodyHandles bodyHandles) where TCallbacks : struct, INarrowPhaseCallbacks Parameters narrowPhase NarrowPhase<TCallbacks> manifoldTypeAsConstraintType int workerIndex int pair CollidablePair manifoldPointer TContactManifold material PairMaterialProperties bodyHandles TCallBodyHandles Type Parameters TContactManifold TCallBodyHandles TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.DepthRefiner-6.Simplex.html": {
    "href": "api/BepuPhysics.CollisionDetection.DepthRefiner-6.Simplex.html",
    "title": "Struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Simplex | Bepu API",
    "keywords": "Struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Simplex Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Simplex Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex A Field Value DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex B public DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex B Field Value DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex C public DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex C Field Value DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex"
  },
  "api/BepuPhysics.CollisionDetection.DepthRefiner-6.SimplexWithWitness.html": {
    "href": "api/BepuPhysics.CollisionDetection.DepthRefiner-6.SimplexWithWitness.html",
    "title": "Struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.SimplexWithWitness | Bepu API",
    "keywords": "Struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.SimplexWithWitness Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.SimplexWithWitness Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness A Field Value DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness B public DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness B Field Value DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness C public DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness C Field Value DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness WeightDenominator public Vector<float> WeightDenominator Field Value Vector<float>"
  },
  "api/BepuPhysics.CollisionDetection.DepthRefiner-6.Vertex.html": {
    "href": "api/BepuPhysics.CollisionDetection.DepthRefiner-6.Vertex.html",
    "title": "Struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex | Bepu API",
    "keywords": "Struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Exists public Vector<int> Exists Field Value Vector<int> Support public Vector3Wide Support Field Value Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.DepthRefiner-6.VertexWithWitness.html": {
    "href": "api/BepuPhysics.CollisionDetection.DepthRefiner-6.VertexWithWitness.html",
    "title": "Struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness | Bepu API",
    "keywords": "Struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Exists public Vector<int> Exists Field Value Vector<int> Support public Vector3Wide Support Field Value Vector3Wide SupportOnA public Vector3Wide SupportOnA Field Value Vector3Wide Weight public Vector<float> Weight Field Value Vector<float>"
  },
  "api/BepuPhysics.CollisionDetection.DepthRefiner-6.html": {
    "href": "api/BepuPhysics.CollisionDetection.DepthRefiner-6.html",
    "title": "Class DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB> | Bepu API",
    "keywords": "Class DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Incrementally refines a sample direction to approach a local minimum depth between two convex bodies. public static class DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB> where TShapeA : IConvexShape where TShapeWideA : IShapeWide<TShapeA> where TSupportFinderA : ISupportFinder<TShapeA, TShapeWideA> where TShapeB : IConvexShape where TShapeWideB : IShapeWide<TShapeB> where TSupportFinderB : ISupportFinder<TShapeB, TShapeWideB> Type Parameters TShapeA Type of the first shape. TShapeWideA SIMD type of the first shape. TSupportFinderA Type providing support sampling for the first shape. TShapeB Type of the second shape. TShapeWideB SIMD type of the second shape. TSupportFinderB Type providing support sampling for the second shape. Inheritance object DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The DepthRefiner implements a Tootbird search: an incremental algorithm that takes steps towards the Tootbird. The Tootbird is the origin projected on the support plane of the best(lowest depth) support direction observed so far. This uses a simplex that updates with rules similar to a simplified version of GJK.The Tootbird is definitionally not inside the minkowski sum. Methods Create(in Vector3Wide, in Vector3Wide, out Simplex) public static void Create(in Vector3Wide normal, in Vector3Wide support, out DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Simplex simplex) Parameters normal Vector3Wide support Vector3Wide simplex DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Simplex Create(in Vector3Wide, in Vector3Wide, in Vector3Wide, out SimplexWithWitness) public static void Create(in Vector3Wide normal, in Vector3Wide support, in Vector3Wide supportOnA, out DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.SimplexWithWitness simplex) Parameters normal Vector3Wide support Vector3Wide supportOnA Vector3Wide simplex DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.SimplexWithWitness FindMinimumDepth(in TShapeWideA, in TShapeWideB, in Vector3Wide, in Matrix3x3Wide, ref TSupportFinderA, ref TSupportFinderB, ref Simplex, in Vector3Wide, in Vector<float>, in Vector<int>, in Vector<float>, in Vector<float>, out Vector<float>, out Vector3Wide, int) public static void FindMinimumDepth(in TShapeWideA a, in TShapeWideB b, in Vector3Wide localOffsetB, in Matrix3x3Wide localOrientationB, ref TSupportFinderA supportFinderA, ref TSupportFinderB supportFinderB, ref DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Simplex simplex, in Vector3Wide initialNormal, in Vector<float> initialDepth, in Vector<int> inactiveLanes, in Vector<float> convergenceThreshold, in Vector<float> minimumDepthThreshold, out Vector<float> refinedDepth, out Vector3Wide refinedNormal, int maximumIterations = 50) Parameters a TShapeWideA b TShapeWideB localOffsetB Vector3Wide localOrientationB Matrix3x3Wide supportFinderA TSupportFinderA supportFinderB TSupportFinderB simplex DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Simplex initialNormal Vector3Wide initialDepth Vector<float> inactiveLanes Vector<int> convergenceThreshold Vector<float> minimumDepthThreshold Vector<float> refinedDepth Vector<float> refinedNormal Vector3Wide maximumIterations int FindMinimumDepth(in TShapeWideA, in TShapeWideB, in Vector3Wide, in Matrix3x3Wide, ref TSupportFinderA, ref TSupportFinderB, ref SimplexWithWitness, in Vector3Wide, in Vector<float>, in Vector<int>, in Vector<float>, in Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide, int) public static void FindMinimumDepth(in TShapeWideA a, in TShapeWideB b, in Vector3Wide localOffsetB, in Matrix3x3Wide localOrientationB, ref TSupportFinderA supportFinderA, ref TSupportFinderB supportFinderB, ref DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.SimplexWithWitness simplex, in Vector3Wide initialNormal, in Vector<float> initialDepth, in Vector<int> inactiveLanes, in Vector<float> convergenceThreshold, in Vector<float> minimumDepthThreshold, out Vector<float> refinedDepth, out Vector3Wide refinedNormal, out Vector3Wide witnessOnA, int maximumIterations = 50) Parameters a TShapeWideA b TShapeWideB localOffsetB Vector3Wide localOrientationB Matrix3x3Wide supportFinderA TSupportFinderA supportFinderB TSupportFinderB simplex DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.SimplexWithWitness initialNormal Vector3Wide initialDepth Vector<float> inactiveLanes Vector<int> convergenceThreshold Vector<float> minimumDepthThreshold Vector<float> refinedDepth Vector<float> refinedNormal Vector3Wide witnessOnA Vector3Wide maximumIterations int FindMinimumDepth(in TShapeWideA, in TShapeWideB, in Vector3Wide, in Matrix3x3Wide, ref TSupportFinderA, ref TSupportFinderB, in Vector3Wide, in Vector<int>, in Vector<float>, in Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide, int) public static void FindMinimumDepth(in TShapeWideA a, in TShapeWideB b, in Vector3Wide localOffsetB, in Matrix3x3Wide localOrientationB, ref TSupportFinderA supportFinderA, ref TSupportFinderB supportFinderB, in Vector3Wide initialNormal, in Vector<int> inactiveLanes, in Vector<float> searchEpsilon, in Vector<float> minimumDepthThreshold, out Vector<float> depth, out Vector3Wide refinedNormal, out Vector3Wide witnessOnA, int maximumIterations = 25) Parameters a TShapeWideA b TShapeWideB localOffsetB Vector3Wide localOrientationB Matrix3x3Wide supportFinderA TSupportFinderA supportFinderB TSupportFinderB initialNormal Vector3Wide inactiveLanes Vector<int> searchEpsilon Vector<float> minimumDepthThreshold Vector<float> depth Vector<float> refinedNormal Vector3Wide witnessOnA Vector3Wide maximumIterations int FindMinimumDepth(in TShapeWideA, in TShapeWideB, in Vector3Wide, in Matrix3x3Wide, ref TSupportFinderA, ref TSupportFinderB, in Vector3Wide, in Vector<int>, in Vector<float>, in Vector<float>, out Vector<float>, out Vector3Wide, int) public static void FindMinimumDepth(in TShapeWideA a, in TShapeWideB b, in Vector3Wide localOffsetB, in Matrix3x3Wide localOrientationB, ref TSupportFinderA supportFinderA, ref TSupportFinderB supportFinderB, in Vector3Wide initialNormal, in Vector<int> inactiveLanes, in Vector<float> searchEpsilon, in Vector<float> minimumDepthThreshold, out Vector<float> depth, out Vector3Wide refinedNormal, int maximumIterations = 25) Parameters a TShapeWideA b TShapeWideB localOffsetB Vector3Wide localOrientationB Matrix3x3Wide supportFinderA TSupportFinderA supportFinderB TSupportFinderB initialNormal Vector3Wide inactiveLanes Vector<int> searchEpsilon Vector<float> minimumDepthThreshold Vector<float> depth Vector<float> refinedNormal Vector3Wide maximumIterations int FindSupport(in TShapeWideA, in TShapeWideB, in Vector3Wide, in Matrix3x3Wide, ref TSupportFinderA, ref TSupportFinderB, in Vector3Wide, in Vector<int>, out Vector3Wide) public static void FindSupport(in TShapeWideA a, in TShapeWideB b, in Vector3Wide localOffsetB, in Matrix3x3Wide localOrientationB, ref TSupportFinderA supportFinderA, ref TSupportFinderB supportFinderB, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters a TShapeWideA b TShapeWideB localOffsetB Vector3Wide localOrientationB Matrix3x3Wide supportFinderA TSupportFinderA supportFinderB TSupportFinderB direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide FindSupport(in TShapeWideA, in TShapeWideB, in Vector3Wide, in Matrix3x3Wide, ref TSupportFinderA, ref TSupportFinderB, in Vector3Wide, in Vector<int>, out Vector3Wide, out Vector3Wide) public static void FindSupport(in TShapeWideA a, in TShapeWideB b, in Vector3Wide localOffsetB, in Matrix3x3Wide localOrientationB, ref TSupportFinderA supportFinderA, ref TSupportFinderB supportFinderB, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support, out Vector3Wide supportOnA) Parameters a TShapeWideA b TShapeWideB localOffsetB Vector3Wide localOrientationB Matrix3x3Wide supportFinderA TSupportFinderA supportFinderB TSupportFinderB direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide supportOnA Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.IBroadPhaseBatchedRayTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.IBroadPhaseBatchedRayTester.html",
    "title": "Interface IBroadPhaseBatchedRayTester | Bepu API",
    "keywords": "Interface IBroadPhaseBatchedRayTester Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public interface IBroadPhaseBatchedRayTester : IBroadPhaseRayTester Inherited Members IBroadPhaseRayTester.RayTest(CollidableReference, RayData*, float*) Methods RayTest(CollidableReference, ref RaySource) void RayTest(CollidableReference collidable, ref RaySource rays) Parameters collidable CollidableReference rays RaySource"
  },
  "api/BepuPhysics.CollisionDetection.IBroadPhaseRayTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.IBroadPhaseRayTester.html",
    "title": "Interface IBroadPhaseRayTester | Bepu API",
    "keywords": "Interface IBroadPhaseRayTester Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public interface IBroadPhaseRayTester Methods RayTest(CollidableReference, RayData*, float*) void RayTest(CollidableReference collidable, RayData* rayData, float* maximumT) Parameters collidable CollidableReference rayData RayData* maximumT float*"
  },
  "api/BepuPhysics.CollisionDetection.IBroadPhaseSweepTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.IBroadPhaseSweepTester.html",
    "title": "Interface IBroadPhaseSweepTester | Bepu API",
    "keywords": "Interface IBroadPhaseSweepTester Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Defines a type that can act as a callback for broad phase sweep tests. public interface IBroadPhaseSweepTester Methods Test(CollidableReference, ref float) void Test(CollidableReference collidable, ref float maximumT) Parameters collidable CollidableReference maximumT float"
  },
  "api/BepuPhysics.CollisionDetection.ICollisionCallbacks.html": {
    "href": "api/BepuPhysics.CollisionDetection.ICollisionCallbacks.html",
    "title": "Interface ICollisionCallbacks | Bepu API",
    "keywords": "Interface ICollisionCallbacks Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Callbacks invoked by a CollisionBatcher<TCallbacks>. public interface ICollisionCallbacks Methods AllowCollisionTesting(int, int, int) Checks whether further collision testing should be performed for a given subtask. bool AllowCollisionTesting(int pairId, int childA, int childB) Parameters pairId int Id of the parent pair. childA int Index of the child belonging to collidable A in the subpair under consideration. childB int Index of the child belonging to collidable B in the subpair under consideration. Returns bool True if testing should proceed, false otherwise. OnChildPairCompleted(int, int, int, ref ConvexContactManifold) Provides control over subtask generated results before they are reported to the parent task. void OnChildPairCompleted(int pairId, int childA, int childB, ref ConvexContactManifold manifold) Parameters pairId int Id of the parent pair that spawned this child pair. childA int Index of the child belonging to collidable A in the subpair under consideration. childB int Index of the child belonging to collidable B in the subpair under consideration. manifold ConvexContactManifold Manifold of the child pair to configure. OnPairCompleted<TManifold>(int, ref TManifold) Called when a pair submitted to a collision batcher has finished collision detection. void OnPairCompleted<TManifold>(int pairId, ref TManifold manifold) where TManifold : unmanaged, IContactManifold<TManifold> Parameters pairId int Id of the pair that completed. manifold TManifold Contact manifold generated by collision testing. Type Parameters TManifold Type of the contact manifold generated by collision detection."
  },
  "api/BepuPhysics.CollisionDetection.ICollisionTestContinuation.html": {
    "href": "api/BepuPhysics.CollisionDetection.ICollisionTestContinuation.html",
    "title": "Interface ICollisionTestContinuation | Bepu API",
    "keywords": "Interface ICollisionTestContinuation Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Defines a type which includes information necessary to apply some form of post processing to a collision test result. public interface ICollisionTestContinuation Methods Create(int, BufferPool) Creates a collision test continuation with the given number of slots for subpairs. void Create(int slots, BufferPool pool) Parameters slots int Number of subpair slots to include in the continuation. pool BufferPool Pool to take resources from. OnChildCompleted<TCallbacks>(ref PairContinuation, ref ConvexContactManifold, ref CollisionBatcher<TCallbacks>) Handles what to do next when the child pair has finished execution and the resulting manifold is available. void OnChildCompleted<TCallbacks>(ref PairContinuation report, ref ConvexContactManifold manifold, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters report PairContinuation Continuation instance being considered. manifold ConvexContactManifold Contact manifold for the child pair. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Type Parameters TCallbacks Type of the callbacks used in the batcher. OnUntestedChildCompleted<TCallbacks>(ref PairContinuation, ref CollisionBatcher<TCallbacks>) Handles what to do next when the child pair was rejected for testing, and no manifold exists. void OnUntestedChildCompleted<TCallbacks>(ref PairContinuation report, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters report PairContinuation Continuation instance being considered. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Type Parameters TCallbacks Type of the callbacks used in the batcher. TryFlush<TCallbacks>(int, ref CollisionBatcher<TCallbacks>) Checks if the parent pair is complete and should be flushed. bool TryFlush<TCallbacks>(int pairId, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters pairId int Id of the pair to attempt to flush. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Returns bool True if the pair was done and got flushed, false otherwise. Type Parameters TCallbacks Type of the callbacks used in the batcher."
  },
  "api/BepuPhysics.CollisionDetection.IContactManifold-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.IContactManifold-1.html",
    "title": "Interface IContactManifold<TManifold> | Bepu API",
    "keywords": "Interface IContactManifold<TManifold> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public interface IContactManifold<TManifold> where TManifold : struct, IContactManifold<TManifold> Type Parameters TManifold Properties Convex Gets whether the contact manifold was created by a pair of convex objects or not. True if convex, false if nonconvex. bool Convex { get; } Property Value bool Count Gets the number of contacts in the manifold. int Count { get; } Property Value int this[int] Gets or sets the contact at the given index in the manifold. Contact this[int contactIndex] { get; set; } Parameters contactIndex int Index of the contact to get or set. Property Value Contact Contact at the specified index. Remarks Note that contact normals are shared across a ConvexContactManifold. Setting one contact in a convex manifold will change the entire convex manifold's normal. Methods GetContact(int, out Contact) Gets a copy of a contact's data. void GetContact(int contactIndex, out Contact contactData) Parameters contactIndex int Index of the contact to copy data from. contactData Contact Data associated with the contact. GetContact(int, out Vector3, out Vector3, out float, out int) Gets a copy of a contact's data. void GetContact(int contactIndex, out Vector3 offset, out Vector3 normal, out float depth, out int featureId) Parameters contactIndex int Index of the contact to copy data from. offset Vector3 Offset from the first collidable's position to the contact position. normal Vector3 Normal of the contact surface at the requested contact. Points from collidable B to collidable A. depth float Penetration depth at the requested contact. featureId int Feature id of the requested contact. Feature ids represent which parts of the collidables formed the contact and can be used to track unique contacts across frames. GetConvexContactReference(ref TManifold, int) Gets a reference to a convex manifold's contact. public static abstract ref ConvexContact GetConvexContactReference(ref TManifold manifold, int contactIndex) Parameters manifold TManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns ConvexContact Reference to the requested contact. Remarks This is a helper that avoids manual casting. If the manifold is not a ConvexContactManifold, the function will throw an NotSupportedException. GetDepth(int) Gets the depth associated with a requested contact. float GetDepth(int contactIndex) Parameters contactIndex int Index of the contact to grab the depth of. Returns float Depth of the requested contact. GetDepthReference(ref TManifold, int) Gets a reference to a contact's depth. public static abstract ref float GetDepthReference(ref TManifold manifold, int contactIndex) Parameters manifold TManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns float Reference to a contact's depth. GetFeatureId(int) Gets the feature id associated with a requested contact. int GetFeatureId(int contactIndex) Parameters contactIndex int Index of the contact to grab the feature id of. Returns int Feature id of the requested contact. GetFeatureIdReference(ref TManifold, int) Gets a reference to a contact's feature id. public static abstract ref int GetFeatureIdReference(ref TManifold manifold, int contactIndex) Parameters manifold TManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns int Reference to a contact's feature id. GetNonconvexContactReference(ref TManifold, int) Gets a reference to a nonconvex manifold's contact. public static abstract ref Contact GetNonconvexContactReference(ref TManifold manifold, int contactIndex) Parameters manifold TManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns Contact Reference to the requested contact. Remarks This is a helper that avoids manual casting. If the manifold is not a NonconvexContactManifold, the function will throw an NotSupportedException. GetNormal(int) Gets a contact's normal. Vector3 GetNormal(int contactIndex) Parameters contactIndex int Index of the contact to grab the normal of. Returns Vector3 Normal of the requested contact. Remarks Points from collidable B to collidable A. In convex manifolds, all contacts share a normal and will return the same value. GetNormalReference(ref TManifold, int) Gets a reference to a contact's normal. Points from collidable B to collidable A. For convex manifolds that share a normal, all contact indices will simply return a reference to the manifold-wide normal. public static abstract ref Vector3 GetNormalReference(ref TManifold manifold, int contactIndex) Parameters manifold TManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns Vector3 Reference to a contact's normal (or the manifold-wide normal in a convex manifold). GetOffset(int) Gets the offset from collidable A to the requested contact. Vector3 GetOffset(int contactIndex) Parameters contactIndex int Index of the contact to grab the offset of. Returns Vector3 Offset to a contact's offset. GetOffsetReference(ref TManifold, int) Gets a reference to the offset from collidable A to the requested contact. public static abstract ref Vector3 GetOffsetReference(ref TManifold manifold, int contactIndex) Parameters manifold TManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns Vector3 Reference to a contact's offset."
  },
  "api/BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.html": {
    "href": "api/BepuPhysics.CollisionDetection.INarrowPhaseCallbacks.html",
    "title": "Interface INarrowPhaseCallbacks | Bepu API",
    "keywords": "Interface INarrowPhaseCallbacks Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Defines handlers for narrow phase events. public interface INarrowPhaseCallbacks Methods AllowContactGeneration(int, CollidableReference, CollidableReference, ref float) Chooses whether to allow contact generation to proceed for two overlapping collidables. bool AllowContactGeneration(int workerIndex, CollidableReference a, CollidableReference b, ref float speculativeMargin) Parameters workerIndex int Index of the worker that identified the overlap. a CollidableReference Reference to the first collidable in the pair. b CollidableReference Reference to the second collidable in the pair. speculativeMargin float Reference to the speculative margin used by the pair. The value was already initialized by the narrowphase by examining the speculative margins of the involved collidables, but it can be modified. Returns bool True if collision detection should proceed, false otherwise. AllowContactGeneration(int, CollidablePair, int, int) Chooses whether to allow contact generation to proceed for the children of two overlapping collidables in a compound-including pair. bool AllowContactGeneration(int workerIndex, CollidablePair pair, int childIndexA, int childIndexB) Parameters workerIndex int Index of the worker thread processing this pair. pair CollidablePair Parent pair of the two child collidables. childIndexA int Index of the child of collidable A in the pair. If collidable A is not compound, then this is always 0. childIndexB int Index of the child of collidable B in the pair. If collidable B is not compound, then this is always 0. Returns bool True if collision detection should proceed, false otherwise. Remarks This is called for each sub-overlap in a collidable pair involving compound collidables. If neither collidable in a pair is compound, this will not be called. For compound-including pairs, if the earlier call to AllowContactGeneration returns false for owning pair, this will not be called. Note that it is possible for this function to be called twice for the same subpair if the pair has continuous collision detection enabled; the CCD sweep test that runs before the contact generation test also asks before performing child pair tests. ConfigureContactManifold(int, CollidablePair, int, int, ref ConvexContactManifold) Provides a notification that a manifold has been created between the children of two collidables in a compound-including pair. Offers an opportunity to change the manifold's details. bool ConfigureContactManifold(int workerIndex, CollidablePair pair, int childIndexA, int childIndexB, ref ConvexContactManifold manifold) Parameters workerIndex int Index of the worker thread that created this manifold. pair CollidablePair Pair of collidables that the manifold was detected between. childIndexA int Index of the child of collidable A in the pair. If collidable A is not compound, then this is always 0. childIndexB int Index of the child of collidable B in the pair. If collidable B is not compound, then this is always 0. manifold ConvexContactManifold Set of contacts detected between the collidables. Returns bool True if this manifold should be considered for the parent pair's contact manifold generation, false otherwise. ConfigureContactManifold<TManifold>(int, CollidablePair, ref TManifold, out PairMaterialProperties) Provides a notification that a manifold has been created for a pair. Offers an opportunity to change the manifold's details. bool ConfigureContactManifold<TManifold>(int workerIndex, CollidablePair pair, ref TManifold manifold, out PairMaterialProperties pairMaterial) where TManifold : unmanaged, IContactManifold<TManifold> Parameters workerIndex int Index of the worker thread that created this manifold. pair CollidablePair Pair of collidables that the manifold was detected between. manifold TManifold Set of contacts detected between the collidables. pairMaterial PairMaterialProperties Material properties of the manifold. Returns bool True if a constraint should be created for the manifold, false otherwise. Type Parameters TManifold Dispose() Releases any resources held by the callbacks. Called by the owning narrow phase when it is being disposed. void Dispose() Initialize(Simulation) Performs any required initialization logic after the Simulation instance has been constructed. void Initialize(Simulation simulation) Parameters simulation Simulation Simulation that owns these callbacks."
  },
  "api/BepuPhysics.CollisionDetection.ISupportFinder-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.ISupportFinder-2.html",
    "title": "Interface ISupportFinder<TShape, TShapeWide> | Bepu API",
    "keywords": "Interface ISupportFinder<TShape, TShapeWide> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public interface ISupportFinder<TShape, TShapeWide> where TShape : IConvexShape where TShapeWide : IShapeWide<TShape> Type Parameters TShape TShapeWide Properties HasMargin Gets whether the support finder is sampling a shape with a spherical margin that should be applied after a solution is found for the core shape. bool HasMargin { get; } Property Value bool Methods ComputeLocalSupport(in TShapeWide, in Vector3Wide, in Vector<int>, out Vector3Wide) void ComputeLocalSupport(in TShapeWide shape, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape TShapeWide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide ComputeSupport(in TShapeWide, in Matrix3x3Wide, in Vector3Wide, in Vector<int>, out Vector3Wide) void ComputeSupport(in TShapeWide shape, in Matrix3x3Wide orientation, in Vector3Wide direction, in Vector<int> terminatedLanes, out Vector3Wide support) Parameters shape TShapeWide orientation Matrix3x3Wide direction Vector3Wide terminatedLanes Vector<int> support Vector3Wide GetMargin(in TShapeWide, out Vector<float>) Margin associated with the shape according to this support finder. void GetMargin(in TShapeWide shape, out Vector<float> margin) Parameters shape TShapeWide Shape to find the margin of. margin Vector<float> Margin of the shape."
  },
  "api/BepuPhysics.CollisionDetection.ISweepFilter.html": {
    "href": "api/BepuPhysics.CollisionDetection.ISweepFilter.html",
    "title": "Interface ISweepFilter | Bepu API",
    "keywords": "Interface ISweepFilter Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public interface ISweepFilter Methods AllowTest(int, int) Checks whether a swept test should be performed for children of swept shapes. bool AllowTest(int childA, int childB) Parameters childA int Index of the child belonging to collidable A. childB int Index of the child belonging to collidable B. Returns bool True if testing should proceed, false otherwise."
  },
  "api/BepuPhysics.CollisionDetection.MeshReduction.html": {
    "href": "api/BepuPhysics.CollisionDetection.MeshReduction.html",
    "title": "Struct MeshReduction | Bepu API",
    "keywords": "Struct MeshReduction Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct MeshReduction : ICollisionTestContinuation Implements ICollisionTestContinuation Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields FaceCollisionFlag Flag used to mark a contact as being generated by the face of a triangle in its feature id. public const int FaceCollisionFlag = 32768 Field Value int Inner public NonconvexReduction Inner Field Value NonconvexReduction Mesh public void* Mesh Field Value void* MeshOrientation public Quaternion MeshOrientation Field Value Quaternion MinimumDotForFaceCollision Minimum dot product between a triangle face and the contact normal for a collision to be considered a triangle face contact. public const float MinimumDotForFaceCollision = 0.999999 Field Value float QueryBounds public BoundingBox QueryBounds Field Value BoundingBox RequiresFlip public bool RequiresFlip Field Value bool Triangles public Buffer<Triangle> Triangles Field Value Buffer<Triangle> Methods Create(int, BufferPool) Creates a collision test continuation with the given number of slots for subpairs. public void Create(int childManifoldCount, BufferPool pool) Parameters childManifoldCount int pool BufferPool Pool to take resources from. OnChildCompleted<TCallbacks>(ref PairContinuation, ref ConvexContactManifold, ref CollisionBatcher<TCallbacks>) Handles what to do next when the child pair has finished execution and the resulting manifold is available. public void OnChildCompleted<TCallbacks>(ref PairContinuation report, ref ConvexContactManifold manifold, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters report PairContinuation Continuation instance being considered. manifold ConvexContactManifold Contact manifold for the child pair. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Type Parameters TCallbacks Type of the callbacks used in the batcher. OnUntestedChildCompleted<TCallbacks>(ref PairContinuation, ref CollisionBatcher<TCallbacks>) Handles what to do next when the child pair was rejected for testing, and no manifold exists. public void OnUntestedChildCompleted<TCallbacks>(ref PairContinuation report, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters report PairContinuation Continuation instance being considered. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Type Parameters TCallbacks Type of the callbacks used in the batcher. ReduceManifolds(ref Buffer<Triangle>, ref Buffer<NonconvexReductionChild>, int, int, bool, in BoundingBox, in Matrix3x3, in Matrix3x3, Mesh*, BufferPool) public static void ReduceManifolds(ref Buffer<Triangle> continuationTriangles, ref Buffer<NonconvexReductionChild> continuationChildren, int start, int count, bool requiresFlip, in BoundingBox queryBounds, in Matrix3x3 meshOrientation, in Matrix3x3 meshInverseOrientation, Mesh* mesh, BufferPool pool) Parameters continuationTriangles Buffer<Triangle> continuationChildren Buffer<NonconvexReductionChild> start int count int requiresFlip bool queryBounds BoundingBox meshOrientation Matrix3x3 meshInverseOrientation Matrix3x3 mesh Mesh* pool BufferPool TryFlush<TCallbacks>(int, ref CollisionBatcher<TCallbacks>) Checks if the parent pair is complete and should be flushed. public bool TryFlush<TCallbacks>(int pairId, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters pairId int Id of the pair to attempt to flush. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Returns bool True if the pair was done and got flushed, false otherwise. Type Parameters TCallbacks Type of the callbacks used in the batcher."
  },
  "api/BepuPhysics.CollisionDetection.NarrowPhase-1.CollisionCallbacks.html": {
    "href": "api/BepuPhysics.CollisionDetection.NarrowPhase-1.CollisionCallbacks.html",
    "title": "Struct NarrowPhase<TCallbacks>.CollisionCallbacks | Bepu API",
    "keywords": "Struct NarrowPhase<TCallbacks>.CollisionCallbacks Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct NarrowPhase<TCallbacks>.CollisionCallbacks : ICollisionCallbacks Implements ICollisionCallbacks Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CollisionCallbacks(int, BufferPool, NarrowPhase<TCallbacks>) public CollisionCallbacks(int workerIndex, BufferPool pool, NarrowPhase<TCallbacks> narrowPhase) Parameters workerIndex int pool BufferPool narrowPhase NarrowPhase<TCallbacks> Methods AddContinuous(ref CollidablePair, Vector3, Vector3, Vector3, float) public CCDContinuationIndex AddContinuous(ref CollidablePair pair, Vector3 relativeLinearVelocity, Vector3 angularVelocityA, Vector3 angularVelocityB, float t) Parameters pair CollidablePair relativeLinearVelocity Vector3 angularVelocityA Vector3 angularVelocityB Vector3 t float Returns CCDContinuationIndex AddDiscrete(ref CollidablePair) public CCDContinuationIndex AddDiscrete(ref CollidablePair pair) Parameters pair CollidablePair Returns CCDContinuationIndex AllowCollisionTesting(int, int, int) Checks whether further collision testing should be performed for a given subtask. public bool AllowCollisionTesting(int pairId, int childA, int childB) Parameters pairId int Id of the parent pair. childA int Index of the child belonging to collidable A in the subpair under consideration. childB int Index of the child belonging to collidable B in the subpair under consideration. Returns bool True if testing should proceed, false otherwise. OnChildPairCompleted(int, int, int, ref ConvexContactManifold) Provides control over subtask generated results before they are reported to the parent task. public void OnChildPairCompleted(int pairId, int childA, int childB, ref ConvexContactManifold manifold) Parameters pairId int Id of the parent pair that spawned this child pair. childA int Index of the child belonging to collidable A in the subpair under consideration. childB int Index of the child belonging to collidable B in the subpair under consideration. manifold ConvexContactManifold Manifold of the child pair to configure. OnPairCompleted<TManifold>(int, ref TManifold) Called when a pair submitted to a collision batcher has finished collision detection. public void OnPairCompleted<TManifold>(int pairId, ref TManifold manifoldReference) where TManifold : unmanaged, IContactManifold<TManifold> Parameters pairId int Id of the pair that completed. manifoldReference TManifold Type Parameters TManifold Type of the contact manifold generated by collision detection."
  },
  "api/BepuPhysics.CollisionDetection.NarrowPhase-1.ConstraintGeneratorType.html": {
    "href": "api/BepuPhysics.CollisionDetection.NarrowPhase-1.ConstraintGeneratorType.html",
    "title": "Enum NarrowPhase<TCallbacks>.ConstraintGeneratorType | Bepu API",
    "keywords": "Enum NarrowPhase<TCallbacks>.ConstraintGeneratorType Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public enum NarrowPhase<TCallbacks>.ConstraintGeneratorType Fields Continuous = 1 Pair which samples a swept location for contacts and needs to be rewound to compute proper speculative depths in a post process. Discrete = 0 Pair which will directly produce constraints."
  },
  "api/BepuPhysics.CollisionDetection.NarrowPhase-1.OverlapWorker.html": {
    "href": "api/BepuPhysics.CollisionDetection.NarrowPhase-1.OverlapWorker.html",
    "title": "Struct NarrowPhase<TCallbacks>.OverlapWorker | Bepu API",
    "keywords": "Struct NarrowPhase<TCallbacks>.OverlapWorker Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct NarrowPhase<TCallbacks>.OverlapWorker Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors OverlapWorker(int, BufferPool, NarrowPhase<TCallbacks>) public OverlapWorker(int workerIndex, BufferPool pool, NarrowPhase<TCallbacks> narrowPhase) Parameters workerIndex int pool BufferPool narrowPhase NarrowPhase<TCallbacks> Fields Batcher public CollisionBatcher<NarrowPhase<TCallbacks>.CollisionCallbacks> Batcher Field Value CollisionBatcher<NarrowPhase<TCallbacks>.CollisionCallbacks> PendingConstraints public NarrowPhase<TCallbacks>.PendingConstraintAddCache PendingConstraints Field Value NarrowPhase<TCallbacks>.PendingConstraintAddCache PendingSetAwakenings public QuickList<int> PendingSetAwakenings Field Value QuickList<int>"
  },
  "api/BepuPhysics.CollisionDetection.NarrowPhase-1.PendingConstraintAddCache.html": {
    "href": "api/BepuPhysics.CollisionDetection.NarrowPhase-1.PendingConstraintAddCache.html",
    "title": "Struct NarrowPhase<TCallbacks>.PendingConstraintAddCache | Bepu API",
    "keywords": "Struct NarrowPhase<TCallbacks>.PendingConstraintAddCache Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct NarrowPhase<TCallbacks>.PendingConstraintAddCache Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors PendingConstraintAddCache(BufferPool, int) public PendingConstraintAddCache(BufferPool pool, int minimumConstraintCountPerCache = 128) Parameters pool BufferPool minimumConstraintCountPerCache int Methods AddConstraint<TBodyHandles, TDescription, TContactImpulses>(int, CollidablePair, PairCacheChangeIndex, TBodyHandles, ref TDescription, ref TContactImpulses) public void AddConstraint<TBodyHandles, TDescription, TContactImpulses>(int manifoldConstraintType, CollidablePair pair, PairCacheChangeIndex pairCacheChange, TBodyHandles bodyHandles, ref TDescription constraintDescription, ref TContactImpulses impulses) where TBodyHandles : unmanaged where TDescription : unmanaged, IConstraintDescription<TDescription> Parameters manifoldConstraintType int pair CollidablePair pairCacheChange PairCacheChangeIndex bodyHandles TBodyHandles constraintDescription TDescription impulses TContactImpulses Type Parameters TBodyHandles TDescription TContactImpulses DeterministicAdd<TBodyHandles, TDescription, TContactImpulses>(int, ref SortConstraintTarget, OverlapWorker[], Simulation, ref PairCache) public static void DeterministicAdd<TBodyHandles, TDescription, TContactImpulses>(int typeIndex, ref NarrowPhase<TCallbacks>.SortConstraintTarget target, NarrowPhase<TCallbacks>.OverlapWorker[] overlapWorkers, Simulation simulation, ref PairCache pairCache) where TBodyHandles : unmanaged where TDescription : unmanaged, IConstraintDescription<TDescription> Parameters typeIndex int target NarrowPhase<TCallbacks>.SortConstraintTarget overlapWorkers OverlapWorker[] simulation Simulation pairCache PairCache Type Parameters TBodyHandles TDescription TContactImpulses Dispose() public void Dispose() SequentialAddToSimulationSpeculative<TBodyHandles, TDescription, TContactImpulses>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) public static void SequentialAddToSimulationSpeculative<TBodyHandles, TDescription, TContactImpulses>(ref UntypedList list, int narrowPhaseConstraintTypeId, ref Buffer<Buffer<ushort>> speculativeBatchIndices, Simulation simulation, PairCache pairCache) where TBodyHandles : unmanaged where TDescription : unmanaged, IConstraintDescription<TDescription> Parameters list UntypedList narrowPhaseConstraintTypeId int speculativeBatchIndices Buffer<Buffer<ushort>> simulation Simulation pairCache PairCache Type Parameters TBodyHandles TDescription TContactImpulses SequentialAddToSimulation<TBodyHandles, TDescription, TContactImpulses>(ref UntypedList, int, Simulation, PairCache) public static void SequentialAddToSimulation<TBodyHandles, TDescription, TContactImpulses>(ref UntypedList list, int narrowPhaseConstraintTypeId, Simulation simulation, PairCache pairCache) where TBodyHandles : unmanaged where TDescription : unmanaged, IConstraintDescription<TDescription> Parameters list UntypedList narrowPhaseConstraintTypeId int simulation Simulation pairCache PairCache Type Parameters TBodyHandles TDescription TContactImpulses"
  },
  "api/BepuPhysics.CollisionDetection.NarrowPhase-1.SortConstraintTarget.html": {
    "href": "api/BepuPhysics.CollisionDetection.NarrowPhase-1.SortConstraintTarget.html",
    "title": "Struct NarrowPhase<TCallbacks>.SortConstraintTarget | Bepu API",
    "keywords": "Struct NarrowPhase<TCallbacks>.SortConstraintTarget Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct NarrowPhase<TCallbacks>.SortConstraintTarget Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ByteIndexInCache public int ByteIndexInCache Field Value int SortKey public ulong SortKey Field Value ulong WorkerIndex public int WorkerIndex Field Value int"
  },
  "api/BepuPhysics.CollisionDetection.NarrowPhase-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.NarrowPhase-1.html",
    "title": "Class NarrowPhase<TCallbacks> | Bepu API",
    "keywords": "Class NarrowPhase<TCallbacks> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Turns broad phase overlaps into contact manifolds and uses them to manage constraints in the solver. public class NarrowPhase<TCallbacks> : NarrowPhase where TCallbacks : struct, INarrowPhaseCallbacks Type Parameters TCallbacks Type of the callbacks to use. Inheritance object NarrowPhase NarrowPhase<TCallbacks> Inherited Members NarrowPhase.Simulation NarrowPhase.Pool NarrowPhase.Bodies NarrowPhase.Statics NarrowPhase.Solver NarrowPhase.Shapes NarrowPhase.SweepTaskRegistry NarrowPhase.CollisionTaskRegistry NarrowPhase.ConstraintRemover NarrowPhase.PairCache NarrowPhase.RegisterContactConstraintAccessor(ContactConstraintAccessor) NarrowPhase.TryGetContactConstraintAccessor(int, out ContactConstraintAccessor) NarrowPhase.TryExtractSolverContactData<TExtractor>(ConstraintHandle, ref TExtractor) NarrowPhase.TryExtractSolverContactPrestepAndImpulses<TExtractor>(ConstraintHandle, ref TExtractor) NarrowPhase.IsContactConstraintType(int) NarrowPhase.Prepare(float, IThreadDispatcher) NarrowPhase.Flush(IThreadDispatcher) NarrowPhase.Clear() NarrowPhase.Dispose() NarrowPhase.SortCollidableReferencesForPair(CollidableReference, CollidableReference, out CollidableMobility, out CollidableMobility, out CollidableReference, out CollidableReference) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NarrowPhase(Simulation, CollisionTaskRegistry, SweepTaskRegistry, TCallbacks, int, int, int) public NarrowPhase(Simulation simulation, CollisionTaskRegistry collisionTaskRegistry, SweepTaskRegistry sweepTaskRegistry, TCallbacks callbacks, int initialSetCapacity, int minimumMappingSize = 2048, int minimumPendingSize = 128) Parameters simulation Simulation collisionTaskRegistry CollisionTaskRegistry sweepTaskRegistry SweepTaskRegistry callbacks TCallbacks initialSetCapacity int minimumMappingSize int minimumPendingSize int Fields Callbacks public TCallbacks Callbacks Field Value TCallbacks Methods ExtractContactConstraintBodyCount(int) public static int ExtractContactConstraintBodyCount(int contactConstraintTypeId) Parameters contactConstraintTypeId int Returns int HandleOverlap(int, CollidableReference, CollidableReference) public void HandleOverlap(int workerIndex, CollidableReference a, CollidableReference b) Parameters workerIndex int a CollidableReference b CollidableReference OnDispose() protected override void OnDispose() OnPostflush(IThreadDispatcher) protected override void OnPostflush(IThreadDispatcher threadDispatcher) Parameters threadDispatcher IThreadDispatcher OnPreflush(IThreadDispatcher, bool) protected override void OnPreflush(IThreadDispatcher threadDispatcher, bool deterministic) Parameters threadDispatcher IThreadDispatcher deterministic bool OnPrepare(IThreadDispatcher) protected override void OnPrepare(IThreadDispatcher threadDispatcher) Parameters threadDispatcher IThreadDispatcher UpdateConstraint<TBodyHandles, TDescription, TContactImpulses>(int, CollidablePair, int, ref ConstraintCache, int, ref TDescription, TBodyHandles) public void UpdateConstraint<TBodyHandles, TDescription, TContactImpulses>(int workerIndex, CollidablePair pair, int manifoldTypeAsConstraintType, ref ConstraintCache newConstraintCache, int newContactCount, ref TDescription description, TBodyHandles bodyHandles) where TBodyHandles : unmanaged where TDescription : unmanaged, IConstraintDescription<TDescription> where TContactImpulses : unmanaged Parameters workerIndex int pair CollidablePair manifoldTypeAsConstraintType int newConstraintCache ConstraintCache newContactCount int description TDescription bodyHandles TBodyHandles Type Parameters TBodyHandles TDescription TContactImpulses UpdateConstraintsForPair<TContactManifold>(int, CollidablePair, ref TContactManifold) public void UpdateConstraintsForPair<TContactManifold>(int workerIndex, CollidablePair pair, ref TContactManifold manifold) where TContactManifold : unmanaged, IContactManifold<TContactManifold> Parameters workerIndex int pair CollidablePair manifold TContactManifold Type Parameters TContactManifold"
  },
  "api/BepuPhysics.CollisionDetection.NarrowPhase.html": {
    "href": "api/BepuPhysics.CollisionDetection.NarrowPhase.html",
    "title": "Class NarrowPhase | Bepu API",
    "keywords": "Class NarrowPhase Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public abstract class NarrowPhase Inheritance object NarrowPhase Derived NarrowPhase<TCallbacks> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NarrowPhase() protected NarrowPhase() Fields Bodies public Bodies Bodies Field Value Bodies CollisionTaskRegistry public CollisionTaskRegistry CollisionTaskRegistry Field Value CollisionTaskRegistry ConstraintRemover public ConstraintRemover ConstraintRemover Field Value ConstraintRemover PairCache public PairCache PairCache Field Value PairCache Pool public BufferPool Pool Field Value BufferPool Shapes public Shapes Shapes Field Value Shapes Simulation public Simulation Simulation Field Value Simulation Solver public Solver Solver Field Value Solver Statics public Statics Statics Field Value Statics SweepTaskRegistry public SweepTaskRegistry SweepTaskRegistry Field Value SweepTaskRegistry Methods Clear() public void Clear() Dispose() public void Dispose() Flush(IThreadDispatcher) public void Flush(IThreadDispatcher threadDispatcher = null) Parameters threadDispatcher IThreadDispatcher IsContactConstraintType(int) Gets whether a constraint type id maps to a contact constraint. public static bool IsContactConstraintType(int constraintTypeId) Parameters constraintTypeId int Id of the constraint to check. Returns bool True if the type id refers to a contact constraint. False otherwise. OnDispose() protected abstract void OnDispose() OnPostflush(IThreadDispatcher) protected abstract void OnPostflush(IThreadDispatcher threadDispatcher) Parameters threadDispatcher IThreadDispatcher OnPreflush(IThreadDispatcher, bool) protected abstract void OnPreflush(IThreadDispatcher threadDispatcher, bool deterministic) Parameters threadDispatcher IThreadDispatcher deterministic bool OnPrepare(IThreadDispatcher) protected abstract void OnPrepare(IThreadDispatcher threadDispatcher) Parameters threadDispatcher IThreadDispatcher Prepare(float, IThreadDispatcher) public void Prepare(float dt, IThreadDispatcher threadDispatcher = null) Parameters dt float threadDispatcher IThreadDispatcher RegisterContactConstraintAccessor(ContactConstraintAccessor) public void RegisterContactConstraintAccessor(ContactConstraintAccessor contactConstraintAccessor) Parameters contactConstraintAccessor ContactConstraintAccessor SortCollidableReferencesForPair(CollidableReference, CollidableReference, out CollidableMobility, out CollidableMobility, out CollidableReference, out CollidableReference) Sorts references to guarantee that two collidables in the same pair will always be in the same order. public static void SortCollidableReferencesForPair(CollidableReference a, CollidableReference b, out CollidableMobility aMobility, out CollidableMobility bMobility, out CollidableReference sortedA, out CollidableReference sortedB) Parameters a CollidableReference First collidable reference to sort. b CollidableReference First collidable reference to sort. aMobility CollidableMobility Mobility extracted from collidable A. bMobility CollidableMobility Mobility extracted from collidable B. sortedA CollidableReference sortedB CollidableReference TryExtractSolverContactData<TExtractor>(ConstraintHandle, ref TExtractor) Tries to extract contact prestep, impulse, and body reference data from the given handle. If it's not a contact constraint, returns false. public bool TryExtractSolverContactData<TExtractor>(ConstraintHandle constraintHandle, ref TExtractor extractor) where TExtractor : struct, ISolverContactDataExtractor Parameters constraintHandle ConstraintHandle Constraint to try to extract data from. extractor TExtractor Extractor used to collect contact data from the solver. Returns bool True if the constraint was a contact type, false otherwise. Type Parameters TExtractor Type of the extractor used to collect contact data from the solver. TryExtractSolverContactPrestepAndImpulses<TExtractor>(ConstraintHandle, ref TExtractor) Tries to extract prestep and impulse contact data from the given handle. If it's not a contact constraint, returns false. public bool TryExtractSolverContactPrestepAndImpulses<TExtractor>(ConstraintHandle constraintHandle, ref TExtractor extractor) where TExtractor : struct, ISolverContactPrestepAndImpulsesExtractor Parameters constraintHandle ConstraintHandle Constraint to try to extract data from. extractor TExtractor Extractor used to collect contact data from the solver. Returns bool True if the constraint was a contact type, false otherwise. Type Parameters TExtractor Type of the extractor used to collect contact data from the solver. TryGetContactConstraintAccessor(int, out ContactConstraintAccessor) Looks up the contact constraint accessor for the given constraint type id if it exists. public bool TryGetContactConstraintAccessor(int constraintTypeId, out ContactConstraintAccessor accessor) Parameters constraintTypeId int Constraint type id to look up a constraint accessor for. accessor ContactConstraintAccessor Accessor for the given type id. Returns bool True if the constraint type id refers to a registered accessor, false otherwise."
  },
  "api/BepuPhysics.CollisionDetection.NarrowPhaseFlushJob.html": {
    "href": "api/BepuPhysics.CollisionDetection.NarrowPhaseFlushJob.html",
    "title": "Struct NarrowPhaseFlushJob | Bepu API",
    "keywords": "Struct NarrowPhaseFlushJob Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct NarrowPhaseFlushJob Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Index public int Index Field Value int Type public NarrowPhaseFlushJobType Type Field Value NarrowPhaseFlushJobType"
  },
  "api/BepuPhysics.CollisionDetection.NarrowPhaseFlushJobType.html": {
    "href": "api/BepuPhysics.CollisionDetection.NarrowPhaseFlushJobType.html",
    "title": "Enum NarrowPhaseFlushJobType | Bepu API",
    "keywords": "Enum NarrowPhaseFlushJobType Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public enum NarrowPhaseFlushJobType Fields FlushPairCacheChanges = 5 RemoveConstraintFromBatchReferencedHandles = 2 RemoveConstraintFromTypeBatch = 4 RemoveConstraintsFromBodyLists = 0 RemoveConstraintsFromFallbackBatch = 3 ReturnConstraintHandles = 1"
  },
  "api/BepuPhysics.CollisionDetection.NonconvexContactManifold.html": {
    "href": "api/BepuPhysics.CollisionDetection.NonconvexContactManifold.html",
    "title": "Struct NonconvexContactManifold | Bepu API",
    "keywords": "Struct NonconvexContactManifold Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Contains the data associated with a nonconvex contact manifold. public struct NonconvexContactManifold : IContactManifold<NonconvexContactManifold> Implements IContactManifold<NonconvexContactManifold> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public Contact Contact0 Field Value Contact Contact1 public Contact Contact1 Field Value Contact Contact2 public Contact Contact2 Field Value Contact Contact3 public Contact Contact3 Field Value Contact Count public int Count Field Value int MaximumContactCount The maximum number of contacts that can exist within a nonconvex manifold. public const int MaximumContactCount = 4 Field Value int OffsetB Offset from collidable A to collidable B. public Vector3 OffsetB Field Value Vector3 Properties this[int] Gets or sets the contact at the given index in the manifold. public Contact this[int contactIndex] { get; set; } Parameters contactIndex int Index of the contact to get or set. Property Value Contact Contact at the specified index. Remarks Note that contact normals are shared across a ConvexContactManifold. Setting one contact in a convex manifold will change the entire convex manifold's normal. Methods Add(NonconvexContactManifold*, ref Vector3, ref ConvexContact) public static void Add(NonconvexContactManifold* manifold, ref Vector3 normal, ref ConvexContact convexContact) Parameters manifold NonconvexContactManifold* normal Vector3 convexContact ConvexContact Allocate(NonconvexContactManifold*) public static ref Contact Allocate(NonconvexContactManifold* manifold) Parameters manifold NonconvexContactManifold* Returns Contact FastRemoveAt(NonconvexContactManifold*, int) public static void FastRemoveAt(NonconvexContactManifold* manifold, int index) Parameters manifold NonconvexContactManifold* index int GetContact(int, out Contact) Gets a copy of a contact's data. public void GetContact(int contactIndex, out Contact contactData) Parameters contactIndex int Index of the contact to copy data from. contactData Contact Data associated with the contact. GetContact(int, out Vector3, out Vector3, out float, out int) Gets a copy of a contact's data. public void GetContact(int contactIndex, out Vector3 offset, out Vector3 normal, out float depth, out int featureId) Parameters contactIndex int Index of the contact to copy data from. offset Vector3 Offset from the first collidable's position to the contact position. normal Vector3 Normal of the contact surface at the requested contact. Points from collidable B to collidable A. depth float Penetration depth at the requested contact. featureId int Feature id of the requested contact. Feature ids represent which parts of the collidables formed the contact and can be used to track unique contacts across frames. GetConvexContactReference(ref NonconvexContactManifold, int) Gets a reference to a convex manifold's contact. public static ref ConvexContact GetConvexContactReference(ref NonconvexContactManifold manifold, int contactIndex) Parameters manifold NonconvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns ConvexContact Reference to the requested contact. Remarks This is a helper that avoids manual casting. If the manifold is not a ConvexContactManifold, the function will throw an NotSupportedException. GetDepth(int) Gets the depth associated with a requested contact. public float GetDepth(int contactIndex) Parameters contactIndex int Index of the contact to grab the depth of. Returns float Depth of the requested contact. GetDepthReference(ref NonconvexContactManifold, int) Gets a reference to a contact's depth. public static ref float GetDepthReference(ref NonconvexContactManifold manifold, int contactIndex) Parameters manifold NonconvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns float Reference to a contact's depth. GetFeatureId(int) Gets the feature id associated with a requested contact. public int GetFeatureId(int contactIndex) Parameters contactIndex int Index of the contact to grab the feature id of. Returns int Feature id of the requested contact. GetFeatureIdReference(ref NonconvexContactManifold, int) Gets a reference to a contact's feature id. public static ref int GetFeatureIdReference(ref NonconvexContactManifold manifold, int contactIndex) Parameters manifold NonconvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns int Reference to a contact's feature id. GetNonconvexContactReference(ref NonconvexContactManifold, int) Gets a reference to a nonconvex manifold's contact. public static ref Contact GetNonconvexContactReference(ref NonconvexContactManifold manifold, int contactIndex) Parameters manifold NonconvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns Contact Reference to the requested contact. Remarks This is a helper that avoids manual casting. If the manifold is not a NonconvexContactManifold, the function will throw an NotSupportedException. GetNormal(int) Gets a contact's normal. public Vector3 GetNormal(int contactIndex) Parameters contactIndex int Index of the contact to grab the normal of. Returns Vector3 Normal of the requested contact. Remarks Points from collidable B to collidable A. In convex manifolds, all contacts share a normal and will return the same value. GetNormalReference(ref NonconvexContactManifold, int) Gets a reference to a contact's normal. Points from collidable B to collidable A. For convex manifolds that share a normal, all contact indices will simply return a reference to the manifold-wide normal. public static ref Vector3 GetNormalReference(ref NonconvexContactManifold manifold, int contactIndex) Parameters manifold NonconvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns Vector3 Reference to a contact's normal (or the manifold-wide normal in a convex manifold). GetOffset(int) Gets the offset from collidable A to the requested contact. public Vector3 GetOffset(int contactIndex) Parameters contactIndex int Index of the contact to grab the offset of. Returns Vector3 Offset to a contact's offset. GetOffsetReference(ref NonconvexContactManifold, int) Gets a reference to the offset from collidable A to the requested contact. public static ref Vector3 GetOffsetReference(ref NonconvexContactManifold manifold, int contactIndex) Parameters manifold NonconvexContactManifold Manifold to pull a reference from. contactIndex int Contact to pull data from. Returns Vector3 Reference to a contact's offset."
  },
  "api/BepuPhysics.CollisionDetection.NonconvexOneBodyAccessor-4.html": {
    "href": "api/BepuPhysics.CollisionDetection.NonconvexOneBodyAccessor-4.html",
    "title": "Class NonconvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> | Bepu API",
    "keywords": "Class NonconvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public class NonconvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> : ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses> where TConstraintDescription : unmanaged, INonconvexOneBodyContactConstraintDescription<TConstraintDescription> where TPrestepData : unmanaged, INonconvexContactPrestep<TPrestepData> where TAccumulatedImpulses : unmanaged, INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> where TContactImpulses : unmanaged Type Parameters TConstraintDescription TPrestepData TAccumulatedImpulses TContactImpulses Inheritance object ContactConstraintAccessor ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses> NonconvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> Inherited Members ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.DeterministicallyAdd<TCallbacks>(int, NarrowPhase<TCallbacks>.OverlapWorker[], ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget>, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.UpdateConstraint<TCallbacks, TCallBodyHandles>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref ConstraintCache, int, ref TConstraintDescription, TCallBodyHandles) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref ConvexContactManifold, out ConstraintCache, out TConstraintDescription) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref NonconvexConstraintContactData) ContactConstraintAccessor<TConstraintDescription, int, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref ConstraintContactData) ContactConstraintAccessor.ConstraintTypeId ContactConstraintAccessor.AccumulatedImpulseBundleStrideInBytes ContactConstraintAccessor.ContactCount ContactConstraintAccessor.Convex ContactConstraintAccessor.GatherOldImpulses(ref ConstraintReference, float*) ContactConstraintAccessor.ScatterNewImpulses<TContactImpulses>(ref ConstraintReference, ref TContactImpulses) ContactConstraintAccessor.DeterministicallyAdd<TCallbacks>(int, NarrowPhase<TCallbacks>.OverlapWorker[], ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget>, Simulation, PairCache) ContactConstraintAccessor.FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) ContactConstraintAccessor.FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) ContactConstraintAccessor.ExtractContactData<TExtractor>(ConstraintHandle, Solver, ref TExtractor) ContactConstraintAccessor.ExtractContactPrestepAndImpulses<TExtractor>(ConstraintHandle, Solver, ref TExtractor) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExtractContactData<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public override void ExtractContactData<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactDataExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public override void ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactPrestepAndImpulsesExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref TContactManifold, ref PairMaterialProperties, TCallBodyHandles) public override void UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks> narrowPhase, int manifoldTypeAsConstraintType, int workerIndex, ref CollidablePair pair, ref TContactManifold manifoldPointer, ref PairMaterialProperties material, TCallBodyHandles bodyHandles) where TCallbacks : struct, INarrowPhaseCallbacks Parameters narrowPhase NarrowPhase<TCallbacks> manifoldTypeAsConstraintType int workerIndex int pair CollidablePair manifoldPointer TContactManifold material PairMaterialProperties bodyHandles TCallBodyHandles Type Parameters TContactManifold TCallBodyHandles TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.NonconvexReduction.html": {
    "href": "api/BepuPhysics.CollisionDetection.NonconvexReduction.html",
    "title": "Struct NonconvexReduction | Bepu API",
    "keywords": "Struct NonconvexReduction Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct NonconvexReduction : ICollisionTestContinuation Implements ICollisionTestContinuation Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ChildCount public int ChildCount Field Value int Children public Buffer<NonconvexReductionChild> Children Field Value Buffer<NonconvexReductionChild> CompletedChildCount public int CompletedChildCount Field Value int Methods Create(int, BufferPool) Creates a collision test continuation with the given number of slots for subpairs. public void Create(int childManifoldCount, BufferPool pool) Parameters childManifoldCount int pool BufferPool Pool to take resources from. Flush<TCallbacks>(int, ref CollisionBatcher<TCallbacks>) public void Flush<TCallbacks>(int pairId, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters pairId int batcher CollisionBatcher<TCallbacks> Type Parameters TCallbacks OnChildCompleted<TCallbacks>(ref PairContinuation, ref ConvexContactManifold, ref CollisionBatcher<TCallbacks>) Handles what to do next when the child pair has finished execution and the resulting manifold is available. public void OnChildCompleted<TCallbacks>(ref PairContinuation report, ref ConvexContactManifold manifold, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters report PairContinuation Continuation instance being considered. manifold ConvexContactManifold Contact manifold for the child pair. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Type Parameters TCallbacks Type of the callbacks used in the batcher. OnUntestedChildCompleted<TCallbacks>(ref PairContinuation, ref CollisionBatcher<TCallbacks>) Handles what to do next when the child pair was rejected for testing, and no manifold exists. public void OnUntestedChildCompleted<TCallbacks>(ref PairContinuation report, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters report PairContinuation Continuation instance being considered. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Type Parameters TCallbacks Type of the callbacks used in the batcher. TryFlush<TCallbacks>(int, ref CollisionBatcher<TCallbacks>) Checks if the parent pair is complete and should be flushed. public bool TryFlush<TCallbacks>(int pairId, ref CollisionBatcher<TCallbacks> batcher) where TCallbacks : struct, ICollisionCallbacks Parameters pairId int Id of the pair to attempt to flush. batcher CollisionBatcher<TCallbacks> Collision batcher processing the pair. Returns bool True if the pair was done and got flushed, false otherwise. Type Parameters TCallbacks Type of the callbacks used in the batcher."
  },
  "api/BepuPhysics.CollisionDetection.NonconvexReductionChild.html": {
    "href": "api/BepuPhysics.CollisionDetection.NonconvexReductionChild.html",
    "title": "Struct NonconvexReductionChild | Bepu API",
    "keywords": "Struct NonconvexReductionChild Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct NonconvexReductionChild Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ChildIndexA public int ChildIndexA Field Value int ChildIndexB public int ChildIndexB Field Value int Manifold public ConvexContactManifold Manifold Field Value ConvexContactManifold OffsetA Offset from the origin of the first shape's parent to the child's location in world space. If there is no parent, this is the zero vector. public Vector3 OffsetA Field Value Vector3 OffsetB Offset from the origin of the second shape's parent to the child's location in world space. If there is no parent, this is the zero vector. public Vector3 OffsetB Field Value Vector3"
  },
  "api/BepuPhysics.CollisionDetection.NonconvexTwoBodyAccessor-4.html": {
    "href": "api/BepuPhysics.CollisionDetection.NonconvexTwoBodyAccessor-4.html",
    "title": "Class NonconvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> | Bepu API",
    "keywords": "Class NonconvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public class NonconvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> : ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> where TConstraintDescription : unmanaged, INonconvexTwoBodyContactConstraintDescription<TConstraintDescription> where TPrestepData : unmanaged, ITwoBodyNonconvexContactPrestep<TPrestepData> where TAccumulatedImpulses : unmanaged, INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> where TContactImpulses : unmanaged Type Parameters TConstraintDescription TPrestepData TAccumulatedImpulses TContactImpulses Inheritance object ContactConstraintAccessor ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> NonconvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> Inherited Members ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.DeterministicallyAdd<TCallbacks>(int, NarrowPhase<TCallbacks>.OverlapWorker[], ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget>, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.UpdateConstraint<TCallbacks, TCallBodyHandles>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref ConstraintCache, int, ref TConstraintDescription, TCallBodyHandles) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref ConvexContactManifold, out ConstraintCache, out TConstraintDescription) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref NonconvexConstraintContactData) ContactConstraintAccessor<TConstraintDescription, TwoBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses>.CopyContactData(ref NonconvexContactManifold, ref ConstraintCache, ref ConstraintContactData) ContactConstraintAccessor.ConstraintTypeId ContactConstraintAccessor.AccumulatedImpulseBundleStrideInBytes ContactConstraintAccessor.ContactCount ContactConstraintAccessor.Convex ContactConstraintAccessor.GatherOldImpulses(ref ConstraintReference, float*) ContactConstraintAccessor.ScatterNewImpulses<TContactImpulses>(ref ConstraintReference, ref TContactImpulses) ContactConstraintAccessor.DeterministicallyAdd<TCallbacks>(int, NarrowPhase<TCallbacks>.OverlapWorker[], ref QuickList<NarrowPhase<TCallbacks>.SortConstraintTarget>, Simulation, PairCache) ContactConstraintAccessor.FlushWithSpeculativeBatches<TCallbacks>(ref UntypedList, int, ref Buffer<Buffer<ushort>>, Simulation, PairCache) ContactConstraintAccessor.FlushSequentially<TCallbacks>(ref UntypedList, int, Simulation, PairCache) ContactConstraintAccessor.ExtractContactData<TExtractor>(ConstraintHandle, Solver, ref TExtractor) ContactConstraintAccessor.ExtractContactPrestepAndImpulses<TExtractor>(ConstraintHandle, Solver, ref TExtractor) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExtractContactData<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public override void ExtractContactData<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactDataExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation, Solver, ref TExtractor) Extracts references to data from a contact constraint of the accessor's type. public override void ExtractContactPrestepAndImpulses<TExtractor>(in ConstraintLocation constraintLocation, Solver solver, ref TExtractor extractor) where TExtractor : struct, ISolverContactPrestepAndImpulsesExtractor Parameters constraintLocation ConstraintLocation Location of the constraint in the solver. solver Solver Solver in which the constraint lives. extractor TExtractor Extractor to handle the extracted references. Type Parameters TExtractor Type of the extractor to handle the extracted references. UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks>, int, int, ref CollidablePair, ref TContactManifold, ref PairMaterialProperties, TCallBodyHandles) public override void UpdateConstraintForManifold<TContactManifold, TCallBodyHandles, TCallbacks>(NarrowPhase<TCallbacks> narrowPhase, int manifoldTypeAsConstraintType, int workerIndex, ref CollidablePair pair, ref TContactManifold manifoldPointer, ref PairMaterialProperties material, TCallBodyHandles bodyHandles) where TCallbacks : struct, INarrowPhaseCallbacks Parameters narrowPhase NarrowPhase<TCallbacks> manifoldTypeAsConstraintType int workerIndex int pair CollidablePair manifoldPointer TContactManifold material PairMaterialProperties bodyHandles TCallBodyHandles Type Parameters TContactManifold TCallBodyHandles TCallbacks"
  },
  "api/BepuPhysics.CollisionDetection.PairCache.html": {
    "href": "api/BepuPhysics.CollisionDetection.PairCache.html",
    "title": "Class PairCache | Bepu API",
    "keywords": "Class PairCache Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public class PairCache Inheritance object PairCache Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PairCache(BufferPool, int, int, int) public PairCache(BufferPool pool, int initialSetCapacity, int minimumMappingSize, int minimumPendingSize) Parameters pool BufferPool initialSetCapacity int minimumMappingSize int minimumPendingSize int Fields CollisionConstraintTypeCount public const int CollisionConstraintTypeCount = 22 Field Value int CollisionTypeCount public const int CollisionTypeCount = 16 Field Value int Mapping public QuickDictionary<CollidablePair, ConstraintCache, CollidablePairComparer> Mapping Field Value QuickDictionary<CollidablePair, ConstraintCache, CollidablePairComparer> Methods Dispose() public void Dispose() FlushMappingChanges() public void FlushMappingChanges() GetCache(int) public ref ConstraintCache GetCache(int index) Parameters index int Returns ConstraintCache IndexOf(CollidablePair) public int IndexOf(CollidablePair pair) Parameters pair CollidablePair Returns int Postflush() public void Postflush() Prepare(IThreadDispatcher) public void Prepare(IThreadDispatcher threadDispatcher = null) Parameters threadDispatcher IThreadDispatcher PrepareFlushJobs(ref QuickList<NarrowPhaseFlushJob>) Flush all deferred changes from the last narrow phase execution. public void PrepareFlushJobs(ref QuickList<NarrowPhaseFlushJob> jobs) Parameters jobs QuickList<NarrowPhaseFlushJob>"
  },
  "api/BepuPhysics.CollisionDetection.PairCacheChangeIndex.html": {
    "href": "api/BepuPhysics.CollisionDetection.PairCacheChangeIndex.html",
    "title": "Struct PairCacheChangeIndex | Bepu API",
    "keywords": "Struct PairCacheChangeIndex Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Refers to a change in a PairCache. public struct PairCacheChangeIndex Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Index Index of the change in the cache. For pending changes, refers to the index within the pending cache; for a direct mapping changes, refers to the pair index. public int Index Field Value int WorkerIndex Index of the WorkerPendingPairChanges storing the pending change, if any. If -1, then this pair cache change refers to a change directly to the mapping. public int WorkerIndex Field Value int Properties IsPending Gets whether this change is in the PairCache public bool IsPending { get; } Property Value bool"
  },
  "api/BepuPhysics.CollisionDetection.PairContinuation.html": {
    "href": "api/BepuPhysics.CollisionDetection.PairContinuation.html",
    "title": "Struct PairContinuation | Bepu API",
    "keywords": "Struct PairContinuation Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct PairContinuation Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors PairContinuation(int) public PairContinuation(int pairId) Parameters pairId int PairContinuation(int, int, int, CollisionContinuationType, int, int) public PairContinuation(int pairId, int childA, int childB, CollisionContinuationType continuationType, int continuationIndex, int continuationChildIndex) Parameters pairId int childA int childB int continuationType CollisionContinuationType continuationIndex int continuationChildIndex int Fields ChildA public int ChildA Field Value int ChildB public int ChildB Field Value int ChildIndexBits Covers bits [0, 20) in the packed representation. Refers to the child pair index in a subtask generating collision task that generated this continuation. public const int ChildIndexBits = 20 Field Value int ContinuationIndexBits Covers bits [20, 30) in the packed representation. Refers to the index of a subpair in a continuation processor. Maximum number should be equal to the sum of the batch sizes subtask generating collision tasks, which as of this writing is 384, but we'll include a little buffer. public const int ContinuationIndexBits = 10 Field Value int ContinuationTypeBits Covers bits [30, 32) in the packed representation. Refers to which continuation processor should be used for this subpair. public const int ContinuationTypeBits = 2 Field Value int ExclusiveMaximumChildIndex public const int ExclusiveMaximumChildIndex = 1048576 Field Value int ExclusiveMaximumContinuationIndex public const int ExclusiveMaximumContinuationIndex = 1024 Field Value int ExclusiveMaximumContinuationType public const int ExclusiveMaximumContinuationType = 4 Field Value int Packed public uint Packed Field Value uint PairId public int PairId Field Value int Properties ChildIndex public int ChildIndex { get; } Property Value int Index public int Index { get; } Property Value int Type public CollisionContinuationType Type { get; } Property Value CollisionContinuationType"
  },
  "api/BepuPhysics.CollisionDetection.PairMaterialProperties.html": {
    "href": "api/BepuPhysics.CollisionDetection.PairMaterialProperties.html",
    "title": "Struct PairMaterialProperties | Bepu API",
    "keywords": "Struct PairMaterialProperties Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Material properties governing the interaction between colliding bodies. Used by the narrow phase to create constraints of the appropriate configuration. public struct PairMaterialProperties Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors PairMaterialProperties(float, float, SpringSettings) Constructs a pair's material properties. public PairMaterialProperties(float frictionCoefficient, float maximumRecoveryVelocity, SpringSettings springSettings) Parameters frictionCoefficient float Coefficient of friction to apply for the constraint. Maximum friction force will be equal to the normal force times the friction coefficient. maximumRecoveryVelocity float Maximum relative velocity along the contact normal at which the collision constraint will recover from penetration. Clamps the velocity goal created from the spring settings. springSettings SpringSettings Defines the constraint's penetration recovery spring properties. Fields FrictionCoefficient Coefficient of friction to apply for the constraint. Maximum friction force will be equal to the normal force times the friction coefficient. public float FrictionCoefficient Field Value float MaximumRecoveryVelocity Maximum relative velocity along the contact normal at which the collision constraint will recover from penetration. Clamps the velocity goal created from the spring settings. public float MaximumRecoveryVelocity Field Value float SpringSettings Defines the constraint's penetration recovery spring properties. public SpringSettings SpringSettings Field Value SpringSettings"
  },
  "api/BepuPhysics.CollisionDetection.SimulationRayBatcher-1.html": {
    "href": "api/BepuPhysics.CollisionDetection.SimulationRayBatcher-1.html",
    "title": "Struct SimulationRayBatcher<TRayHitHandler> | Bepu API",
    "keywords": "Struct SimulationRayBatcher<TRayHitHandler> Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Tests batches of rays against the simulation. public struct SimulationRayBatcher<TRayHitHandler> : IDisposable where TRayHitHandler : struct, IRayHitHandler Type Parameters TRayHitHandler Type used to handle hits against objects in the simulation. Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors SimulationRayBatcher(BufferPool, Simulation, TRayHitHandler, int) public SimulationRayBatcher(BufferPool pool, Simulation simulation, TRayHitHandler hitHandler, int batcherRayCapacity = 2048) Parameters pool BufferPool simulation Simulation hitHandler TRayHitHandler batcherRayCapacity int Methods Add(ref Vector3, ref Vector3, float, int) Adds a ray to the batcher to test against the simulation. If the underlying ray batcher hits its maximum capacity, all the accumulated rays will be tested against the simulation and the accumulator will be reset. public void Add(ref Vector3 origin, ref Vector3 direction, float maximumT, int id = 0) Parameters origin Vector3 Origin of the ray to test against the simulation. direction Vector3 Direction of the ray to test against the simulation. maximumT float Maximum distance that the ray will travel in units of the ray's length. id int Identifier value for the ray. Callbacks will have access to the id. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Flush() Tests any accumulated rays against the broad phase trees and then resets the batcher. public void Flush()"
  },
  "api/BepuPhysics.CollisionDetection.SweepTask.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTask.html",
    "title": "Class SweepTask | Bepu API",
    "keywords": "Class SweepTask Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public abstract class SweepTask Inheritance object SweepTask Derived CompoundHomogeneousCompoundSweepTask<TCompoundA, TCompoundB, TChildShapeB, TChildShapeWideB, TOverlapFinder> CompoundPairSweepTask<TCompoundA, TCompoundB, TOverlapFinder> ConvexCompoundSweepTask<TShapeA, TShapeWideA, TCompound, TOverlapFinder> ConvexHomogeneousCompoundSweepTask<TConvex, TConvexWide, TCompound, TChildType, TChildTypeWide, TOverlapFinder> ConvexPairSweepTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPairDistanceTester> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ShapeTypeIndexA Gets the first shape type index associated with the task. public int ShapeTypeIndexA { get; protected set; } Property Value int ShapeTypeIndexB Gets the second shape type index associated with the task. public int ShapeTypeIndexB { get; protected set; } Property Value int Methods PreorderedTypeSweep(void*, in RigidPose, Quaternion, in BodyVelocity, void*, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) protected abstract bool PreorderedTypeSweep(void* shapeDataA, in RigidPose localPoseA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, in RigidPose localPoseB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) Parameters shapeDataA void* localPoseA RigidPose orientationA Quaternion velocityA BodyVelocity shapeDataB void* localPoseB RigidPose offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool PreorderedTypeSweep<TSweepFilter>(void*, Quaternion, in BodyVelocity, void*, Vector3, Quaternion, in BodyVelocity, float, float, float, int, bool, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) protected abstract bool PreorderedTypeSweep<TSweepFilter>(void* shapeDataA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, bool flipRequired, ref TSweepFilter filter, Shapes shapes, SweepTaskRegistry sweepTasks, BufferPool pool, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) where TSweepFilter : ISweepFilter Parameters shapeDataA void* orientationA Quaternion velocityA BodyVelocity shapeDataB void* offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int flipRequired bool filter TSweepFilter shapes Shapes sweepTasks SweepTaskRegistry pool BufferPool t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool Type Parameters TSweepFilter Sweep(void*, int, in RigidPose, Quaternion, in BodyVelocity, void*, int, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) public bool Sweep(void* shapeDataA, int shapeTypeA, in RigidPose localPoseA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, int shapeTypeB, in RigidPose localPoseB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) Parameters shapeDataA void* shapeTypeA int localPoseA RigidPose orientationA Quaternion velocityA BodyVelocity shapeDataB void* shapeTypeB int localPoseB RigidPose offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool Sweep<TSweepFilter>(void*, int, Quaternion, in BodyVelocity, void*, int, Vector3, Quaternion, in BodyVelocity, float, float, float, int, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) public bool Sweep<TSweepFilter>(void* shapeDataA, int shapeTypeA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, int shapeTypeB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, ref TSweepFilter filter, Shapes shapes, SweepTaskRegistry sweepTasks, BufferPool pool, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) where TSweepFilter : ISweepFilter Parameters shapeDataA void* shapeTypeA int orientationA Quaternion velocityA BodyVelocity shapeDataB void* shapeTypeB int offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int filter TSweepFilter shapes Shapes sweepTasks SweepTaskRegistry pool BufferPool t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool Type Parameters TSweepFilter"
  },
  "api/BepuPhysics.CollisionDetection.SweepTaskRegistry.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTaskRegistry.html",
    "title": "Class SweepTaskRegistry | Bepu API",
    "keywords": "Class SweepTaskRegistry Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public class SweepTaskRegistry Inheritance object SweepTaskRegistry Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SweepTaskRegistry(int) public SweepTaskRegistry(int initialShapeCount = 9) Parameters initialShapeCount int Properties this[int] public SweepTask this[int taskIndex] { get; } Parameters taskIndex int Property Value SweepTask Methods GetTask(int, int) public SweepTask GetTask(int topLevelTypeA, int topLevelTypeB) Parameters topLevelTypeA int topLevelTypeB int Returns SweepTask GetTask<TShapeA, TShapeB>() public SweepTask GetTask<TShapeA, TShapeB>() where TShapeA : unmanaged, IShape where TShapeB : unmanaged, IShape Returns SweepTask Type Parameters TShapeA TShapeB Register(SweepTask) public int Register(SweepTask task) Parameters task SweepTask Returns int"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.CapsuleBoxDistanceTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.CapsuleBoxDistanceTester.html",
    "title": "Struct CapsuleBoxDistanceTester | Bepu API",
    "keywords": "Struct CapsuleBoxDistanceTester Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct CapsuleBoxDistanceTester : IPairDistanceTester<CapsuleWide, BoxWide> Implements IPairDistanceTester<CapsuleWide, BoxWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Test(in CapsuleWide, in BoxWide, in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector<int>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide) public void Test(in CapsuleWide a, in BoxWide b, in Vector3Wide offsetB, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector<int> inactiveLanes, out Vector<int> intersected, out Vector<float> distance, out Vector3Wide closestA, out Vector3Wide normal) Parameters a CapsuleWide b BoxWide offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide inactiveLanes Vector<int> intersected Vector<int> distance Vector<float> closestA Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.CapsulePairDistanceTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.CapsulePairDistanceTester.html",
    "title": "Struct CapsulePairDistanceTester | Bepu API",
    "keywords": "Struct CapsulePairDistanceTester Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct CapsulePairDistanceTester : IPairDistanceTester<CapsuleWide, CapsuleWide> Implements IPairDistanceTester<CapsuleWide, CapsuleWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Test(in CapsuleWide, in CapsuleWide, in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector<int>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide) public void Test(in CapsuleWide a, in CapsuleWide b, in Vector3Wide offsetB, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector<int> inactiveLanes, out Vector<int> intersected, out Vector<float> distance, out Vector3Wide closestA, out Vector3Wide normal) Parameters a CapsuleWide b CapsuleWide offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide inactiveLanes Vector<int> intersected Vector<int> distance Vector<float> closestA Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.CompoundHomogeneousCompoundSweepTask-5.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.CompoundHomogeneousCompoundSweepTask-5.html",
    "title": "Class CompoundHomogeneousCompoundSweepTask<TCompoundA, TCompoundB, TChildShapeB, TChildShapeWideB, TOverlapFinder> | Bepu API",
    "keywords": "Class CompoundHomogeneousCompoundSweepTask<TCompoundA, TCompoundB, TChildShapeB, TChildShapeWideB, TOverlapFinder> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public class CompoundHomogeneousCompoundSweepTask<TCompoundA, TCompoundB, TChildShapeB, TChildShapeWideB, TOverlapFinder> : SweepTask where TCompoundA : unmanaged, ICompoundShape where TCompoundB : unmanaged, IHomogeneousCompoundShape<TChildShapeB, TChildShapeWideB> where TChildShapeB : unmanaged, IConvexShape where TChildShapeWideB : unmanaged, IShapeWide<TChildShapeB> where TOverlapFinder : struct, ICompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> Type Parameters TCompoundA TCompoundB TChildShapeB TChildShapeWideB TOverlapFinder Inheritance object SweepTask CompoundHomogeneousCompoundSweepTask<TCompoundA, TCompoundB, TChildShapeB, TChildShapeWideB, TOverlapFinder> Inherited Members SweepTask.ShapeTypeIndexA SweepTask.ShapeTypeIndexB SweepTask.Sweep(void*, int, in RigidPose, Quaternion, in BodyVelocity, void*, int, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) SweepTask.Sweep<TSweepFilter>(void*, int, Quaternion, in BodyVelocity, void*, int, Vector3, Quaternion, in BodyVelocity, float, float, float, int, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CompoundHomogeneousCompoundSweepTask() public CompoundHomogeneousCompoundSweepTask() Methods PreorderedTypeSweep(void*, in RigidPose, Quaternion, in BodyVelocity, void*, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep(void* shapeDataA, in RigidPose localPoseA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, in RigidPose localPoseB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) Parameters shapeDataA void* localPoseA RigidPose orientationA Quaternion velocityA BodyVelocity shapeDataB void* localPoseB RigidPose offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool PreorderedTypeSweep<TSweepFilter>(void*, Quaternion, in BodyVelocity, void*, Vector3, Quaternion, in BodyVelocity, float, float, float, int, bool, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep<TSweepFilter>(void* shapeDataA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, bool flipRequired, ref TSweepFilter filter, Shapes shapes, SweepTaskRegistry sweepTasks, BufferPool pool, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) where TSweepFilter : ISweepFilter Parameters shapeDataA void* orientationA Quaternion velocityA BodyVelocity shapeDataB void* offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int flipRequired bool filter TSweepFilter shapes Shapes sweepTasks SweepTaskRegistry pool BufferPool t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool Type Parameters TSweepFilter"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.CompoundPairSweepOverlapFinder-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.CompoundPairSweepOverlapFinder-2.html",
    "title": "Struct CompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> | Bepu API",
    "keywords": "Struct CompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct CompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> : ICompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> where TCompoundA : struct, ICompoundShape where TCompoundB : struct, IBoundsQueryableCompound Type Parameters TCompoundA TCompoundB Implements ICompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods FindOverlaps(ref TCompoundA, Quaternion, in BodyVelocity, ref TCompoundB, Vector3, Quaternion, in BodyVelocity, float, Shapes, BufferPool, out CompoundPairSweepOverlaps) public static void FindOverlaps(ref TCompoundA compoundA, Quaternion orientationA, in BodyVelocity velocityA, ref TCompoundB compoundB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, Shapes shapes, BufferPool pool, out CompoundPairSweepOverlaps overlaps) Parameters compoundA TCompoundA orientationA Quaternion velocityA BodyVelocity compoundB TCompoundB offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float shapes Shapes pool BufferPool overlaps CompoundPairSweepOverlaps"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.CompoundPairSweepOverlaps.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.CompoundPairSweepOverlaps.html",
    "title": "Struct CompoundPairSweepOverlaps | Bepu API",
    "keywords": "Struct CompoundPairSweepOverlaps Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct CompoundPairSweepOverlaps Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CompoundPairSweepOverlaps(BufferPool, int) public CompoundPairSweepOverlaps(BufferPool pool, int childCount) Parameters pool BufferPool childCount int Fields ChildCount public readonly int ChildCount Field Value int Methods Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool GetOverlapsForChild(int) public ref ChildOverlapsCollection GetOverlapsForChild(int pairIndex) Parameters pairIndex int Returns ChildOverlapsCollection"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.CompoundPairSweepTask-3.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.CompoundPairSweepTask-3.html",
    "title": "Class CompoundPairSweepTask<TCompoundA, TCompoundB, TOverlapFinder> | Bepu API",
    "keywords": "Class CompoundPairSweepTask<TCompoundA, TCompoundB, TOverlapFinder> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public class CompoundPairSweepTask<TCompoundA, TCompoundB, TOverlapFinder> : SweepTask where TCompoundA : unmanaged, ICompoundShape where TCompoundB : unmanaged, ICompoundShape where TOverlapFinder : struct, ICompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> Type Parameters TCompoundA TCompoundB TOverlapFinder Inheritance object SweepTask CompoundPairSweepTask<TCompoundA, TCompoundB, TOverlapFinder> Inherited Members SweepTask.ShapeTypeIndexA SweepTask.ShapeTypeIndexB SweepTask.Sweep(void*, int, in RigidPose, Quaternion, in BodyVelocity, void*, int, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) SweepTask.Sweep<TSweepFilter>(void*, int, Quaternion, in BodyVelocity, void*, int, Vector3, Quaternion, in BodyVelocity, float, float, float, int, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CompoundPairSweepTask() public CompoundPairSweepTask() Methods PreorderedTypeSweep(void*, in RigidPose, Quaternion, in BodyVelocity, void*, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep(void* shapeDataA, in RigidPose localPoseA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, in RigidPose localPoseB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) Parameters shapeDataA void* localPoseA RigidPose orientationA Quaternion velocityA BodyVelocity shapeDataB void* localPoseB RigidPose offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool PreorderedTypeSweep<TSweepFilter>(void*, Quaternion, in BodyVelocity, void*, Vector3, Quaternion, in BodyVelocity, float, float, float, int, bool, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep<TSweepFilter>(void* shapeDataA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, bool flipRequired, ref TSweepFilter filter, Shapes shapes, SweepTaskRegistry sweepTasks, BufferPool pool, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) where TSweepFilter : ISweepFilter Parameters shapeDataA void* orientationA Quaternion velocityA BodyVelocity shapeDataB void* offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int flipRequired bool filter TSweepFilter shapes Shapes sweepTasks SweepTaskRegistry pool BufferPool t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool Type Parameters TSweepFilter"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.ConvexCompoundSweepOverlapFinder-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.ConvexCompoundSweepOverlapFinder-2.html",
    "title": "Struct ConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> | Bepu API",
    "keywords": "Struct ConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct ConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> : IConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> where TShapeA : struct, IConvexShape where TCompoundB : struct, IBoundsQueryableCompound Type Parameters TShapeA TCompoundB Implements IConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods FindOverlaps(ref TShapeA, Quaternion, in BodyVelocity, ref TCompoundB, Vector3, Quaternion, in BodyVelocity, float, Shapes, BufferPool, out ChildOverlapsCollection) public static void FindOverlaps(ref TShapeA shapeA, Quaternion orientationA, in BodyVelocity velocityA, ref TCompoundB compoundB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, Shapes shapes, BufferPool pool, out ChildOverlapsCollection overlaps) Parameters shapeA TShapeA orientationA Quaternion velocityA BodyVelocity compoundB TCompoundB offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float shapes Shapes pool BufferPool overlaps ChildOverlapsCollection"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.ConvexCompoundSweepTask-4.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.ConvexCompoundSweepTask-4.html",
    "title": "Class ConvexCompoundSweepTask<TShapeA, TShapeWideA, TCompound, TOverlapFinder> | Bepu API",
    "keywords": "Class ConvexCompoundSweepTask<TShapeA, TShapeWideA, TCompound, TOverlapFinder> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public class ConvexCompoundSweepTask<TShapeA, TShapeWideA, TCompound, TOverlapFinder> : SweepTask where TShapeA : unmanaged, IConvexShape where TShapeWideA : unmanaged, IShapeWide<TShapeA> where TCompound : unmanaged, ICompoundShape where TOverlapFinder : struct, IConvexCompoundSweepOverlapFinder<TShapeA, TCompound> Type Parameters TShapeA TShapeWideA TCompound TOverlapFinder Inheritance object SweepTask ConvexCompoundSweepTask<TShapeA, TShapeWideA, TCompound, TOverlapFinder> Inherited Members SweepTask.ShapeTypeIndexA SweepTask.ShapeTypeIndexB SweepTask.Sweep(void*, int, in RigidPose, Quaternion, in BodyVelocity, void*, int, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) SweepTask.Sweep<TSweepFilter>(void*, int, Quaternion, in BodyVelocity, void*, int, Vector3, Quaternion, in BodyVelocity, float, float, float, int, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConvexCompoundSweepTask() public ConvexCompoundSweepTask() Methods PreorderedTypeSweep(void*, in RigidPose, Quaternion, in BodyVelocity, void*, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep(void* shapeDataA, in RigidPose localPoseA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, in RigidPose localPoseB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) Parameters shapeDataA void* localPoseA RigidPose orientationA Quaternion velocityA BodyVelocity shapeDataB void* localPoseB RigidPose offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool PreorderedTypeSweep<TSweepFilter>(void*, Quaternion, in BodyVelocity, void*, Vector3, Quaternion, in BodyVelocity, float, float, float, int, bool, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep<TSweepFilter>(void* shapeDataA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, bool flipRequired, ref TSweepFilter filter, Shapes shapes, SweepTaskRegistry sweepTasks, BufferPool pool, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) where TSweepFilter : ISweepFilter Parameters shapeDataA void* orientationA Quaternion velocityA BodyVelocity shapeDataB void* offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int flipRequired bool filter TSweepFilter shapes Shapes sweepTasks SweepTaskRegistry pool BufferPool t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool Type Parameters TSweepFilter"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.ConvexHomogeneousCompoundSweepTask-6.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.ConvexHomogeneousCompoundSweepTask-6.html",
    "title": "Class ConvexHomogeneousCompoundSweepTask<TConvex, TConvexWide, TCompound, TChildType, TChildTypeWide, TOverlapFinder> | Bepu API",
    "keywords": "Class ConvexHomogeneousCompoundSweepTask<TConvex, TConvexWide, TCompound, TChildType, TChildTypeWide, TOverlapFinder> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public class ConvexHomogeneousCompoundSweepTask<TConvex, TConvexWide, TCompound, TChildType, TChildTypeWide, TOverlapFinder> : SweepTask where TConvex : unmanaged, IConvexShape where TConvexWide : unmanaged, IShapeWide<TConvex> where TCompound : unmanaged, IHomogeneousCompoundShape<TChildType, TChildTypeWide> where TChildType : unmanaged, IConvexShape where TChildTypeWide : unmanaged, IShapeWide<TChildType> where TOverlapFinder : struct, IConvexCompoundSweepOverlapFinder<TConvex, TCompound> Type Parameters TConvex TConvexWide TCompound TChildType TChildTypeWide TOverlapFinder Inheritance object SweepTask ConvexHomogeneousCompoundSweepTask<TConvex, TConvexWide, TCompound, TChildType, TChildTypeWide, TOverlapFinder> Inherited Members SweepTask.ShapeTypeIndexA SweepTask.ShapeTypeIndexB SweepTask.Sweep(void*, int, in RigidPose, Quaternion, in BodyVelocity, void*, int, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) SweepTask.Sweep<TSweepFilter>(void*, int, Quaternion, in BodyVelocity, void*, int, Vector3, Quaternion, in BodyVelocity, float, float, float, int, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConvexHomogeneousCompoundSweepTask() public ConvexHomogeneousCompoundSweepTask() Methods PreorderedTypeSweep(void*, in RigidPose, Quaternion, in BodyVelocity, void*, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep(void* shapeDataA, in RigidPose localPoseA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, in RigidPose localPoseB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) Parameters shapeDataA void* localPoseA RigidPose orientationA Quaternion velocityA BodyVelocity shapeDataB void* localPoseB RigidPose offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool PreorderedTypeSweep<TSweepFilter>(void*, Quaternion, in BodyVelocity, void*, Vector3, Quaternion, in BodyVelocity, float, float, float, int, bool, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep<TSweepFilter>(void* shapeDataA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, bool flipRequired, ref TSweepFilter filter, Shapes shapes, SweepTaskRegistry sweepTasks, BufferPool pool, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) where TSweepFilter : ISweepFilter Parameters shapeDataA void* orientationA Quaternion velocityA BodyVelocity shapeDataB void* offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int flipRequired bool filter TSweepFilter shapes Shapes sweepTasks SweepTaskRegistry pool BufferPool t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool Type Parameters TSweepFilter"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.ConvexPairSweepTask-5.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.ConvexPairSweepTask-5.html",
    "title": "Class ConvexPairSweepTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPairDistanceTester> | Bepu API",
    "keywords": "Class ConvexPairSweepTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPairDistanceTester> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public class ConvexPairSweepTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPairDistanceTester> : SweepTask where TShapeA : unmanaged, IConvexShape where TShapeWideA : unmanaged, IShapeWide<TShapeA> where TShapeB : unmanaged, IConvexShape where TShapeWideB : unmanaged, IShapeWide<TShapeB> where TPairDistanceTester : struct, IPairDistanceTester<TShapeWideA, TShapeWideB> Type Parameters TShapeA TShapeWideA TShapeB TShapeWideB TPairDistanceTester Inheritance object SweepTask ConvexPairSweepTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPairDistanceTester> Inherited Members SweepTask.ShapeTypeIndexA SweepTask.ShapeTypeIndexB SweepTask.Sweep(void*, int, in RigidPose, Quaternion, in BodyVelocity, void*, int, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) SweepTask.Sweep<TSweepFilter>(void*, int, Quaternion, in BodyVelocity, void*, int, Vector3, Quaternion, in BodyVelocity, float, float, float, int, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ConvexPairSweepTask() public ConvexPairSweepTask() Methods PreorderedTypeSweep(void*, in RigidPose, Quaternion, in BodyVelocity, void*, in RigidPose, Vector3, Quaternion, in BodyVelocity, float, float, float, int, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep(void* shapeDataA, in RigidPose localPoseA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, in RigidPose localPoseB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) Parameters shapeDataA void* localPoseA RigidPose orientationA Quaternion velocityA BodyVelocity shapeDataB void* localPoseB RigidPose offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool PreorderedTypeSweep<TSweepFilter>(void*, Quaternion, in BodyVelocity, void*, Vector3, Quaternion, in BodyVelocity, float, float, float, int, bool, ref TSweepFilter, Shapes, SweepTaskRegistry, BufferPool, out float, out float, out Vector3, out Vector3) protected override bool PreorderedTypeSweep<TSweepFilter>(void* shapeDataA, Quaternion orientationA, in BodyVelocity velocityA, void* shapeDataB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, float minimumProgression, float convergenceThreshold, int maximumIterationCount, bool requiresFlip, ref TSweepFilter filter, Shapes shapes, SweepTaskRegistry sweepTasks, BufferPool pool, out float t0, out float t1, out Vector3 hitLocation, out Vector3 hitNormal) where TSweepFilter : ISweepFilter Parameters shapeDataA void* orientationA Quaternion velocityA BodyVelocity shapeDataB void* offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float minimumProgression float convergenceThreshold float maximumIterationCount int requiresFlip bool filter TSweepFilter shapes Shapes sweepTasks SweepTaskRegistry pool BufferPool t0 float t1 float hitLocation Vector3 hitNormal Vector3 Returns bool Type Parameters TSweepFilter"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.GJKDistanceTester-6.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.GJKDistanceTester-6.html",
    "title": "Struct GJKDistanceTester<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB> | Bepu API",
    "keywords": "Struct GJKDistanceTester<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct GJKDistanceTester<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB> : IPairDistanceTester<TShapeWideA, TShapeWideB> where TShapeA : unmanaged, IConvexShape where TShapeWideA : unmanaged, IShapeWide<TShapeA> where TSupportFinderA : struct, ISupportFinder<TShapeA, TShapeWideA> where TShapeB : unmanaged, IConvexShape where TShapeWideB : unmanaged, IShapeWide<TShapeB> where TSupportFinderB : struct, ISupportFinder<TShapeB, TShapeWideB> Type Parameters TShapeA TShapeWideA TSupportFinderA TShapeB TShapeWideB TSupportFinderB Implements IPairDistanceTester<TShapeWideA, TShapeWideB> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ContainmentEpsilon public float ContainmentEpsilon Field Value float ContainmentEpsilonDefault public const float ContainmentEpsilonDefault = 0.00031622776 Field Value float TerminationEpsilon public float TerminationEpsilon Field Value float TerminationEpsilonDefault public const float TerminationEpsilonDefault = 1E-07 Field Value float Methods Test(in TShapeWideA, in TShapeWideB, in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector<int>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide) public void Test(in TShapeWideA a, in TShapeWideB b, in Vector3Wide offsetB, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector<int> inactiveLanes, out Vector<int> intersected, out Vector<float> distance, out Vector3Wide closestA, out Vector3Wide normal) Parameters a TShapeWideA b TShapeWideB offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide inactiveLanes Vector<int> intersected Vector<int> distance Vector<float> closestA Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.ICompoundPairSweepOverlapFinder-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.ICompoundPairSweepOverlapFinder-2.html",
    "title": "Interface ICompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> | Bepu API",
    "keywords": "Interface ICompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public interface ICompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> where TCompoundA : struct, ICompoundShape where TCompoundB : struct, IBoundsQueryableCompound Type Parameters TCompoundA TCompoundB Methods FindOverlaps(ref TCompoundA, Quaternion, in BodyVelocity, ref TCompoundB, Vector3, Quaternion, in BodyVelocity, float, Shapes, BufferPool, out CompoundPairSweepOverlaps) public static abstract void FindOverlaps(ref TCompoundA compoundA, Quaternion orientationA, in BodyVelocity velocityA, ref TCompoundB compoundB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, Shapes shapes, BufferPool pool, out CompoundPairSweepOverlaps overlaps) Parameters compoundA TCompoundA orientationA Quaternion velocityA BodyVelocity compoundB TCompoundB offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float shapes Shapes pool BufferPool overlaps CompoundPairSweepOverlaps"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.IConvexCompoundSweepOverlapFinder-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.IConvexCompoundSweepOverlapFinder-2.html",
    "title": "Interface IConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> | Bepu API",
    "keywords": "Interface IConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public interface IConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> where TShapeA : struct, IConvexShape where TCompoundB : struct, IBoundsQueryableCompound Type Parameters TShapeA TCompoundB Methods FindOverlaps(ref TShapeA, Quaternion, in BodyVelocity, ref TCompoundB, Vector3, Quaternion, in BodyVelocity, float, Shapes, BufferPool, out ChildOverlapsCollection) public static abstract void FindOverlaps(ref TShapeA shapeA, Quaternion orientationA, in BodyVelocity velocityA, ref TCompoundB compoundB, Vector3 offsetB, Quaternion orientationB, in BodyVelocity velocityB, float maximumT, Shapes shapes, BufferPool pool, out ChildOverlapsCollection overlaps) Parameters shapeA TShapeA orientationA Quaternion velocityA BodyVelocity compoundB TCompoundB offsetB Vector3 orientationB Quaternion velocityB BodyVelocity maximumT float shapes Shapes pool BufferPool overlaps ChildOverlapsCollection"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.IPairDistanceTester-2.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.IPairDistanceTester-2.html",
    "title": "Interface IPairDistanceTester<TShapeWideA, TShapeWideB> | Bepu API",
    "keywords": "Interface IPairDistanceTester<TShapeWideA, TShapeWideB> Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public interface IPairDistanceTester<TShapeWideA, TShapeWideB> Type Parameters TShapeWideA TShapeWideB Methods Test(in TShapeWideA, in TShapeWideB, in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector<int>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide) void Test(in TShapeWideA a, in TShapeWideB b, in Vector3Wide offsetB, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector<int> inactiveLanes, out Vector<int> intersected, out Vector<float> distance, out Vector3Wide closestA, out Vector3Wide normal) Parameters a TShapeWideA b TShapeWideB offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide inactiveLanes Vector<int> intersected Vector<int> distance Vector<float> closestA Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.SphereBoxDistanceTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.SphereBoxDistanceTester.html",
    "title": "Struct SphereBoxDistanceTester | Bepu API",
    "keywords": "Struct SphereBoxDistanceTester Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct SphereBoxDistanceTester : IPairDistanceTester<SphereWide, BoxWide> Implements IPairDistanceTester<SphereWide, BoxWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Test(in SphereWide, in BoxWide, in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector<int>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide) public void Test(in SphereWide a, in BoxWide b, in Vector3Wide offsetB, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector<int> inactiveLanes, out Vector<int> intersected, out Vector<float> distance, out Vector3Wide closestA, out Vector3Wide normal) Parameters a SphereWide b BoxWide offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide inactiveLanes Vector<int> intersected Vector<int> distance Vector<float> closestA Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.SphereCapsuleDistanceTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.SphereCapsuleDistanceTester.html",
    "title": "Struct SphereCapsuleDistanceTester | Bepu API",
    "keywords": "Struct SphereCapsuleDistanceTester Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct SphereCapsuleDistanceTester : IPairDistanceTester<SphereWide, CapsuleWide> Implements IPairDistanceTester<SphereWide, CapsuleWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Test(in SphereWide, in CapsuleWide, in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector<int>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide) public void Test(in SphereWide a, in CapsuleWide b, in Vector3Wide offsetB, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector<int> inactiveLanes, out Vector<int> intersected, out Vector<float> distance, out Vector3Wide closestA, out Vector3Wide normal) Parameters a SphereWide b CapsuleWide offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide inactiveLanes Vector<int> intersected Vector<int> distance Vector<float> closestA Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.SphereCylinderDistanceTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.SphereCylinderDistanceTester.html",
    "title": "Struct SphereCylinderDistanceTester | Bepu API",
    "keywords": "Struct SphereCylinderDistanceTester Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct SphereCylinderDistanceTester : IPairDistanceTester<SphereWide, CylinderWide> Implements IPairDistanceTester<SphereWide, CylinderWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Test(in SphereWide, in CylinderWide, in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector<int>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide) public void Test(in SphereWide a, in CylinderWide b, in Vector3Wide offsetB, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector<int> inactiveLanes, out Vector<int> intersected, out Vector<float> distance, out Vector3Wide closestA, out Vector3Wide normal) Parameters a SphereWide b CylinderWide offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide inactiveLanes Vector<int> intersected Vector<int> distance Vector<float> closestA Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.SpherePairDistanceTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.SpherePairDistanceTester.html",
    "title": "Struct SpherePairDistanceTester | Bepu API",
    "keywords": "Struct SpherePairDistanceTester Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct SpherePairDistanceTester : IPairDistanceTester<SphereWide, SphereWide> Implements IPairDistanceTester<SphereWide, SphereWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Test(in SphereWide, in SphereWide, in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector<int>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide) public void Test(in SphereWide a, in SphereWide b, in Vector3Wide offsetB, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector<int> inactiveLanes, out Vector<int> intersected, out Vector<float> distance, out Vector3Wide closestA, out Vector3Wide normal) Parameters a SphereWide b SphereWide offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide inactiveLanes Vector<int> intersected Vector<int> distance Vector<float> closestA Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.SphereTriangleDistanceTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.SphereTriangleDistanceTester.html",
    "title": "Struct SphereTriangleDistanceTester | Bepu API",
    "keywords": "Struct SphereTriangleDistanceTester Namespace BepuPhysics.CollisionDetection.SweepTasks Assembly BepuPhysics.dll public struct SphereTriangleDistanceTester : IPairDistanceTester<SphereWide, TriangleWide> Implements IPairDistanceTester<SphereWide, TriangleWide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Test(in SphereWide, in TriangleWide, in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector<int>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide) public void Test(in SphereWide a, in TriangleWide b, in Vector3Wide offsetB, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector<int> inactiveLanes, out Vector<int> intersected, out Vector<float> distance, out Vector3Wide closestA, out Vector3Wide normal) Parameters a SphereWide b TriangleWide offsetB Vector3Wide orientationA QuaternionWide orientationB QuaternionWide inactiveLanes Vector<int> intersected Vector<int> distance Vector<float> closestA Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.CollisionDetection.SweepTasks.html": {
    "href": "api/BepuPhysics.CollisionDetection.SweepTasks.html",
    "title": "Namespace BepuPhysics.CollisionDetection.SweepTasks | Bepu API",
    "keywords": "Namespace BepuPhysics.CollisionDetection.SweepTasks Classes CompoundHomogeneousCompoundSweepTask<TCompoundA, TCompoundB, TChildShapeB, TChildShapeWideB, TOverlapFinder> CompoundPairSweepTask<TCompoundA, TCompoundB, TOverlapFinder> ConvexCompoundSweepTask<TShapeA, TShapeWideA, TCompound, TOverlapFinder> ConvexHomogeneousCompoundSweepTask<TConvex, TConvexWide, TCompound, TChildType, TChildTypeWide, TOverlapFinder> ConvexPairSweepTask<TShapeA, TShapeWideA, TShapeB, TShapeWideB, TPairDistanceTester> Structs CapsuleBoxDistanceTester CapsulePairDistanceTester CompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> CompoundPairSweepOverlaps ConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> GJKDistanceTester<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB> SphereBoxDistanceTester SphereCapsuleDistanceTester SphereCylinderDistanceTester SpherePairDistanceTester SphereTriangleDistanceTester Interfaces ICompoundPairSweepOverlapFinder<TCompoundA, TCompoundB> IConvexCompoundSweepOverlapFinder<TShapeA, TCompoundB> IPairDistanceTester<TShapeWideA, TShapeWideB>"
  },
  "api/BepuPhysics.CollisionDetection.TwoBodyHandles.html": {
    "href": "api/BepuPhysics.CollisionDetection.TwoBodyHandles.html",
    "title": "Struct TwoBodyHandles | Bepu API",
    "keywords": "Struct TwoBodyHandles Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Associated with a pair of two collidables that each are controlled by bodies. public struct TwoBodyHandles Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public int A Field Value int B public int B Field Value int"
  },
  "api/BepuPhysics.CollisionDetection.UntypedList.html": {
    "href": "api/BepuPhysics.CollisionDetection.UntypedList.html",
    "title": "Struct UntypedList | Bepu API",
    "keywords": "Struct UntypedList Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct UntypedList Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors UntypedList(int, int, BufferPool) public UntypedList(int elementSizeInBytes, int initialCapacityInElements, BufferPool pool) Parameters elementSizeInBytes int initialCapacityInElements int pool BufferPool Fields Buffer public Buffer<byte> Buffer Field Value Buffer<byte> ByteCount public int ByteCount Field Value int Count public int Count Field Value int ElementSizeInBytes public int ElementSizeInBytes Field Value int Methods Add<T>(ref T, int, BufferPool) public int Add<T>(ref T data, int minimumCount, BufferPool pool) Parameters data T minimumCount int pool BufferPool Returns int Type Parameters T Allocate(int, int, BufferPool) Allocates an element in the list, initializing the backing buffer if needed. public int Allocate(int elementSizeInBytes, int minimumElementCount, BufferPool pool) Parameters elementSizeInBytes int Number of bytes per element. minimumElementCount int Minimum size of the backing buffer to create if this is a new allocation. pool BufferPool Pool to pull allocations from. Returns int Index of the element in bytes within the list's buffer. AllocateUnsafely() public byte* AllocateUnsafely() Returns byte* AllocateUnsafely<T>() public ref T AllocateUnsafely<T>() Returns T Type Parameters T Allocate<T>(int, BufferPool) public int Allocate<T>(int minimumElementCount, BufferPool pool) Parameters minimumElementCount int pool BufferPool Returns int Type Parameters T GetFromBytes<T>(int) public ref T GetFromBytes<T>(int byteIndex) Parameters byteIndex int Returns T Type Parameters T Get<T>(int) public ref T Get<T>(int index) Parameters index int Returns T Type Parameters T"
  },
  "api/BepuPhysics.CollisionDetection.WideRayTester.html": {
    "href": "api/BepuPhysics.CollisionDetection.WideRayTester.html",
    "title": "Class WideRayTester | Bepu API",
    "keywords": "Class WideRayTester Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Helper class for creating runtime specialized vectorized ray intersection tests with shapes that support broadcasting. public static class WideRayTester Inheritance object WideRayTester Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Test<TRaySource, TShape, TShapeWide, TRayHitHandler>(ref TShape, in RigidPose, ref TRaySource, ref TRayHitHandler) public static void Test<TRaySource, TShape, TShapeWide, TRayHitHandler>(ref TShape shape, in RigidPose pose, ref TRaySource raySource, ref TRayHitHandler rayHitHandler) where TRaySource : IRaySource where TShape : unmanaged, IConvexShape where TShapeWide : unmanaged, IShapeWide<TShape> where TRayHitHandler : struct, IShapeRayHitHandler Parameters shape TShape pose RigidPose raySource TRaySource rayHitHandler TRayHitHandler Type Parameters TRaySource TShape TShapeWide TRayHitHandler"
  },
  "api/BepuPhysics.CollisionDetection.WorkerPendingPairChanges.PendingAdd.html": {
    "href": "api/BepuPhysics.CollisionDetection.WorkerPendingPairChanges.PendingAdd.html",
    "title": "Struct WorkerPendingPairChanges.PendingAdd | Bepu API",
    "keywords": "Struct WorkerPendingPairChanges.PendingAdd Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll public struct WorkerPendingPairChanges.PendingAdd Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Cache public ConstraintCache Cache Field Value ConstraintCache Pair public CollidablePair Pair Field Value CollidablePair"
  },
  "api/BepuPhysics.CollisionDetection.WorkerPendingPairChanges.html": {
    "href": "api/BepuPhysics.CollisionDetection.WorkerPendingPairChanges.html",
    "title": "Struct WorkerPendingPairChanges | Bepu API",
    "keywords": "Struct WorkerPendingPairChanges Namespace BepuPhysics.CollisionDetection Assembly BepuPhysics.dll Contains the pending pair cache changes created by a single worker during the last execution of narrow phase pair processing. public struct WorkerPendingPairChanges Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors WorkerPendingPairChanges(BufferPool, int) public WorkerPendingPairChanges(BufferPool pool, int pendingCapacity) Parameters pool BufferPool pendingCapacity int Fields PendingAdds The set of pair-pointer associations created by this worker that should be added to the pair mapping. public QuickList<WorkerPendingPairChanges.PendingAdd> PendingAdds Field Value QuickList<WorkerPendingPairChanges.PendingAdd> PendingRemoves The set of pairs to remove from the pair cache generated by the worker. public QuickList<CollidablePair> PendingRemoves Field Value QuickList<CollidablePair> Methods Add(BufferPool, CollidablePair, in ConstraintCache) public int Add(BufferPool pool, CollidablePair pair, in ConstraintCache cache) Parameters pool BufferPool pair CollidablePair cache ConstraintCache Returns int Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool"
  },
  "api/BepuPhysics.CollisionDetection.html": {
    "href": "api/BepuPhysics.CollisionDetection.html",
    "title": "Namespace BepuPhysics.CollisionDetection | Bepu API",
    "keywords": "Namespace BepuPhysics.CollisionDetection Classes BroadPhase Manages scene acceleration structures for collision detection and queries. CollidableOverlapFinder CollidableOverlapFinder<TCallbacks> CollisionTask Parent type of tasks which handle collision tests between batches of shapes of a particular type. CollisionTaskRegistry Registry of collision tasks used to handle various shape pair types. ConstraintRemover Accumulates constraints to remove from multiple threads, and efficiently removes them all as a batch. ContactConstraintAccessor Provides indirection for reading from and updating constraints in the narrow phase. ContactConstraintAccessor<TConstraintDescription, TBodyHandles, TPrestepData, TAccumulatedImpulses, TContactImpulses> ConvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> ConvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB> Incrementally refines a sample direction to approach a local minimum depth between two convex bodies. NarrowPhase NarrowPhase<TCallbacks> Turns broad phase overlaps into contact manifolds and uses them to manage constraints in the solver. NonconvexOneBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> NonconvexTwoBodyAccessor<TConstraintDescription, TPrestepData, TAccumulatedImpulses, TContactImpulses> PairCache SweepTask SweepTaskRegistry WideRayTester Helper class for creating runtime specialized vectorized ray intersection tests with shapes that support broadcasting. Structs BatcherContinuations<T> BroadPhaseRayBatcher<TRayTester> Helps test the broad phase's active and static trees with a custom leaf tester. CCDContinuationIndex CollidablePair CollidablePairComparer CollisionBatcher<TCallbacks> CollisionTaskReference Metadata about a collision task. CompoundMeshReduction ConstraintCache Stores information about a contact constraint from the previous timestep. Contact Information about a single contact. ContactImpulses1 ContactImpulses2 ContactImpulses3 ContactImpulses4 ContactImpulses5 ContactImpulses6 ContactImpulses7 ContactImpulses8 Convex1ContactManifoldWide Convex2ContactManifoldWide Convex4ContactManifoldWide ConvexContact Information about a single contact in a convex collidable pair. Convex collidable pairs share one surface basis across the manifold, since the contact surface is guaranteed to be a plane. ConvexContactManifold Contains the data associated with a convex contact manifold. DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Simplex DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.SimplexWithWitness DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.Vertex DepthRefiner<TShapeA, TShapeWideA, TSupportFinderA, TShapeB, TShapeWideB, TSupportFinderB>.VertexWithWitness MeshReduction NarrowPhaseFlushJob NarrowPhase<TCallbacks>.CollisionCallbacks NarrowPhase<TCallbacks>.OverlapWorker NarrowPhase<TCallbacks>.PendingConstraintAddCache NarrowPhase<TCallbacks>.SortConstraintTarget NonconvexContactManifold Contains the data associated with a nonconvex contact manifold. NonconvexReduction NonconvexReductionChild PairCacheChangeIndex Refers to a change in a PairCache. PairContinuation PairMaterialProperties Material properties governing the interaction between colliding bodies. Used by the narrow phase to create constraints of the appropriate configuration. SimulationRayBatcher<TRayHitHandler> Tests batches of rays against the simulation. TwoBodyHandles Associated with a pair of two collidables that each are controlled by bodies. UntypedList WorkerPendingPairChanges Contains the pending pair cache changes created by a single worker during the last execution of narrow phase pair processing. WorkerPendingPairChanges.PendingAdd Interfaces IBroadPhaseBatchedRayTester IBroadPhaseRayTester IBroadPhaseSweepTester Defines a type that can act as a callback for broad phase sweep tests. ICollisionCallbacks Callbacks invoked by a CollisionBatcher<TCallbacks>. ICollisionTestContinuation Defines a type which includes information necessary to apply some form of post processing to a collision test result. IContactManifold<TManifold> INarrowPhaseCallbacks Defines handlers for narrow phase events. ISupportFinder<TShape, TShapeWide> ISweepFilter Enums CollisionContinuationType Describes the flow control to apply to a convex-convex pair report. CollisionTaskPairType Describes the data requirements for a collision pair type in a CollisionBatcher<TCallbacks>. NarrowPhaseFlushJobType NarrowPhase<TCallbacks>.ConstraintGeneratorType Delegates BroadPhase.RefinementScheduler Returns the size and number of refinements to execute during the broad phase."
  },
  "api/BepuPhysics.ConstraintBatch.html": {
    "href": "api/BepuPhysics.ConstraintBatch.html",
    "title": "Struct ConstraintBatch | Bepu API",
    "keywords": "Struct ConstraintBatch Namespace BepuPhysics Assembly BepuPhysics.dll Contains a set of type batches whose constraints share no body references. public struct ConstraintBatch Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ConstraintBatch(BufferPool, int) public ConstraintBatch(BufferPool pool, int initialTypeCountEstimate = 32) Parameters pool BufferPool initialTypeCountEstimate int Fields TypeBatches public QuickList<TypeBatch> TypeBatches Field Value QuickList<TypeBatch> TypeIndexToTypeBatchIndex public Buffer<int> TypeIndexToTypeBatchIndex Field Value Buffer<int> Methods Clear(BufferPool) public void Clear(BufferPool pool) Parameters pool BufferPool Dispose(BufferPool) Releases all memory used by the batch. public void Dispose(BufferPool pool) Parameters pool BufferPool EnsureTypeBatchCapacities(Solver) Ensures that all type batches within this constraint batch meet or exceed the size requirements of the per-type capacities defined by the solver. public void EnsureTypeBatchCapacities(Solver solver) Parameters solver Solver Solver to pull minimum capacities from. GetTypeBatch(int) Gets a type batch in the batch matching the given type id. Requires that there exists at least one constraint in the type batch. public ref TypeBatch GetTypeBatch(int typeId) Parameters typeId int Id of the TypeBatch's type to retrieve. Returns TypeBatch TypeBatch instance associated with the given type. GetTypeBatchPointer(int) Gets a pointer to the type batch in the batch matching the given type id. Requires that there exists at least one constraint in the type batch. public TypeBatch* GetTypeBatchPointer(int typeId) Parameters typeId int Id of the TypeBatch's type to retrieve. Returns TypeBatch* TypeBatch instance associated with the given type. Remove(int, int, bool, Solver) public void Remove(int constraintTypeId, int indexInTypeBatch, bool isFallback, Solver solver) Parameters constraintTypeId int indexInTypeBatch int isFallback bool solver Solver RemoveBodyHandlesFromBatchForConstraint(int, int, int, Solver) public void RemoveBodyHandlesFromBatchForConstraint(int constraintTypeId, int indexInTypeBatch, int batchIndex, Solver solver) Parameters constraintTypeId int indexInTypeBatch int batchIndex int solver Solver RemoveTypeBatchIfEmpty(ref TypeBatch, int, BufferPool) public void RemoveTypeBatchIfEmpty(ref TypeBatch typeBatch, int typeBatchIndexToRemove, BufferPool pool) Parameters typeBatch TypeBatch typeBatchIndexToRemove int pool BufferPool ResizeTypeBatchCapacities(Solver) Applies the solver-defined minimum capacities to existing type batches. public void ResizeTypeBatchCapacities(Solver solver) Parameters solver Solver Solver to pull minimum capacities from."
  },
  "api/BepuPhysics.ConstraintHandle.html": {
    "href": "api/BepuPhysics.ConstraintHandle.html",
    "title": "Struct ConstraintHandle | Bepu API",
    "keywords": "Struct ConstraintHandle Namespace BepuPhysics Assembly BepuPhysics.dll Unique identifier of a constraint belonging to a simulation's Solver. public struct ConstraintHandle : IEquatable<ConstraintHandle>, IEqualityComparerRef<ConstraintHandle> Implements IEquatable<ConstraintHandle> IEqualityComparerRef<ConstraintHandle> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ConstraintHandle(int) public ConstraintHandle(int index) Parameters index int Fields Value Index in the handle-to-memory mapping table used to look up the current memory location of the constraint. This value will not (and must not) change during the constraint's lifespan, but the memory that the table points to could change. public int Value Field Value int Methods Equals(ConstraintHandle) Indicates whether the current object is equal to another object of the same type. public bool Equals(ConstraintHandle other) Parameters other ConstraintHandle An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(ref ConstraintHandle, ref ConstraintHandle) public bool Equals(ref ConstraintHandle a, ref ConstraintHandle b) Parameters a ConstraintHandle b ConstraintHandle Returns bool Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Hash(ref ConstraintHandle) public int Hash(ref ConstraintHandle item) Parameters item ConstraintHandle Returns int ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(ConstraintHandle, ConstraintHandle) public static bool operator ==(ConstraintHandle a, ConstraintHandle b) Parameters a ConstraintHandle b ConstraintHandle Returns bool operator !=(ConstraintHandle, ConstraintHandle) public static bool operator !=(ConstraintHandle a, ConstraintHandle b) Parameters a ConstraintHandle b ConstraintHandle Returns bool"
  },
  "api/BepuPhysics.ConstraintLocation.html": {
    "href": "api/BepuPhysics.ConstraintLocation.html",
    "title": "Struct ConstraintLocation | Bepu API",
    "keywords": "Struct ConstraintLocation Namespace BepuPhysics Assembly BepuPhysics.dll Location in memory where a constraint is stored. public struct ConstraintLocation Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields BatchIndex Index of the constraint batch the constraint belongs to. public int BatchIndex Field Value int IndexInTypeBatch Index of the constraint in a type batch. public int IndexInTypeBatch Field Value int SetIndex Index of the constraint set that owns the constraint. If zero, the constraint is attached to bodies that are awake. public int SetIndex Field Value int TypeId Type id of the constraint. Used to look up the type batch index in a constraint batch's type id to type batch index table. public int TypeId Field Value int"
  },
  "api/BepuPhysics.ConstraintReference.html": {
    "href": "api/BepuPhysics.ConstraintReference.html",
    "title": "Struct ConstraintReference | Bepu API",
    "keywords": "Struct ConstraintReference Namespace BepuPhysics Assembly BepuPhysics.dll Reference to a constraint's memory location in the solver. public struct ConstraintReference Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ConstraintReference(TypeBatch*, int) Creates a new constraint reference from a constraint memory location. public ConstraintReference(TypeBatch* typeBatchPointer, int indexInTypeBatch) Parameters typeBatchPointer TypeBatch* Pointer to the type batch where the constraint lives. indexInTypeBatch int Index in the type batch where the constraint is allocated. Fields IndexInTypeBatch Index in the type batch where the constraint is allocated. public readonly int IndexInTypeBatch Field Value int Properties TypeBatch Gets a reference to the type batch holding the constraint. public ref TypeBatch TypeBatch { get; } Property Value TypeBatch"
  },
  "api/BepuPhysics.ConstraintSet.html": {
    "href": "api/BepuPhysics.ConstraintSet.html",
    "title": "Struct ConstraintSet | Bepu API",
    "keywords": "Struct ConstraintSet Namespace BepuPhysics Assembly BepuPhysics.dll public struct ConstraintSet Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ConstraintSet(BufferPool, int) public ConstraintSet(BufferPool pool, int initialBatchCapacity) Parameters pool BufferPool initialBatchCapacity int Fields Batches public QuickList<ConstraintBatch> Batches Field Value QuickList<ConstraintBatch> SequentialFallback public SequentialFallbackBatch SequentialFallback Field Value SequentialFallbackBatch Properties Allocated Gets whether this constraint set is allocated. public bool Allocated { get; } Property Value bool BundleCount Gets the total number of bundles across all types and batches. public int BundleCount { get; } Property Value int ConstraintCount Gets the total number of bundles across all types and batches. public int ConstraintCount { get; } Property Value int Methods Clear(BufferPool) public void Clear(BufferPool pool) Parameters pool BufferPool Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool"
  },
  "api/BepuPhysics.Constraints.AccessAll.html": {
    "href": "api/BepuPhysics.Constraints.AccessAll.html",
    "title": "Struct AccessAll | Bepu API",
    "keywords": "Struct AccessAll Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks all body properties as necessary for gather/scatter. public struct AccessAll : IBodyAccessFilter Implements IBodyAccessFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. public bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. public bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. public bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. public bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.AccessNoInertia.html": {
    "href": "api/BepuPhysics.Constraints.AccessNoInertia.html",
    "title": "Struct AccessNoInertia | Bepu API",
    "keywords": "Struct AccessNoInertia Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Used for kinematic integration; the inertias are known ahead of time and there's no reason to gather them. public struct AccessNoInertia : IBodyAccessFilter Implements IBodyAccessFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. public bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. public bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. public bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. public bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.AccessNoOrientation.html": {
    "href": "api/BepuPhysics.Constraints.AccessNoOrientation.html",
    "title": "Struct AccessNoOrientation | Bepu API",
    "keywords": "Struct AccessNoOrientation Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AccessNoOrientation : IBodyAccessFilter Implements IBodyAccessFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. public bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. public bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. public bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. public bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.AccessNoPose.html": {
    "href": "api/BepuPhysics.Constraints.AccessNoPose.html",
    "title": "Struct AccessNoPose | Bepu API",
    "keywords": "Struct AccessNoPose Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AccessNoPose : IBodyAccessFilter Implements IBodyAccessFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. public bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. public bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. public bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. public bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.AccessNoPosition.html": {
    "href": "api/BepuPhysics.Constraints.AccessNoPosition.html",
    "title": "Struct AccessNoPosition | Bepu API",
    "keywords": "Struct AccessNoPosition Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AccessNoPosition : IBodyAccessFilter Implements IBodyAccessFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. public bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. public bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. public bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. public bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.AccessOnlyAngular.html": {
    "href": "api/BepuPhysics.Constraints.AccessOnlyAngular.html",
    "title": "Struct AccessOnlyAngular | Bepu API",
    "keywords": "Struct AccessOnlyAngular Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AccessOnlyAngular : IBodyAccessFilter Implements IBodyAccessFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. public bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. public bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. public bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. public bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.AccessOnlyAngularWithoutPose.html": {
    "href": "api/BepuPhysics.Constraints.AccessOnlyAngularWithoutPose.html",
    "title": "Struct AccessOnlyAngularWithoutPose | Bepu API",
    "keywords": "Struct AccessOnlyAngularWithoutPose Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AccessOnlyAngularWithoutPose : IBodyAccessFilter Implements IBodyAccessFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. public bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. public bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. public bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. public bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.AccessOnlyLinear.html": {
    "href": "api/BepuPhysics.Constraints.AccessOnlyLinear.html",
    "title": "Struct AccessOnlyLinear | Bepu API",
    "keywords": "Struct AccessOnlyLinear Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AccessOnlyLinear : IBodyAccessFilter Implements IBodyAccessFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. public bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. public bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. public bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. public bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.AccessOnlyVelocity.html": {
    "href": "api/BepuPhysics.Constraints.AccessOnlyVelocity.html",
    "title": "Struct AccessOnlyVelocity | Bepu API",
    "keywords": "Struct AccessOnlyVelocity Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AccessOnlyVelocity : IBodyAccessFilter Implements IBodyAccessFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. public bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. public bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. public bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. public bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. public bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.AllowPoseIntegration.html": {
    "href": "api/BepuPhysics.Constraints.AllowPoseIntegration.html",
    "title": "Struct AllowPoseIntegration | Bepu API",
    "keywords": "Struct AllowPoseIntegration Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks a batch as integrating poses for any bodies with integration responsibility within the constraint batch. Constraints which need to be updated in response to pose integration will also have their UpdateForNewPose function called. public struct AllowPoseIntegration : IBatchPoseIntegrationAllowed Implements IBatchPoseIntegrationAllowed Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/BepuPhysics.Constraints.AngularAxisGearMotor.html": {
    "href": "api/BepuPhysics.Constraints.AngularAxisGearMotor.html",
    "title": "Struct AngularAxisGearMotor | Bepu API",
    "keywords": "Struct AngularAxisGearMotor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains body B's angular velocity around an axis anchored to body A to equal body A's velocity around that axis with a scaling factor applied. public struct AngularAxisGearMotor : ITwoBodyConstraintDescription<AngularAxisGearMotor>, IConstraintDescription<AngularAxisGearMotor> Implements ITwoBodyConstraintDescription<AngularAxisGearMotor> IConstraintDescription<AngularAxisGearMotor> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalAxisA Axis of rotation in body A's local space. public Vector3 LocalAxisA Field Value Vector3 Settings Motor control parameters. public MotorSettings Settings Field Value MotorSettings VelocityScale Scale to apply to body A's velocity around the axis to get body B's target velocity. In other words, a VelocityScale of 2 means that body A could have a velocity of 3 while body B has a velocity of 6. public float VelocityScale Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out AngularAxisGearMotor) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out AngularAxisGearMotor description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description AngularAxisGearMotor Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.AngularAxisGearMotorFunctions.html": {
    "href": "api/BepuPhysics.Constraints.AngularAxisGearMotorFunctions.html",
    "title": "Struct AngularAxisGearMotorFunctions | Bepu API",
    "keywords": "Struct AngularAxisGearMotorFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularAxisGearMotorFunctions : ITwoBodyConstraintFunctions<AngularAxisGearMotorPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<AngularAxisGearMotorPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(in Vector3Wide, in Vector3Wide, in Vector<float>, ref Vector3Wide, ref Vector3Wide) public static void ApplyImpulse(in Vector3Wide impulseToVelocityA, in Vector3Wide negatedImpulseToVelocityB, in Vector<float> csi, ref Vector3Wide angularVelocityA, ref Vector3Wide angularVelocityB) Parameters impulseToVelocityA Vector3Wide negatedImpulseToVelocityB Vector3Wide csi Vector<float> angularVelocityA Vector3Wide angularVelocityB Vector3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref AngularAxisGearMotorPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref AngularAxisGearMotorPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData AngularAxisGearMotorPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref AngularAxisGearMotorPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref AngularAxisGearMotorPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep AngularAxisGearMotorPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref AngularAxisGearMotorPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref AngularAxisGearMotorPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep AngularAxisGearMotorPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.AngularAxisGearMotorPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.AngularAxisGearMotorPrestepData.html",
    "title": "Struct AngularAxisGearMotorPrestepData | Bepu API",
    "keywords": "Struct AngularAxisGearMotorPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularAxisGearMotorPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalAxisA public Vector3Wide LocalAxisA Field Value Vector3Wide Settings public MotorSettingsWide Settings Field Value MotorSettingsWide VelocityScale public Vector<float> VelocityScale Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.AngularAxisGearMotorTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.AngularAxisGearMotorTypeProcessor.html",
    "title": "Class AngularAxisGearMotorTypeProcessor | Bepu API",
    "keywords": "Class AngularAxisGearMotorTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class AngularAxisGearMotorTypeProcessor : TwoBodyTypeProcessor<AngularAxisGearMotorPrestepData, Vector<float>, AngularAxisGearMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>> TwoBodyTypeProcessor<AngularAxisGearMotorPrestepData, Vector<float>, AngularAxisGearMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose> AngularAxisGearMotorTypeProcessor Inherited Members TwoBodyTypeProcessor<AngularAxisGearMotorPrestepData, Vector<float>, AngularAxisGearMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<AngularAxisGearMotorPrestepData, Vector<float>, AngularAxisGearMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<AngularAxisGearMotorPrestepData, Vector<float>, AngularAxisGearMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<AngularAxisGearMotorPrestepData, Vector<float>, AngularAxisGearMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<AngularAxisGearMotorPrestepData, Vector<float>, AngularAxisGearMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref AngularAxisGearMotorPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref AngularAxisGearMotorPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularAxisGearMotorPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 54 Field Value int"
  },
  "api/BepuPhysics.Constraints.AngularAxisMotor.html": {
    "href": "api/BepuPhysics.Constraints.AngularAxisMotor.html",
    "title": "Struct AngularAxisMotor | Bepu API",
    "keywords": "Struct AngularAxisMotor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains the relative angular velocity of two bodies around a local axis attached to body A to a target velocity. public struct AngularAxisMotor : ITwoBodyConstraintDescription<AngularAxisMotor>, IConstraintDescription<AngularAxisMotor> Implements ITwoBodyConstraintDescription<AngularAxisMotor> IConstraintDescription<AngularAxisMotor> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalAxisA Axis of rotation in body A's local space. public Vector3 LocalAxisA Field Value Vector3 Settings Motor control parameters. public MotorSettings Settings Field Value MotorSettings TargetVelocity Target relative angular velocity around the axis. public float TargetVelocity Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out AngularAxisMotor) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out AngularAxisMotor description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description AngularAxisMotor Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.AngularAxisMotorFunctions.html": {
    "href": "api/BepuPhysics.Constraints.AngularAxisMotorFunctions.html",
    "title": "Struct AngularAxisMotorFunctions | Bepu API",
    "keywords": "Struct AngularAxisMotorFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularAxisMotorFunctions : ITwoBodyConstraintFunctions<AngularAxisMotorPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<AngularAxisMotorPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(in Vector3Wide, in Vector3Wide, in Vector<float>, ref Vector3Wide, ref Vector3Wide) public static void ApplyImpulse(in Vector3Wide impulseToVelocityA, in Vector3Wide negatedImpulseToVelocityB, in Vector<float> csi, ref Vector3Wide angularVelocityA, ref Vector3Wide angularVelocityB) Parameters impulseToVelocityA Vector3Wide negatedImpulseToVelocityB Vector3Wide csi Vector<float> angularVelocityA Vector3Wide angularVelocityB Vector3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref AngularAxisMotorPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref AngularAxisMotorPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData AngularAxisMotorPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref AngularAxisMotorPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref AngularAxisMotorPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep AngularAxisMotorPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref AngularAxisMotorPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref AngularAxisMotorPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep AngularAxisMotorPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.AngularAxisMotorPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.AngularAxisMotorPrestepData.html",
    "title": "Struct AngularAxisMotorPrestepData | Bepu API",
    "keywords": "Struct AngularAxisMotorPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularAxisMotorPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalAxisA public Vector3Wide LocalAxisA Field Value Vector3Wide Settings public MotorSettingsWide Settings Field Value MotorSettingsWide TargetVelocity public Vector<float> TargetVelocity Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.AngularAxisMotorTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.AngularAxisMotorTypeProcessor.html",
    "title": "Class AngularAxisMotorTypeProcessor | Bepu API",
    "keywords": "Class AngularAxisMotorTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class AngularAxisMotorTypeProcessor : TwoBodyTypeProcessor<AngularAxisMotorPrestepData, Vector<float>, AngularAxisMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>> TwoBodyTypeProcessor<AngularAxisMotorPrestepData, Vector<float>, AngularAxisMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular> AngularAxisMotorTypeProcessor Inherited Members TwoBodyTypeProcessor<AngularAxisMotorPrestepData, Vector<float>, AngularAxisMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.InternalBodiesPerConstraint TwoBodyTypeProcessor<AngularAxisMotorPrestepData, Vector<float>, AngularAxisMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<AngularAxisMotorPrestepData, Vector<float>, AngularAxisMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<AngularAxisMotorPrestepData, Vector<float>, AngularAxisMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<AngularAxisMotorPrestepData, Vector<float>, AngularAxisMotorFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref AngularAxisMotorPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref AngularAxisMotorPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularAxisMotorPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 41 Field Value int"
  },
  "api/BepuPhysics.Constraints.AngularHinge.html": {
    "href": "api/BepuPhysics.Constraints.AngularHinge.html",
    "title": "Struct AngularHinge | Bepu API",
    "keywords": "Struct AngularHinge Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Angular component of a hinge. Constrains the angular degrees of freedom of two bodies such that they can only rotate relative to each other around the hinge's axis. public struct AngularHinge : ITwoBodyConstraintDescription<AngularHinge>, IConstraintDescription<AngularHinge> Implements ITwoBodyConstraintDescription<AngularHinge> IConstraintDescription<AngularHinge> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalHingeAxisA Hinge axis in the local space of A. public Vector3 LocalHingeAxisA Field Value Vector3 LocalHingeAxisB Hinge axis in the local space of B. public Vector3 LocalHingeAxisB Field Value Vector3 SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out AngularHinge) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out AngularHinge description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description AngularHinge Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.AngularHingeFunctions.html": {
    "href": "api/BepuPhysics.Constraints.AngularHingeFunctions.html",
    "title": "Struct AngularHingeFunctions | Bepu API",
    "keywords": "Struct AngularHingeFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularHingeFunctions : ITwoBodyConstraintFunctions<AngularHingePrestepData, Vector2Wide> Implements ITwoBodyConstraintFunctions<AngularHingePrestepData, Vector2Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods GetErrorAngles(in Vector3Wide, in Vector3Wide, in Matrix2x3Wide, out Vector2Wide) public static void GetErrorAngles(in Vector3Wide hingeAxisA, in Vector3Wide hingeAxisB, in Matrix2x3Wide jacobianA, out Vector2Wide errorAngles) Parameters hingeAxisA Vector3Wide hingeAxisB Vector3Wide jacobianA Matrix2x3Wide errorAngles Vector2Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref AngularHingePrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref AngularHingePrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData AngularHingePrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref AngularHingePrestepData, ref Vector2Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref AngularHingePrestepData prestep, ref Vector2Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep AngularHingePrestepData accumulatedImpulses Vector2Wide wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref AngularHingePrestepData, ref Vector2Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref AngularHingePrestepData prestep, ref Vector2Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep AngularHingePrestepData accumulatedImpulses Vector2Wide wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.AngularHingePrestepData.html": {
    "href": "api/BepuPhysics.Constraints.AngularHingePrestepData.html",
    "title": "Struct AngularHingePrestepData | Bepu API",
    "keywords": "Struct AngularHingePrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularHingePrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalHingeAxisA public Vector3Wide LocalHingeAxisA Field Value Vector3Wide LocalHingeAxisB public Vector3Wide LocalHingeAxisB Field Value Vector3Wide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.AngularHingeTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.AngularHingeTypeProcessor.html",
    "title": "Class AngularHingeTypeProcessor | Bepu API",
    "keywords": "Class AngularHingeTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class AngularHingeTypeProcessor : TwoBodyTypeProcessor<AngularHingePrestepData, Vector2Wide, AngularHingeFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide> TwoBodyTypeProcessor<AngularHingePrestepData, Vector2Wide, AngularHingeFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular> AngularHingeTypeProcessor Inherited Members TwoBodyTypeProcessor<AngularHingePrestepData, Vector2Wide, AngularHingeFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.InternalBodiesPerConstraint TwoBodyTypeProcessor<AngularHingePrestepData, Vector2Wide, AngularHingeFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<AngularHingePrestepData, Vector2Wide, AngularHingeFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<AngularHingePrestepData, Vector2Wide, AngularHingeFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<AngularHingePrestepData, Vector2Wide, AngularHingeFunctions, AccessOnlyAngular, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.Move(ref TwoBodyReferences, ref AngularHingePrestepData, ref Vector2Wide, ConstraintHandle, int, ref TwoBodyReferences, ref AngularHingePrestepData, ref Vector2Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularHingePrestepData, Vector2Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 23 Field Value int"
  },
  "api/BepuPhysics.Constraints.AngularMotor.html": {
    "href": "api/BepuPhysics.Constraints.AngularMotor.html",
    "title": "Struct AngularMotor | Bepu API",
    "keywords": "Struct AngularMotor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains the relative angular velocity between two bodies to a target. public struct AngularMotor : ITwoBodyConstraintDescription<AngularMotor>, IConstraintDescription<AngularMotor> Implements ITwoBodyConstraintDescription<AngularMotor> IConstraintDescription<AngularMotor> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Settings Motor control parameters. public MotorSettings Settings Field Value MotorSettings TargetVelocityLocalA Target relative angular velocity between A and B, stored in A's local space. Target world space angular velocity of B is AngularVelocityA + TargetVelocityLocalA * OrientationA. public Vector3 TargetVelocityLocalA Field Value Vector3 Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out AngularMotor) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out AngularMotor description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description AngularMotor Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.AngularMotorFunctions.html": {
    "href": "api/BepuPhysics.Constraints.AngularMotorFunctions.html",
    "title": "Struct AngularMotorFunctions | Bepu API",
    "keywords": "Struct AngularMotorFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularMotorFunctions : ITwoBodyConstraintFunctions<AngularMotorPrestepData, Vector3Wide> Implements ITwoBodyConstraintFunctions<AngularMotorPrestepData, Vector3Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref AngularMotorPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref AngularMotorPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData AngularMotorPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref AngularMotorPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref AngularMotorPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep AngularMotorPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref AngularMotorPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref AngularMotorPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep AngularMotorPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.AngularMotorPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.AngularMotorPrestepData.html",
    "title": "Struct AngularMotorPrestepData | Bepu API",
    "keywords": "Struct AngularMotorPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularMotorPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Settings public MotorSettingsWide Settings Field Value MotorSettingsWide TargetVelocityLocalA public Vector3Wide TargetVelocityLocalA Field Value Vector3Wide"
  },
  "api/BepuPhysics.Constraints.AngularMotorTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.AngularMotorTypeProcessor.html",
    "title": "Class AngularMotorTypeProcessor | Bepu API",
    "keywords": "Class AngularMotorTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class AngularMotorTypeProcessor : TwoBodyTypeProcessor<AngularMotorPrestepData, Vector3Wide, AngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide> TwoBodyTypeProcessor<AngularMotorPrestepData, Vector3Wide, AngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose> AngularMotorTypeProcessor Inherited Members TwoBodyTypeProcessor<AngularMotorPrestepData, Vector3Wide, AngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<AngularMotorPrestepData, Vector3Wide, AngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<AngularMotorPrestepData, Vector3Wide, AngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<AngularMotorPrestepData, Vector3Wide, AngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<AngularMotorPrestepData, Vector3Wide, AngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngularWithoutPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.Move(ref TwoBodyReferences, ref AngularMotorPrestepData, ref Vector3Wide, ConstraintHandle, int, ref TwoBodyReferences, ref AngularMotorPrestepData, ref Vector3Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularMotorPrestepData, Vector3Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 30 Field Value int"
  },
  "api/BepuPhysics.Constraints.AngularServo.html": {
    "href": "api/BepuPhysics.Constraints.AngularServo.html",
    "title": "Struct AngularServo | Bepu API",
    "keywords": "Struct AngularServo Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains two bodies to have a target relative rotation. public struct AngularServo : ITwoBodyConstraintDescription<AngularServo>, IConstraintDescription<AngularServo> Implements ITwoBodyConstraintDescription<AngularServo> IConstraintDescription<AngularServo> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ServoSettings Servo control parameters. public ServoSettings ServoSettings Field Value ServoSettings SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings TargetRelativeRotationLocalA The target relative rotation from body A to body B in body A's local space. The constraint tries to maintain OrientationB = TargetRelativeRotationLocalA * OrientationA. public Quaternion TargetRelativeRotationLocalA Field Value Quaternion Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out AngularServo) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out AngularServo description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description AngularServo Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.AngularServoFunctions.html": {
    "href": "api/BepuPhysics.Constraints.AngularServoFunctions.html",
    "title": "Struct AngularServoFunctions | Bepu API",
    "keywords": "Struct AngularServoFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularServoFunctions : ITwoBodyConstraintFunctions<AngularServoPrestepData, Vector3Wide> Implements ITwoBodyConstraintFunctions<AngularServoPrestepData, Vector3Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(ref Vector3Wide, ref Vector3Wide, in Symmetric3x3Wide, in Symmetric3x3Wide, in Vector3Wide) public static void ApplyImpulse(ref Vector3Wide angularVelocityA, ref Vector3Wide angularVelocityB, in Symmetric3x3Wide impulseToVelocityA, in Symmetric3x3Wide negatedImpulseToVelocityB, in Vector3Wide csi) Parameters angularVelocityA Vector3Wide angularVelocityB Vector3Wide impulseToVelocityA Symmetric3x3Wide negatedImpulseToVelocityB Symmetric3x3Wide csi Vector3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref AngularServoPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref AngularServoPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData AngularServoPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref AngularServoPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref AngularServoPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep AngularServoPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref AngularServoPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref AngularServoPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep AngularServoPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.AngularServoPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.AngularServoPrestepData.html",
    "title": "Struct AngularServoPrestepData | Bepu API",
    "keywords": "Struct AngularServoPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularServoPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ServoSettings public ServoSettingsWide ServoSettings Field Value ServoSettingsWide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide TargetRelativeRotationLocalA public QuaternionWide TargetRelativeRotationLocalA Field Value QuaternionWide"
  },
  "api/BepuPhysics.Constraints.AngularServoTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.AngularServoTypeProcessor.html",
    "title": "Class AngularServoTypeProcessor | Bepu API",
    "keywords": "Class AngularServoTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class AngularServoTypeProcessor : TwoBodyTypeProcessor<AngularServoPrestepData, Vector3Wide, AngularServoFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide> TwoBodyTypeProcessor<AngularServoPrestepData, Vector3Wide, AngularServoFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular> AngularServoTypeProcessor Inherited Members TwoBodyTypeProcessor<AngularServoPrestepData, Vector3Wide, AngularServoFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.InternalBodiesPerConstraint TwoBodyTypeProcessor<AngularServoPrestepData, Vector3Wide, AngularServoFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<AngularServoPrestepData, Vector3Wide, AngularServoFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<AngularServoPrestepData, Vector3Wide, AngularServoFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<AngularServoPrestepData, Vector3Wide, AngularServoFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngularWithoutPose, AccessOnlyAngular, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.Move(ref TwoBodyReferences, ref AngularServoPrestepData, ref Vector3Wide, ConstraintHandle, int, ref TwoBodyReferences, ref AngularServoPrestepData, ref Vector3Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularServoPrestepData, Vector3Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 29 Field Value int"
  },
  "api/BepuPhysics.Constraints.AngularSwivelHinge.html": {
    "href": "api/BepuPhysics.Constraints.AngularSwivelHinge.html",
    "title": "Struct AngularSwivelHinge | Bepu API",
    "keywords": "Struct AngularSwivelHinge Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains two bodies with the angular component of a swivel hinge that allows rotation around two axes, like a laptop monitor hinge that allows flipping the screen. public struct AngularSwivelHinge : ITwoBodyConstraintDescription<AngularSwivelHinge>, IConstraintDescription<AngularSwivelHinge> Implements ITwoBodyConstraintDescription<AngularSwivelHinge> IConstraintDescription<AngularSwivelHinge> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalHingeAxisB Hinge axis in the local space of body B. public Vector3 LocalHingeAxisB Field Value Vector3 LocalSwivelAxisA Swivel axis in the local space of body A. public Vector3 LocalSwivelAxisA Field Value Vector3 SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out AngularSwivelHinge) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out AngularSwivelHinge description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description AngularSwivelHinge Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.AngularSwivelHingeFunctions.html": {
    "href": "api/BepuPhysics.Constraints.AngularSwivelHingeFunctions.html",
    "title": "Struct AngularSwivelHingeFunctions | Bepu API",
    "keywords": "Struct AngularSwivelHingeFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularSwivelHingeFunctions : ITwoBodyConstraintFunctions<AngularSwivelHingePrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<AngularSwivelHingePrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref AngularSwivelHingePrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref AngularSwivelHingePrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData AngularSwivelHingePrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref AngularSwivelHingePrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref AngularSwivelHingePrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep AngularSwivelHingePrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref AngularSwivelHingePrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref AngularSwivelHingePrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep AngularSwivelHingePrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.AngularSwivelHingePrestepData.html": {
    "href": "api/BepuPhysics.Constraints.AngularSwivelHingePrestepData.html",
    "title": "Struct AngularSwivelHingePrestepData | Bepu API",
    "keywords": "Struct AngularSwivelHingePrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AngularSwivelHingePrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalHingeAxisB public Vector3Wide LocalHingeAxisB Field Value Vector3Wide LocalSwivelAxisA public Vector3Wide LocalSwivelAxisA Field Value Vector3Wide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.AngularSwivelHingeTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.AngularSwivelHingeTypeProcessor.html",
    "title": "Class AngularSwivelHingeTypeProcessor | Bepu API",
    "keywords": "Class AngularSwivelHingeTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class AngularSwivelHingeTypeProcessor : TwoBodyTypeProcessor<AngularSwivelHingePrestepData, Vector<float>, AngularSwivelHingeFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>> TwoBodyTypeProcessor<AngularSwivelHingePrestepData, Vector<float>, AngularSwivelHingeFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> AngularSwivelHingeTypeProcessor Inherited Members TwoBodyTypeProcessor<AngularSwivelHingePrestepData, Vector<float>, AngularSwivelHingeFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.InternalBodiesPerConstraint TwoBodyTypeProcessor<AngularSwivelHingePrestepData, Vector<float>, AngularSwivelHingeFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<AngularSwivelHingePrestepData, Vector<float>, AngularSwivelHingeFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<AngularSwivelHingePrestepData, Vector<float>, AngularSwivelHingeFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<AngularSwivelHingePrestepData, Vector<float>, AngularSwivelHingeFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref AngularSwivelHingePrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref AngularSwivelHingePrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, AngularSwivelHingePrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 24 Field Value int"
  },
  "api/BepuPhysics.Constraints.AreaConstraint.html": {
    "href": "api/BepuPhysics.Constraints.AreaConstraint.html",
    "title": "Struct AreaConstraint | Bepu API",
    "keywords": "Struct AreaConstraint Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains the area of a triangle connecting the centers of three bodies to match a goal area. Scaled volume computed from ||ab x ac||. public struct AreaConstraint : IThreeBodyConstraintDescription<AreaConstraint>, IConstraintDescription<AreaConstraint> Implements IThreeBodyConstraintDescription<AreaConstraint> IConstraintDescription<AreaConstraint> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors AreaConstraint(Vector3, Vector3, Vector3, SpringSettings) Creates a new area constraint, initializing the target area using a set of initial positions. public AreaConstraint(Vector3 a, Vector3 b, Vector3 c, SpringSettings springSettings) Parameters a Vector3 Initial position of the first body. b Vector3 Initial position of the second body. c Vector3 Initial position of the third body. springSettings SpringSettings Spring settings to apply to the volume constraint. Fields SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings TargetScaledArea 2 times the target area of the triangle. Computed from ||ab x ac||. public float TargetScaledArea Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out AreaConstraint) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out AreaConstraint description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description AreaConstraint Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.AreaConstraintFunctions.html": {
    "href": "api/BepuPhysics.Constraints.AreaConstraintFunctions.html",
    "title": "Struct AreaConstraintFunctions | Bepu API",
    "keywords": "Struct AreaConstraintFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AreaConstraintFunctions : IThreeBodyConstraintFunctions<AreaConstraintPrestepData, Vector<float>> Implements IThreeBodyConstraintFunctions<AreaConstraintPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, in BodyVelocityWide, ref AreaConstraintPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, in BodyVelocityWide wsvC, ref AreaConstraintPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide prestepData AreaConstraintPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref AreaConstraintPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, in Vector3Wide positionC, in QuaternionWide orientationC, in BodyInertiaWide inertiaC, float dt, float inverseDt, ref AreaConstraintPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB, ref BodyVelocityWide wsvC) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide positionC Vector3Wide orientationC QuaternionWide inertiaC BodyInertiaWide dt float inverseDt float prestep AreaConstraintPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref AreaConstraintPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, in Vector3Wide positionC, in QuaternionWide orientationC, in BodyInertiaWide inertiaC, ref AreaConstraintPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB, ref BodyVelocityWide wsvC) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide positionC Vector3Wide orientationC QuaternionWide inertiaC BodyInertiaWide prestep AreaConstraintPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.AreaConstraintPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.AreaConstraintPrestepData.html",
    "title": "Struct AreaConstraintPrestepData | Bepu API",
    "keywords": "Struct AreaConstraintPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct AreaConstraintPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide TargetScaledArea public Vector<float> TargetScaledArea Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.AreaConstraintTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.AreaConstraintTypeProcessor.html",
    "title": "Class AreaConstraintTypeProcessor | Bepu API",
    "keywords": "Class AreaConstraintTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of area constraints. public class AreaConstraintTypeProcessor : ThreeBodyTypeProcessor<AreaConstraintPrestepData, Vector<float>, AreaConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear> Inheritance object TypeProcessor TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>> ThreeBodyTypeProcessor<AreaConstraintPrestepData, Vector<float>, AreaConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear> AreaConstraintTypeProcessor Inherited Members ThreeBodyTypeProcessor<AreaConstraintPrestepData, Vector<float>, AreaConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.InternalBodiesPerConstraint ThreeBodyTypeProcessor<AreaConstraintPrestepData, Vector<float>, AreaConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) ThreeBodyTypeProcessor<AreaConstraintPrestepData, Vector<float>, AreaConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.Solve(ref TypeBatch, Bodies, float, float, int, int) ThreeBodyTypeProcessor<AreaConstraintPrestepData, Vector<float>, AreaConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.RequiresIncrementalSubstepUpdates ThreeBodyTypeProcessor<AreaConstraintPrestepData, Vector<float>, AreaConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.SetBodyReferencesLane(ref ThreeBodyReferences, int, Span<int>) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.AddBodyReferencesLane(ref ThreeBodyReferences, int, Span<int>) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref ThreeBodyReferences, int) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.Move(ref ThreeBodyReferences, ref AreaConstraintPrestepData, ref Vector<float>, ConstraintHandle, int, ref ThreeBodyReferences, ref AreaConstraintPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<ThreeBodyReferences, AreaConstraintPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 36 Field Value int"
  },
  "api/BepuPhysics.Constraints.BallSocket.html": {
    "href": "api/BepuPhysics.Constraints.BallSocket.html",
    "title": "Struct BallSocket | Bepu API",
    "keywords": "Struct BallSocket Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains a point on one body to a point on another body. public struct BallSocket : ITwoBodyConstraintDescription<BallSocket>, IConstraintDescription<BallSocket> Implements ITwoBodyConstraintDescription<BallSocket> IConstraintDescription<BallSocket> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA Offset from the center of body A to its attachment in A's local space. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Offset from the center of body B to its attachment in B's local space. public Vector3 LocalOffsetB Field Value Vector3 SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out BallSocket) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out BallSocket description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description BallSocket Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.BallSocketFunctions.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketFunctions.html",
    "title": "Struct BallSocketFunctions | Bepu API",
    "keywords": "Struct BallSocketFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct BallSocketFunctions : ITwoBodyConstraintFunctions<BallSocketPrestepData, Vector3Wide> Implements ITwoBodyConstraintFunctions<BallSocketPrestepData, Vector3Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref BallSocketPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref BallSocketPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData BallSocketPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref BallSocketPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref BallSocketPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep BallSocketPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref BallSocketPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref BallSocketPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep BallSocketPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.BallSocketMotor.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketMotor.html",
    "title": "Struct BallSocketMotor | Bepu API",
    "keywords": "Struct BallSocketMotor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Controls the relative linear velocity from the center of body A to an attachment point on body B. public struct BallSocketMotor : ITwoBodyConstraintDescription<BallSocketMotor>, IConstraintDescription<BallSocketMotor> Implements ITwoBodyConstraintDescription<BallSocketMotor> IConstraintDescription<BallSocketMotor> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetB Offset from body B to its attachment in B's local space. public Vector3 LocalOffsetB Field Value Vector3 Settings Motor control parameters. public MotorSettings Settings Field Value MotorSettings TargetVelocityLocalA Target relative linear velocity between A and B, stored in A's local space. Target world space linear velocity of B is LinearVelocityA + TargetVelocityLocalA * OrientationA. public Vector3 TargetVelocityLocalA Field Value Vector3 Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out BallSocketMotor) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out BallSocketMotor description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description BallSocketMotor Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.BallSocketMotorFunctions.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketMotorFunctions.html",
    "title": "Struct BallSocketMotorFunctions | Bepu API",
    "keywords": "Struct BallSocketMotorFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct BallSocketMotorFunctions : ITwoBodyConstraintFunctions<BallSocketMotorPrestepData, Vector3Wide> Implements ITwoBodyConstraintFunctions<BallSocketMotorPrestepData, Vector3Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref BallSocketMotorPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref BallSocketMotorPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData BallSocketMotorPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref BallSocketMotorPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref BallSocketMotorPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep BallSocketMotorPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref BallSocketMotorPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref BallSocketMotorPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep BallSocketMotorPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.BallSocketMotorPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketMotorPrestepData.html",
    "title": "Struct BallSocketMotorPrestepData | Bepu API",
    "keywords": "Struct BallSocketMotorPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct BallSocketMotorPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide Settings public MotorSettingsWide Settings Field Value MotorSettingsWide TargetVelocityLocalA public Vector3Wide TargetVelocityLocalA Field Value Vector3Wide"
  },
  "api/BepuPhysics.Constraints.BallSocketMotorTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketMotorTypeProcessor.html",
    "title": "Class BallSocketMotorTypeProcessor | Bepu API",
    "keywords": "Class BallSocketMotorTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of ball socket motor constraints. public class BallSocketMotorTypeProcessor : TwoBodyTypeProcessor<BallSocketMotorPrestepData, Vector3Wide, BallSocketMotorFunctions, AccessNoOrientation, AccessAll, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide> TwoBodyTypeProcessor<BallSocketMotorPrestepData, Vector3Wide, BallSocketMotorFunctions, AccessNoOrientation, AccessAll, AccessAll, AccessAll> BallSocketMotorTypeProcessor Inherited Members TwoBodyTypeProcessor<BallSocketMotorPrestepData, Vector3Wide, BallSocketMotorFunctions, AccessNoOrientation, AccessAll, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<BallSocketMotorPrestepData, Vector3Wide, BallSocketMotorFunctions, AccessNoOrientation, AccessAll, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<BallSocketMotorPrestepData, Vector3Wide, BallSocketMotorFunctions, AccessNoOrientation, AccessAll, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<BallSocketMotorPrestepData, Vector3Wide, BallSocketMotorFunctions, AccessNoOrientation, AccessAll, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<BallSocketMotorPrestepData, Vector3Wide, BallSocketMotorFunctions, AccessNoOrientation, AccessAll, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.Move(ref TwoBodyReferences, ref BallSocketMotorPrestepData, ref Vector3Wide, ConstraintHandle, int, ref TwoBodyReferences, ref BallSocketMotorPrestepData, ref Vector3Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, BallSocketMotorPrestepData, Vector3Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 52 Field Value int"
  },
  "api/BepuPhysics.Constraints.BallSocketPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketPrestepData.html",
    "title": "Struct BallSocketPrestepData | Bepu API",
    "keywords": "Struct BallSocketPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct BallSocketPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.BallSocketServo.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketServo.html",
    "title": "Struct BallSocketServo | Bepu API",
    "keywords": "Struct BallSocketServo Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains a point on one body to a point on another body. Provides speed and force configuration that the BallSocket joint does not. public struct BallSocketServo : ITwoBodyConstraintDescription<BallSocketServo>, IConstraintDescription<BallSocketServo> Implements ITwoBodyConstraintDescription<BallSocketServo> IConstraintDescription<BallSocketServo> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA Offset from the center of body A to its attachment in A's local space. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Offset from the center of body B to its attachment in B's local space. public Vector3 LocalOffsetB Field Value Vector3 ServoSettings Servo control parameters. public ServoSettings ServoSettings Field Value ServoSettings SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out BallSocketServo) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out BallSocketServo description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description BallSocketServo Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.BallSocketServoFunctions.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketServoFunctions.html",
    "title": "Struct BallSocketServoFunctions | Bepu API",
    "keywords": "Struct BallSocketServoFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct BallSocketServoFunctions : ITwoBodyConstraintFunctions<BallSocketServoPrestepData, Vector3Wide> Implements ITwoBodyConstraintFunctions<BallSocketServoPrestepData, Vector3Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref BallSocketServoPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref BallSocketServoPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData BallSocketServoPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref BallSocketServoPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref BallSocketServoPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep BallSocketServoPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref BallSocketServoPrestepData, ref Vector3Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref BallSocketServoPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep BallSocketServoPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.BallSocketServoPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketServoPrestepData.html",
    "title": "Struct BallSocketServoPrestepData | Bepu API",
    "keywords": "Struct BallSocketServoPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct BallSocketServoPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide ServoSettings public ServoSettingsWide ServoSettings Field Value ServoSettingsWide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.BallSocketServoTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketServoTypeProcessor.html",
    "title": "Class BallSocketServoTypeProcessor | Bepu API",
    "keywords": "Class BallSocketServoTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of ball socket servo constraints. public class BallSocketServoTypeProcessor : TwoBodyTypeProcessor<BallSocketServoPrestepData, Vector3Wide, BallSocketServoFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide> TwoBodyTypeProcessor<BallSocketServoPrestepData, Vector3Wide, BallSocketServoFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll> BallSocketServoTypeProcessor Inherited Members TwoBodyTypeProcessor<BallSocketServoPrestepData, Vector3Wide, BallSocketServoFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<BallSocketServoPrestepData, Vector3Wide, BallSocketServoFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<BallSocketServoPrestepData, Vector3Wide, BallSocketServoFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<BallSocketServoPrestepData, Vector3Wide, BallSocketServoFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<BallSocketServoPrestepData, Vector3Wide, BallSocketServoFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.Move(ref TwoBodyReferences, ref BallSocketServoPrestepData, ref Vector3Wide, ConstraintHandle, int, ref TwoBodyReferences, ref BallSocketServoPrestepData, ref Vector3Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, BallSocketServoPrestepData, Vector3Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 53 Field Value int"
  },
  "api/BepuPhysics.Constraints.BallSocketShared.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketShared.html",
    "title": "Class BallSocketShared | Bepu API",
    "keywords": "Class BallSocketShared Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Provides shared functionality for constraints with jacobians similar to the BallSocket. public static class BallSocketShared Inheritance object BallSocketShared Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ApplyImpulse(ref BodyVelocityWide, ref BodyVelocityWide, in Vector3Wide, in Vector3Wide, in BodyInertiaWide, in BodyInertiaWide, in Vector3Wide) public static void ApplyImpulse(ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB, in Vector3Wide offsetA, in Vector3Wide offsetB, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector3Wide constraintSpaceImpulse) Parameters velocityA BodyVelocityWide velocityB BodyVelocityWide offsetA Vector3Wide offsetB Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide constraintSpaceImpulse Vector3Wide ComputeCorrectiveImpulse(ref BodyVelocityWide, ref BodyVelocityWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Symmetric3x3Wide, in Vector<float>, in Vector3Wide, out Vector3Wide) public static void ComputeCorrectiveImpulse(ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB, in Vector3Wide offsetA, in Vector3Wide offsetB, in Vector3Wide biasVelocity, in Symmetric3x3Wide effectiveMass, in Vector<float> softnessImpulseScale, in Vector3Wide accumulatedImpulse, out Vector3Wide correctiveImpulse) Parameters velocityA BodyVelocityWide velocityB BodyVelocityWide offsetA Vector3Wide offsetB Vector3Wide biasVelocity Vector3Wide effectiveMass Symmetric3x3Wide softnessImpulseScale Vector<float> accumulatedImpulse Vector3Wide correctiveImpulse Vector3Wide ComputeEffectiveMass(in BodyInertiaWide, in BodyInertiaWide, in Vector3Wide, in Vector3Wide, in Vector<float>, out Symmetric3x3Wide) public static void ComputeEffectiveMass(in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector3Wide offsetA, in Vector3Wide offsetB, in Vector<float> effectiveMassCFMScale, out Symmetric3x3Wide effectiveMass) Parameters inertiaA BodyInertiaWide inertiaB BodyInertiaWide offsetA Vector3Wide offsetB Vector3Wide effectiveMassCFMScale Vector<float> effectiveMass Symmetric3x3Wide Solve(ref BodyVelocityWide, ref BodyVelocityWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Symmetric3x3Wide, in Vector<float>, ref Vector3Wide, in BodyInertiaWide, in BodyInertiaWide) public static void Solve(ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB, in Vector3Wide offsetA, in Vector3Wide offsetB, in Vector3Wide biasVelocity, in Symmetric3x3Wide effectiveMass, in Vector<float> softnessImpulseScale, ref Vector3Wide accumulatedImpulse, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB) Parameters velocityA BodyVelocityWide velocityB BodyVelocityWide offsetA Vector3Wide offsetB Vector3Wide biasVelocity Vector3Wide effectiveMass Symmetric3x3Wide softnessImpulseScale Vector<float> accumulatedImpulse Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide Solve(ref BodyVelocityWide, ref BodyVelocityWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Symmetric3x3Wide, in Vector<float>, in Vector<float>, ref Vector3Wide, in BodyInertiaWide, in BodyInertiaWide) public static void Solve(ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB, in Vector3Wide offsetA, in Vector3Wide offsetB, in Vector3Wide biasVelocity, in Symmetric3x3Wide effectiveMass, in Vector<float> softnessImpulseScale, in Vector<float> maximumImpulse, ref Vector3Wide accumulatedImpulse, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB) Parameters velocityA BodyVelocityWide velocityB BodyVelocityWide offsetA Vector3Wide offsetB Vector3Wide biasVelocity Vector3Wide effectiveMass Symmetric3x3Wide softnessImpulseScale Vector<float> maximumImpulse Vector<float> accumulatedImpulse Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide"
  },
  "api/BepuPhysics.Constraints.BallSocketTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.BallSocketTypeProcessor.html",
    "title": "Class BallSocketTypeProcessor | Bepu API",
    "keywords": "Class BallSocketTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of ball socket constraints. public class BallSocketTypeProcessor : TwoBodyTypeProcessor<BallSocketPrestepData, Vector3Wide, BallSocketFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide> TwoBodyTypeProcessor<BallSocketPrestepData, Vector3Wide, BallSocketFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll> BallSocketTypeProcessor Inherited Members TwoBodyTypeProcessor<BallSocketPrestepData, Vector3Wide, BallSocketFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<BallSocketPrestepData, Vector3Wide, BallSocketFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<BallSocketPrestepData, Vector3Wide, BallSocketFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<BallSocketPrestepData, Vector3Wide, BallSocketFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<BallSocketPrestepData, Vector3Wide, BallSocketFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.Move(ref TwoBodyReferences, ref BallSocketPrestepData, ref Vector3Wide, ConstraintHandle, int, ref TwoBodyReferences, ref BallSocketPrestepData, ref Vector3Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, BallSocketPrestepData, Vector3Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 22 Field Value int"
  },
  "api/BepuPhysics.Constraints.BatchShouldAlwaysIntegrate.html": {
    "href": "api/BepuPhysics.Constraints.BatchShouldAlwaysIntegrate.html",
    "title": "Struct BatchShouldAlwaysIntegrate | Bepu API",
    "keywords": "Struct BatchShouldAlwaysIntegrate Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll The batch was determined to have only constraints with integration responsibilities, so there's no need to check. public struct BatchShouldAlwaysIntegrate : IBatchIntegrationMode Implements IBatchIntegrationMode Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/BepuPhysics.Constraints.BatchShouldConditionallyIntegrate.html": {
    "href": "api/BepuPhysics.Constraints.BatchShouldConditionallyIntegrate.html",
    "title": "Struct BatchShouldConditionallyIntegrate | Bepu API",
    "keywords": "Struct BatchShouldConditionallyIntegrate Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll The batch was determined to have some constraints with integration responsibilities. public struct BatchShouldConditionallyIntegrate : IBatchIntegrationMode Implements IBatchIntegrationMode Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/BepuPhysics.Constraints.BatchShouldNeverIntegrate.html": {
    "href": "api/BepuPhysics.Constraints.BatchShouldNeverIntegrate.html",
    "title": "Struct BatchShouldNeverIntegrate | Bepu API",
    "keywords": "Struct BatchShouldNeverIntegrate Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll The batch was determined to have no constraints with integration responsibilities, so there's no need to check. public struct BatchShouldNeverIntegrate : IBatchIntegrationMode Implements IBatchIntegrationMode Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/BepuPhysics.Constraints.CenterDistanceConstraint.html": {
    "href": "api/BepuPhysics.Constraints.CenterDistanceConstraint.html",
    "title": "Struct CenterDistanceConstraint | Bepu API",
    "keywords": "Struct CenterDistanceConstraint Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains the center of two bodies to be separated by a goal distance. public struct CenterDistanceConstraint : ITwoBodyConstraintDescription<CenterDistanceConstraint>, IConstraintDescription<CenterDistanceConstraint> Implements ITwoBodyConstraintDescription<CenterDistanceConstraint> IConstraintDescription<CenterDistanceConstraint> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CenterDistanceConstraint(float, in SpringSettings) public CenterDistanceConstraint(float targetDistance, in SpringSettings springSettings) Parameters targetDistance float springSettings SpringSettings Fields SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings TargetDistance Target distance between the body centers. public float TargetDistance Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out CenterDistanceConstraint) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out CenterDistanceConstraint description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description CenterDistanceConstraint Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.CenterDistanceConstraintFunctions.html": {
    "href": "api/BepuPhysics.Constraints.CenterDistanceConstraintFunctions.html",
    "title": "Struct CenterDistanceConstraintFunctions | Bepu API",
    "keywords": "Struct CenterDistanceConstraintFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct CenterDistanceConstraintFunctions : ITwoBodyConstraintFunctions<CenterDistancePrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<CenterDistancePrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(in Vector3Wide, in Vector<float>, in Vector<float>, in Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void ApplyImpulse(in Vector3Wide jacobianA, in Vector<float> inverseMassA, in Vector<float> inverseMassB, in Vector<float> impulse, ref BodyVelocityWide a, ref BodyVelocityWide b) Parameters jacobianA Vector3Wide inverseMassA Vector<float> inverseMassB Vector<float> impulse Vector<float> a BodyVelocityWide b BodyVelocityWide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref CenterDistancePrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref CenterDistancePrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData CenterDistancePrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref CenterDistancePrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref CenterDistancePrestepData prestep, ref Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep CenterDistancePrestepData accumulatedImpulse Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref CenterDistancePrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref CenterDistancePrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep CenterDistancePrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.CenterDistanceLimit.html": {
    "href": "api/BepuPhysics.Constraints.CenterDistanceLimit.html",
    "title": "Struct CenterDistanceLimit | Bepu API",
    "keywords": "Struct CenterDistanceLimit Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains the center of two bodies to be separated by a distance within a range. public struct CenterDistanceLimit : ITwoBodyConstraintDescription<CenterDistanceLimit>, IConstraintDescription<CenterDistanceLimit> Implements ITwoBodyConstraintDescription<CenterDistanceLimit> IConstraintDescription<CenterDistanceLimit> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors CenterDistanceLimit(float, float, in SpringSettings) public CenterDistanceLimit(float minimumDistance, float maximumDistance, in SpringSettings springSettings) Parameters minimumDistance float maximumDistance float springSettings SpringSettings Fields MaximumDistance Maximum distance between the body centers. public float MaximumDistance Field Value float MinimumDistance Minimum distance between the body centers. public float MinimumDistance Field Value float SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out CenterDistanceLimit) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out CenterDistanceLimit description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description CenterDistanceLimit Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.CenterDistanceLimitFunctions.html": {
    "href": "api/BepuPhysics.Constraints.CenterDistanceLimitFunctions.html",
    "title": "Struct CenterDistanceLimitFunctions | Bepu API",
    "keywords": "Struct CenterDistanceLimitFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct CenterDistanceLimitFunctions : ITwoBodyConstraintFunctions<CenterDistanceLimitPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<CenterDistanceLimitPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref CenterDistanceLimitPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref CenterDistanceLimitPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData CenterDistanceLimitPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref CenterDistanceLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref CenterDistanceLimitPrestepData prestep, ref Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep CenterDistanceLimitPrestepData accumulatedImpulse Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref CenterDistanceLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref CenterDistanceLimitPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep CenterDistanceLimitPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.CenterDistanceLimitPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.CenterDistanceLimitPrestepData.html",
    "title": "Struct CenterDistanceLimitPrestepData | Bepu API",
    "keywords": "Struct CenterDistanceLimitPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct CenterDistanceLimitPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields MaximumDistance public Vector<float> MaximumDistance Field Value Vector<float> MinimumDistance public Vector<float> MinimumDistance Field Value Vector<float> SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.CenterDistanceLimitTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.CenterDistanceLimitTypeProcessor.html",
    "title": "Class CenterDistanceLimitTypeProcessor | Bepu API",
    "keywords": "Class CenterDistanceLimitTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of distance servos. public class CenterDistanceLimitTypeProcessor : TwoBodyTypeProcessor<CenterDistanceLimitPrestepData, Vector<float>, CenterDistanceLimitFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>> TwoBodyTypeProcessor<CenterDistanceLimitPrestepData, Vector<float>, CenterDistanceLimitFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear> CenterDistanceLimitTypeProcessor Inherited Members TwoBodyTypeProcessor<CenterDistanceLimitPrestepData, Vector<float>, CenterDistanceLimitFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.InternalBodiesPerConstraint TwoBodyTypeProcessor<CenterDistanceLimitPrestepData, Vector<float>, CenterDistanceLimitFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<CenterDistanceLimitPrestepData, Vector<float>, CenterDistanceLimitFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<CenterDistanceLimitPrestepData, Vector<float>, CenterDistanceLimitFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<CenterDistanceLimitPrestepData, Vector<float>, CenterDistanceLimitFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref CenterDistanceLimitPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref CenterDistanceLimitPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, CenterDistanceLimitPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 55 Field Value int"
  },
  "api/BepuPhysics.Constraints.CenterDistancePrestepData.html": {
    "href": "api/BepuPhysics.Constraints.CenterDistancePrestepData.html",
    "title": "Struct CenterDistancePrestepData | Bepu API",
    "keywords": "Struct CenterDistancePrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct CenterDistancePrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide TargetDistance public Vector<float> TargetDistance Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.CenterDistanceTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.CenterDistanceTypeProcessor.html",
    "title": "Class CenterDistanceTypeProcessor | Bepu API",
    "keywords": "Class CenterDistanceTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of distance servos. public class CenterDistanceTypeProcessor : TwoBodyTypeProcessor<CenterDistancePrestepData, Vector<float>, CenterDistanceConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>> TwoBodyTypeProcessor<CenterDistancePrestepData, Vector<float>, CenterDistanceConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear> CenterDistanceTypeProcessor Inherited Members TwoBodyTypeProcessor<CenterDistancePrestepData, Vector<float>, CenterDistanceConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.InternalBodiesPerConstraint TwoBodyTypeProcessor<CenterDistancePrestepData, Vector<float>, CenterDistanceConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<CenterDistancePrestepData, Vector<float>, CenterDistanceConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<CenterDistancePrestepData, Vector<float>, CenterDistanceConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<CenterDistancePrestepData, Vector<float>, CenterDistanceConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref CenterDistancePrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref CenterDistancePrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, CenterDistancePrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 35 Field Value int"
  },
  "api/BepuPhysics.Constraints.ConstraintChecker.html": {
    "href": "api/BepuPhysics.Constraints.ConstraintChecker.html",
    "title": "Class ConstraintChecker | Bepu API",
    "keywords": "Class ConstraintChecker Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public static class ConstraintChecker Inheritance object ConstraintChecker Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AssertUnitLength(Quaternion, string, string) [Conditional(\"DEBUG\")] public static void AssertUnitLength(Quaternion q, string typeName, string propertyName) Parameters q Quaternion typeName string propertyName string AssertUnitLength(Vector3, string, string) [Conditional(\"DEBUG\")] public static void AssertUnitLength(Vector3 v, string typeName, string propertyName) Parameters v Vector3 typeName string propertyName string AssertValid(in MotorSettings, string) [Conditional(\"DEBUG\")] public static void AssertValid(in MotorSettings settings, string typeName) Parameters settings MotorSettings typeName string AssertValid(in ServoSettings, in SpringSettings, string) [Conditional(\"DEBUG\")] public static void AssertValid(in ServoSettings servoSettings, in SpringSettings springSettings, string typeName) Parameters servoSettings ServoSettings springSettings SpringSettings typeName string AssertValid(in ServoSettings, string) [Conditional(\"DEBUG\")] public static void AssertValid(in ServoSettings settings, string typeName) Parameters settings ServoSettings typeName string AssertValid(in SpringSettings, string) [Conditional(\"DEBUG\")] public static void AssertValid(in SpringSettings settings, string typeName) Parameters settings SpringSettings typeName string IsFiniteNumber(float) Checks if a value is a finite number- neither infinite nor NaN. public static bool IsFiniteNumber(float value) Parameters value float Value to check. Returns bool True if the value is neither infinite nor NaN, false otherwise. IsNegativeNumber(float) Checks if a value is a finite value less than zero and not NaN. public static bool IsNegativeNumber(float value) Parameters value float Value to check. Returns bool True if the value is a finite number less than zero and not NaN, false otherwise. IsNonnegativeNumber(float) Checks if a value is a finite value greater than or equal to zero and not NaN. public static bool IsNonnegativeNumber(float value) Parameters value float Value to check. Returns bool True if the value is a finite number greater than or equal to zero and not NaN, false otherwise. IsNonpositiveNumber(float) Checks if a value is a finite value less than or equal to zero and not NaN. public static bool IsNonpositiveNumber(float value) Parameters value float Value to check. Returns bool True if the value is a finite number less than or equal to zero and not NaN, false otherwise. IsPositiveNumber(float) Checks if a value is a finite value greater than zero and not NaN. public static bool IsPositiveNumber(float value) Parameters value float Value to check. Returns bool True if the value is a finite number greater than zero and not NaN, false otherwise."
  },
  "api/BepuPhysics.Constraints.Contact.ConstraintContactData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.ConstraintContactData.html",
    "title": "Struct ConstraintContactData | Bepu API",
    "keywords": "Struct ConstraintContactData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct ConstraintContactData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields OffsetA public Vector3 OffsetA Field Value Vector3 PenetrationDepth public float PenetrationDepth Field Value float"
  },
  "api/BepuPhysics.Constraints.Contact.Contact1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact1.html",
    "title": "Struct Contact1 | Bepu API",
    "keywords": "Struct Contact1 Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact1 : IConvexTwoBodyContactConstraintDescription<Contact1>, ITwoBodyConstraintDescription<Contact1>, IConstraintDescription<Contact1> Implements IConvexTwoBodyContactConstraintDescription<Contact1> ITwoBodyConstraintDescription<Contact1> IConstraintDescription<Contact1> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConstraintContactData Contact0 Field Value ConstraintContactData FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float Normal public Vector3 Normal Field Value Vector3 OffsetB public Vector3 OffsetB Field Value Vector3 SpringSettings public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact1) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact1 description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact1 Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 offsetB, ref Vector3 normal, ref PairMaterialProperties material) Parameters offsetB Vector3 normal Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetFirstContact(ref Contact1) public static ref ConstraintContactData GetFirstContact(ref Contact1 description) Parameters description Contact1 Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact1AccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact1AccumulatedImpulses.html",
    "title": "Struct Contact1AccumulatedImpulses | Bepu API",
    "keywords": "Struct Contact1AccumulatedImpulses Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact1AccumulatedImpulses : IConvexContactAccumulatedImpulses<Contact1AccumulatedImpulses>, IContactAccumulatedImpulses<Contact1AccumulatedImpulses> Implements IConvexContactAccumulatedImpulses<Contact1AccumulatedImpulses> IContactAccumulatedImpulses<Contact1AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Penetration0 public Vector<float> Penetration0 Field Value Vector<float> Tangent public Vector2Wide Tangent Field Value Vector2Wide Twist public Vector<float> Twist Field Value Vector<float> Properties ContactCount public static int ContactCount { get; } Property Value int Methods GetPenetrationImpulseForContact(ref Contact1AccumulatedImpulses, int) public static ref Vector<float> GetPenetrationImpulseForContact(ref Contact1AccumulatedImpulses impulses, int index) Parameters impulses Contact1AccumulatedImpulses index int Returns Vector<float> GetTangentFriction(ref Contact1AccumulatedImpulses) public static ref Vector2Wide GetTangentFriction(ref Contact1AccumulatedImpulses impulses) Parameters impulses Contact1AccumulatedImpulses Returns Vector2Wide GetTwistFriction(ref Contact1AccumulatedImpulses) public static ref Vector<float> GetTwistFriction(ref Contact1AccumulatedImpulses impulses) Parameters impulses Contact1AccumulatedImpulses Returns Vector<float>"
  },
  "api/BepuPhysics.Constraints.Contact.Contact1Functions.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact1Functions.html",
    "title": "Struct Contact1Functions | Bepu API",
    "keywords": "Struct Contact1Functions Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact1Functions : ITwoBodyConstraintFunctions<Contact1PrestepData, Contact1AccumulatedImpulses> Implements ITwoBodyConstraintFunctions<Contact1PrestepData, Contact1AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref Contact1PrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocityA, in BodyVelocityWide velocityB, ref Contact1PrestepData prestep) Parameters dt Vector<float> velocityA BodyVelocityWide velocityB BodyVelocityWide prestep Contact1PrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref Contact1PrestepData, ref Contact1AccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref Contact1PrestepData prestep, ref Contact1AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep Contact1PrestepData accumulatedImpulses Contact1AccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref Contact1PrestepData, ref Contact1AccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref Contact1PrestepData prestep, ref Contact1AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep Contact1PrestepData accumulatedImpulses Contact1AccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact1OneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact1OneBody.html",
    "title": "Struct Contact1OneBody | Bepu API",
    "keywords": "Struct Contact1OneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact1OneBody : IConvexOneBodyContactConstraintDescription<Contact1OneBody>, IOneBodyConstraintDescription<Contact1OneBody>, IConstraintDescription<Contact1OneBody> Implements IConvexOneBodyContactConstraintDescription<Contact1OneBody> IOneBodyConstraintDescription<Contact1OneBody> IConstraintDescription<Contact1OneBody> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConstraintContactData Contact0 Field Value ConstraintContactData FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float Normal public Vector3 Normal Field Value Vector3 SpringSettings public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact1OneBody) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact1OneBody description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact1OneBody Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 normal, ref PairMaterialProperties material) Parameters normal Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetFirstContact(ref Contact1OneBody) public static ref ConstraintContactData GetFirstContact(ref Contact1OneBody description) Parameters description Contact1OneBody Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact1OneBodyFunctions.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact1OneBodyFunctions.html",
    "title": "Struct Contact1OneBodyFunctions | Bepu API",
    "keywords": "Struct Contact1OneBodyFunctions Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact1OneBodyFunctions : IOneBodyConstraintFunctions<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses> Implements IOneBodyConstraintFunctions<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref Contact1OneBodyPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocityA, ref Contact1OneBodyPrestepData prestep) Parameters dt Vector<float> velocityA BodyVelocityWide prestep Contact1OneBodyPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref Contact1OneBodyPrestepData, ref Contact1AccumulatedImpulses, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref Contact1OneBodyPrestepData prestep, ref Contact1AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep Contact1OneBodyPrestepData accumulatedImpulses Contact1AccumulatedImpulses wsvA BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref Contact1OneBodyPrestepData, ref Contact1AccumulatedImpulses, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref Contact1OneBodyPrestepData prestep, ref Contact1AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep Contact1OneBodyPrestepData accumulatedImpulses Contact1AccumulatedImpulses wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact1OneBodyPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact1OneBodyPrestepData.html",
    "title": "Struct Contact1OneBodyPrestepData | Bepu API",
    "keywords": "Struct Contact1OneBodyPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact1OneBodyPrestepData : IConvexContactPrestep<Contact1OneBodyPrestepData>, IContactPrestep<Contact1OneBodyPrestepData> Implements IConvexContactPrestep<Contact1OneBodyPrestepData> IContactPrestep<Contact1OneBodyPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConvexContactWide Contact0 Field Value ConvexContactWide MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Normal public Vector3Wide Normal Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact1OneBodyPrestepData, int) public static ref ConvexContactWide GetContact(ref Contact1OneBodyPrestepData prestep, int index) Parameters prestep Contact1OneBodyPrestepData index int Returns ConvexContactWide GetMaterialProperties(ref Contact1OneBodyPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact1OneBodyPrestepData prestep) Parameters prestep Contact1OneBodyPrestepData Returns MaterialPropertiesWide GetNormal(ref Contact1OneBodyPrestepData) public static ref Vector3Wide GetNormal(ref Contact1OneBodyPrestepData prestep) Parameters prestep Contact1OneBodyPrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact1OneBodyTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact1OneBodyTypeProcessor.html",
    "title": "Class Contact1OneBodyTypeProcessor | Bepu API",
    "keywords": "Class Contact1OneBodyTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 1-contact one body manifold constraints. public class Contact1OneBodyTypeProcessor : OneBodyContactTypeProcessor<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses, Contact1OneBodyFunctions> Inheritance object TypeProcessor TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses> OneBodyTypeProcessor<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses, Contact1OneBodyFunctions, AccessNoPose, AccessNoPose> OneBodyContactTypeProcessor<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses, Contact1OneBodyFunctions> Contact1OneBodyTypeProcessor Inherited Members OneBodyTypeProcessor<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses, Contact1OneBodyFunctions, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint OneBodyTypeProcessor<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses, Contact1OneBodyFunctions, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses, Contact1OneBodyFunctions, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses, Contact1OneBodyFunctions, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<Contact1OneBodyPrestepData, Contact1AccumulatedImpulses, Contact1OneBodyFunctions, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.Move(ref Vector<int>, ref Contact1OneBodyPrestepData, ref Contact1AccumulatedImpulses, ConstraintHandle, int, ref Vector<int>, ref Contact1OneBodyPrestepData, ref Contact1AccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact1OneBodyPrestepData, Contact1AccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 0 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact1PrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact1PrestepData.html",
    "title": "Struct Contact1PrestepData | Bepu API",
    "keywords": "Struct Contact1PrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact1PrestepData : ITwoBodyConvexContactPrestep<Contact1PrestepData>, IConvexContactPrestep<Contact1PrestepData>, IContactPrestep<Contact1PrestepData> Implements ITwoBodyConvexContactPrestep<Contact1PrestepData> IConvexContactPrestep<Contact1PrestepData> IContactPrestep<Contact1PrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConvexContactWide Contact0 Field Value ConvexContactWide MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Normal public Vector3Wide Normal Field Value Vector3Wide OffsetB public Vector3Wide OffsetB Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact1PrestepData, int) public static ref ConvexContactWide GetContact(ref Contact1PrestepData prestep, int index) Parameters prestep Contact1PrestepData index int Returns ConvexContactWide GetMaterialProperties(ref Contact1PrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact1PrestepData prestep) Parameters prestep Contact1PrestepData Returns MaterialPropertiesWide GetNormal(ref Contact1PrestepData) public static ref Vector3Wide GetNormal(ref Contact1PrestepData prestep) Parameters prestep Contact1PrestepData Returns Vector3Wide GetOffsetB(ref Contact1PrestepData) public static ref Vector3Wide GetOffsetB(ref Contact1PrestepData prestep) Parameters prestep Contact1PrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact1TypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact1TypeProcessor.html",
    "title": "Class Contact1TypeProcessor | Bepu API",
    "keywords": "Class Contact1TypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 1-contact two body manifold constraints. public class Contact1TypeProcessor : TwoBodyContactTypeProcessor<Contact1PrestepData, Contact1AccumulatedImpulses, Contact1Functions> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses> TwoBodyTypeProcessor<Contact1PrestepData, Contact1AccumulatedImpulses, Contact1Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose> TwoBodyContactTypeProcessor<Contact1PrestepData, Contact1AccumulatedImpulses, Contact1Functions> Contact1TypeProcessor Inherited Members TwoBodyTypeProcessor<Contact1PrestepData, Contact1AccumulatedImpulses, Contact1Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<Contact1PrestepData, Contact1AccumulatedImpulses, Contact1Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<Contact1PrestepData, Contact1AccumulatedImpulses, Contact1Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<Contact1PrestepData, Contact1AccumulatedImpulses, Contact1Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<Contact1PrestepData, Contact1AccumulatedImpulses, Contact1Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.Move(ref TwoBodyReferences, ref Contact1PrestepData, ref Contact1AccumulatedImpulses, ConstraintHandle, int, ref TwoBodyReferences, ref Contact1PrestepData, ref Contact1AccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact1PrestepData, Contact1AccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 4 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2.html",
    "title": "Struct Contact2 | Bepu API",
    "keywords": "Struct Contact2 Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2 : IConvexTwoBodyContactConstraintDescription<Contact2>, ITwoBodyConstraintDescription<Contact2>, IConstraintDescription<Contact2> Implements IConvexTwoBodyContactConstraintDescription<Contact2> ITwoBodyConstraintDescription<Contact2> IConstraintDescription<Contact2> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConstraintContactData Contact0 Field Value ConstraintContactData Contact1 public ConstraintContactData Contact1 Field Value ConstraintContactData FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float Normal public Vector3 Normal Field Value Vector3 OffsetB public Vector3 OffsetB Field Value Vector3 SpringSettings public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact2) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact2 description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact2 Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 offsetB, ref Vector3 normal, ref PairMaterialProperties material) Parameters offsetB Vector3 normal Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetFirstContact(ref Contact2) public static ref ConstraintContactData GetFirstContact(ref Contact2 description) Parameters description Contact2 Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2AccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2AccumulatedImpulses.html",
    "title": "Struct Contact2AccumulatedImpulses | Bepu API",
    "keywords": "Struct Contact2AccumulatedImpulses Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2AccumulatedImpulses : IConvexContactAccumulatedImpulses<Contact2AccumulatedImpulses>, IContactAccumulatedImpulses<Contact2AccumulatedImpulses> Implements IConvexContactAccumulatedImpulses<Contact2AccumulatedImpulses> IContactAccumulatedImpulses<Contact2AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Penetration0 public Vector<float> Penetration0 Field Value Vector<float> Penetration1 public Vector<float> Penetration1 Field Value Vector<float> Tangent public Vector2Wide Tangent Field Value Vector2Wide Twist public Vector<float> Twist Field Value Vector<float> Properties ContactCount public static int ContactCount { get; } Property Value int Methods GetPenetrationImpulseForContact(ref Contact2AccumulatedImpulses, int) public static ref Vector<float> GetPenetrationImpulseForContact(ref Contact2AccumulatedImpulses impulses, int index) Parameters impulses Contact2AccumulatedImpulses index int Returns Vector<float> GetTangentFriction(ref Contact2AccumulatedImpulses) public static ref Vector2Wide GetTangentFriction(ref Contact2AccumulatedImpulses impulses) Parameters impulses Contact2AccumulatedImpulses Returns Vector2Wide GetTwistFriction(ref Contact2AccumulatedImpulses) public static ref Vector<float> GetTwistFriction(ref Contact2AccumulatedImpulses impulses) Parameters impulses Contact2AccumulatedImpulses Returns Vector<float>"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2Functions.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2Functions.html",
    "title": "Struct Contact2Functions | Bepu API",
    "keywords": "Struct Contact2Functions Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2Functions : ITwoBodyConstraintFunctions<Contact2PrestepData, Contact2AccumulatedImpulses> Implements ITwoBodyConstraintFunctions<Contact2PrestepData, Contact2AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref Contact2PrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocityA, in BodyVelocityWide velocityB, ref Contact2PrestepData prestep) Parameters dt Vector<float> velocityA BodyVelocityWide velocityB BodyVelocityWide prestep Contact2PrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref Contact2PrestepData, ref Contact2AccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref Contact2PrestepData prestep, ref Contact2AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep Contact2PrestepData accumulatedImpulses Contact2AccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref Contact2PrestepData, ref Contact2AccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref Contact2PrestepData prestep, ref Contact2AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep Contact2PrestepData accumulatedImpulses Contact2AccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2Nonconvex.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2Nonconvex.html",
    "title": "Struct Contact2Nonconvex | Bepu API",
    "keywords": "Struct Contact2Nonconvex Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2Nonconvex : INonconvexTwoBodyContactConstraintDescription<Contact2Nonconvex>, ITwoBodyConstraintDescription<Contact2Nonconvex>, IConstraintDescription<Contact2Nonconvex> Implements INonconvexTwoBodyContactConstraintDescription<Contact2Nonconvex> ITwoBodyConstraintDescription<Contact2Nonconvex> IConstraintDescription<Contact2Nonconvex> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Common public NonconvexTwoBodyManifoldConstraintProperties Common Field Value NonconvexTwoBodyManifoldConstraintProperties Contact0 public NonconvexConstraintContactData Contact0 Field Value NonconvexConstraintContactData Contact1 public NonconvexConstraintContactData Contact1 Field Value NonconvexConstraintContactData Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact2Nonconvex) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact2Nonconvex description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact2Nonconvex Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 offsetB, ref PairMaterialProperties material) Parameters offsetB Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetCommonProperties(ref Contact2Nonconvex) public static ref NonconvexTwoBodyManifoldConstraintProperties GetCommonProperties(ref Contact2Nonconvex description) Parameters description Contact2Nonconvex Returns NonconvexTwoBodyManifoldConstraintProperties GetFirstContact(ref Contact2Nonconvex) public static ref NonconvexConstraintContactData GetFirstContact(ref Contact2Nonconvex description) Parameters description Contact2Nonconvex Returns NonconvexConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2NonconvexAccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2NonconvexAccumulatedImpulses.html",
    "title": "Struct Contact2NonconvexAccumulatedImpulses | Bepu API",
    "keywords": "Struct Contact2NonconvexAccumulatedImpulses Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2NonconvexAccumulatedImpulses : INonconvexContactAccumulatedImpulses<Contact2NonconvexAccumulatedImpulses>, IContactAccumulatedImpulses<Contact2NonconvexAccumulatedImpulses> Implements INonconvexContactAccumulatedImpulses<Contact2NonconvexAccumulatedImpulses> IContactAccumulatedImpulses<Contact2NonconvexAccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public NonconvexAccumulatedImpulses Contact0 Field Value NonconvexAccumulatedImpulses Contact1 public NonconvexAccumulatedImpulses Contact1 Field Value NonconvexAccumulatedImpulses Properties ContactCount public static int ContactCount { get; } Property Value int Methods GetImpulsesForContact(ref Contact2NonconvexAccumulatedImpulses, int) public static ref NonconvexAccumulatedImpulses GetImpulsesForContact(ref Contact2NonconvexAccumulatedImpulses impulses, int index) Parameters impulses Contact2NonconvexAccumulatedImpulses index int Returns NonconvexAccumulatedImpulses"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2NonconvexOneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2NonconvexOneBody.html",
    "title": "Struct Contact2NonconvexOneBody | Bepu API",
    "keywords": "Struct Contact2NonconvexOneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2NonconvexOneBody : INonconvexOneBodyContactConstraintDescription<Contact2NonconvexOneBody>, IOneBodyConstraintDescription<Contact2NonconvexOneBody>, IConstraintDescription<Contact2NonconvexOneBody> Implements INonconvexOneBodyContactConstraintDescription<Contact2NonconvexOneBody> IOneBodyConstraintDescription<Contact2NonconvexOneBody> IConstraintDescription<Contact2NonconvexOneBody> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Common public NonconvexOneBodyManifoldConstraintProperties Common Field Value NonconvexOneBodyManifoldConstraintProperties Contact0 public NonconvexConstraintContactData Contact0 Field Value NonconvexConstraintContactData Contact1 public NonconvexConstraintContactData Contact1 Field Value NonconvexConstraintContactData Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact2NonconvexOneBody) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact2NonconvexOneBody description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact2NonconvexOneBody Description of the constraint. CopyManifoldWideProperties(ref PairMaterialProperties) public void CopyManifoldWideProperties(ref PairMaterialProperties material) Parameters material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetCommonProperties(ref Contact2NonconvexOneBody) public static ref NonconvexOneBodyManifoldConstraintProperties GetCommonProperties(ref Contact2NonconvexOneBody description) Parameters description Contact2NonconvexOneBody Returns NonconvexOneBodyManifoldConstraintProperties GetFirstContact(ref Contact2NonconvexOneBody) public static ref NonconvexConstraintContactData GetFirstContact(ref Contact2NonconvexOneBody description) Parameters description Contact2NonconvexOneBody Returns NonconvexConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2NonconvexOneBodyPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2NonconvexOneBodyPrestepData.html",
    "title": "Struct Contact2NonconvexOneBodyPrestepData | Bepu API",
    "keywords": "Struct Contact2NonconvexOneBodyPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2NonconvexOneBodyPrestepData : INonconvexContactPrestep<Contact2NonconvexOneBodyPrestepData>, IContactPrestep<Contact2NonconvexOneBodyPrestepData> Implements INonconvexContactPrestep<Contact2NonconvexOneBodyPrestepData> IContactPrestep<Contact2NonconvexOneBodyPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public NonconvexContactPrestepData Contact0 Field Value NonconvexContactPrestepData Contact1 public NonconvexContactPrestepData Contact1 Field Value NonconvexContactPrestepData MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact2NonconvexOneBodyPrestepData, int) public static ref NonconvexContactPrestepData GetContact(ref Contact2NonconvexOneBodyPrestepData prestep, int index) Parameters prestep Contact2NonconvexOneBodyPrestepData index int Returns NonconvexContactPrestepData GetMaterialProperties(ref Contact2NonconvexOneBodyPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact2NonconvexOneBodyPrestepData prestep) Parameters prestep Contact2NonconvexOneBodyPrestepData Returns MaterialPropertiesWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2NonconvexOneBodyTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2NonconvexOneBodyTypeProcessor.html",
    "title": "Class Contact2NonconvexOneBodyTypeProcessor | Bepu API",
    "keywords": "Class Contact2NonconvexOneBodyTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 2-contact nonconvex one body manifold constraints. public class Contact2NonconvexOneBodyTypeProcessor : OneBodyContactTypeProcessor<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>> Inheritance object TypeProcessor TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses> OneBodyTypeProcessor<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose> OneBodyContactTypeProcessor<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>> Contact2NonconvexOneBodyTypeProcessor Inherited Members OneBodyTypeProcessor<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint OneBodyTypeProcessor<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.Move(ref Vector<int>, ref Contact2NonconvexOneBodyPrestepData, ref Contact2NonconvexAccumulatedImpulses, ConstraintHandle, int, ref Vector<int>, ref Contact2NonconvexOneBodyPrestepData, ref Contact2NonconvexAccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact2NonconvexOneBodyPrestepData, Contact2NonconvexAccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 8 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2NonconvexPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2NonconvexPrestepData.html",
    "title": "Struct Contact2NonconvexPrestepData | Bepu API",
    "keywords": "Struct Contact2NonconvexPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2NonconvexPrestepData : ITwoBodyNonconvexContactPrestep<Contact2NonconvexPrestepData>, INonconvexContactPrestep<Contact2NonconvexPrestepData>, IContactPrestep<Contact2NonconvexPrestepData> Implements ITwoBodyNonconvexContactPrestep<Contact2NonconvexPrestepData> INonconvexContactPrestep<Contact2NonconvexPrestepData> IContactPrestep<Contact2NonconvexPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public NonconvexContactPrestepData Contact0 Field Value NonconvexContactPrestepData Contact1 public NonconvexContactPrestepData Contact1 Field Value NonconvexContactPrestepData MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide OffsetB public Vector3Wide OffsetB Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact2NonconvexPrestepData, int) public static ref NonconvexContactPrestepData GetContact(ref Contact2NonconvexPrestepData prestep, int index) Parameters prestep Contact2NonconvexPrestepData index int Returns NonconvexContactPrestepData GetMaterialProperties(ref Contact2NonconvexPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact2NonconvexPrestepData prestep) Parameters prestep Contact2NonconvexPrestepData Returns MaterialPropertiesWide GetOffsetB(ref Contact2NonconvexPrestepData) public static ref Vector3Wide GetOffsetB(ref Contact2NonconvexPrestepData prestep) Parameters prestep Contact2NonconvexPrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2NonconvexTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2NonconvexTypeProcessor.html",
    "title": "Class Contact2NonconvexTypeProcessor | Bepu API",
    "keywords": "Class Contact2NonconvexTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 2-contact nonconvex two body manifold constraints. public class Contact2NonconvexTypeProcessor : TwoBodyContactTypeProcessor<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses> TwoBodyTypeProcessor<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose> TwoBodyContactTypeProcessor<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>> Contact2NonconvexTypeProcessor Inherited Members TwoBodyTypeProcessor<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.Move(ref TwoBodyReferences, ref Contact2NonconvexPrestepData, ref Contact2NonconvexAccumulatedImpulses, ConstraintHandle, int, ref TwoBodyReferences, ref Contact2NonconvexPrestepData, ref Contact2NonconvexAccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact2NonconvexPrestepData, Contact2NonconvexAccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 15 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2OneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2OneBody.html",
    "title": "Struct Contact2OneBody | Bepu API",
    "keywords": "Struct Contact2OneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2OneBody : IConvexOneBodyContactConstraintDescription<Contact2OneBody>, IOneBodyConstraintDescription<Contact2OneBody>, IConstraintDescription<Contact2OneBody> Implements IConvexOneBodyContactConstraintDescription<Contact2OneBody> IOneBodyConstraintDescription<Contact2OneBody> IConstraintDescription<Contact2OneBody> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConstraintContactData Contact0 Field Value ConstraintContactData Contact1 public ConstraintContactData Contact1 Field Value ConstraintContactData FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float Normal public Vector3 Normal Field Value Vector3 SpringSettings public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact2OneBody) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact2OneBody description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact2OneBody Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 normal, ref PairMaterialProperties material) Parameters normal Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetFirstContact(ref Contact2OneBody) public static ref ConstraintContactData GetFirstContact(ref Contact2OneBody description) Parameters description Contact2OneBody Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2OneBodyFunctions.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2OneBodyFunctions.html",
    "title": "Struct Contact2OneBodyFunctions | Bepu API",
    "keywords": "Struct Contact2OneBodyFunctions Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2OneBodyFunctions : IOneBodyConstraintFunctions<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses> Implements IOneBodyConstraintFunctions<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref Contact2OneBodyPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocityA, ref Contact2OneBodyPrestepData prestep) Parameters dt Vector<float> velocityA BodyVelocityWide prestep Contact2OneBodyPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref Contact2OneBodyPrestepData, ref Contact2AccumulatedImpulses, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref Contact2OneBodyPrestepData prestep, ref Contact2AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep Contact2OneBodyPrestepData accumulatedImpulses Contact2AccumulatedImpulses wsvA BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref Contact2OneBodyPrestepData, ref Contact2AccumulatedImpulses, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref Contact2OneBodyPrestepData prestep, ref Contact2AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep Contact2OneBodyPrestepData accumulatedImpulses Contact2AccumulatedImpulses wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2OneBodyPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2OneBodyPrestepData.html",
    "title": "Struct Contact2OneBodyPrestepData | Bepu API",
    "keywords": "Struct Contact2OneBodyPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2OneBodyPrestepData : IConvexContactPrestep<Contact2OneBodyPrestepData>, IContactPrestep<Contact2OneBodyPrestepData> Implements IConvexContactPrestep<Contact2OneBodyPrestepData> IContactPrestep<Contact2OneBodyPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConvexContactWide Contact0 Field Value ConvexContactWide Contact1 public ConvexContactWide Contact1 Field Value ConvexContactWide MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Normal public Vector3Wide Normal Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact2OneBodyPrestepData, int) public static ref ConvexContactWide GetContact(ref Contact2OneBodyPrestepData prestep, int index) Parameters prestep Contact2OneBodyPrestepData index int Returns ConvexContactWide GetMaterialProperties(ref Contact2OneBodyPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact2OneBodyPrestepData prestep) Parameters prestep Contact2OneBodyPrestepData Returns MaterialPropertiesWide GetNormal(ref Contact2OneBodyPrestepData) public static ref Vector3Wide GetNormal(ref Contact2OneBodyPrestepData prestep) Parameters prestep Contact2OneBodyPrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2OneBodyTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2OneBodyTypeProcessor.html",
    "title": "Class Contact2OneBodyTypeProcessor | Bepu API",
    "keywords": "Class Contact2OneBodyTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 2-contact one body manifold constraints. public class Contact2OneBodyTypeProcessor : OneBodyContactTypeProcessor<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses, Contact2OneBodyFunctions> Inheritance object TypeProcessor TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses> OneBodyTypeProcessor<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses, Contact2OneBodyFunctions, AccessNoPose, AccessNoPose> OneBodyContactTypeProcessor<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses, Contact2OneBodyFunctions> Contact2OneBodyTypeProcessor Inherited Members OneBodyTypeProcessor<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses, Contact2OneBodyFunctions, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint OneBodyTypeProcessor<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses, Contact2OneBodyFunctions, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses, Contact2OneBodyFunctions, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses, Contact2OneBodyFunctions, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<Contact2OneBodyPrestepData, Contact2AccumulatedImpulses, Contact2OneBodyFunctions, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.Move(ref Vector<int>, ref Contact2OneBodyPrestepData, ref Contact2AccumulatedImpulses, ConstraintHandle, int, ref Vector<int>, ref Contact2OneBodyPrestepData, ref Contact2AccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact2OneBodyPrestepData, Contact2AccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 1 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2PrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2PrestepData.html",
    "title": "Struct Contact2PrestepData | Bepu API",
    "keywords": "Struct Contact2PrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact2PrestepData : ITwoBodyConvexContactPrestep<Contact2PrestepData>, IConvexContactPrestep<Contact2PrestepData>, IContactPrestep<Contact2PrestepData> Implements ITwoBodyConvexContactPrestep<Contact2PrestepData> IConvexContactPrestep<Contact2PrestepData> IContactPrestep<Contact2PrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConvexContactWide Contact0 Field Value ConvexContactWide Contact1 public ConvexContactWide Contact1 Field Value ConvexContactWide MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Normal public Vector3Wide Normal Field Value Vector3Wide OffsetB public Vector3Wide OffsetB Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact2PrestepData, int) public static ref ConvexContactWide GetContact(ref Contact2PrestepData prestep, int index) Parameters prestep Contact2PrestepData index int Returns ConvexContactWide GetMaterialProperties(ref Contact2PrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact2PrestepData prestep) Parameters prestep Contact2PrestepData Returns MaterialPropertiesWide GetNormal(ref Contact2PrestepData) public static ref Vector3Wide GetNormal(ref Contact2PrestepData prestep) Parameters prestep Contact2PrestepData Returns Vector3Wide GetOffsetB(ref Contact2PrestepData) public static ref Vector3Wide GetOffsetB(ref Contact2PrestepData prestep) Parameters prestep Contact2PrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact2TypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact2TypeProcessor.html",
    "title": "Class Contact2TypeProcessor | Bepu API",
    "keywords": "Class Contact2TypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 2-contact two body manifold constraints. public class Contact2TypeProcessor : TwoBodyContactTypeProcessor<Contact2PrestepData, Contact2AccumulatedImpulses, Contact2Functions> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses> TwoBodyTypeProcessor<Contact2PrestepData, Contact2AccumulatedImpulses, Contact2Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose> TwoBodyContactTypeProcessor<Contact2PrestepData, Contact2AccumulatedImpulses, Contact2Functions> Contact2TypeProcessor Inherited Members TwoBodyTypeProcessor<Contact2PrestepData, Contact2AccumulatedImpulses, Contact2Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<Contact2PrestepData, Contact2AccumulatedImpulses, Contact2Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<Contact2PrestepData, Contact2AccumulatedImpulses, Contact2Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<Contact2PrestepData, Contact2AccumulatedImpulses, Contact2Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<Contact2PrestepData, Contact2AccumulatedImpulses, Contact2Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.Move(ref TwoBodyReferences, ref Contact2PrestepData, ref Contact2AccumulatedImpulses, ConstraintHandle, int, ref TwoBodyReferences, ref Contact2PrestepData, ref Contact2AccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact2PrestepData, Contact2AccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 5 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3.html",
    "title": "Struct Contact3 | Bepu API",
    "keywords": "Struct Contact3 Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3 : IConvexTwoBodyContactConstraintDescription<Contact3>, ITwoBodyConstraintDescription<Contact3>, IConstraintDescription<Contact3> Implements IConvexTwoBodyContactConstraintDescription<Contact3> ITwoBodyConstraintDescription<Contact3> IConstraintDescription<Contact3> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConstraintContactData Contact0 Field Value ConstraintContactData Contact1 public ConstraintContactData Contact1 Field Value ConstraintContactData Contact2 public ConstraintContactData Contact2 Field Value ConstraintContactData FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float Normal public Vector3 Normal Field Value Vector3 OffsetB public Vector3 OffsetB Field Value Vector3 SpringSettings public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact3) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact3 description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact3 Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 offsetB, ref Vector3 normal, ref PairMaterialProperties material) Parameters offsetB Vector3 normal Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetFirstContact(ref Contact3) public static ref ConstraintContactData GetFirstContact(ref Contact3 description) Parameters description Contact3 Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3AccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3AccumulatedImpulses.html",
    "title": "Struct Contact3AccumulatedImpulses | Bepu API",
    "keywords": "Struct Contact3AccumulatedImpulses Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3AccumulatedImpulses : IConvexContactAccumulatedImpulses<Contact3AccumulatedImpulses>, IContactAccumulatedImpulses<Contact3AccumulatedImpulses> Implements IConvexContactAccumulatedImpulses<Contact3AccumulatedImpulses> IContactAccumulatedImpulses<Contact3AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Penetration0 public Vector<float> Penetration0 Field Value Vector<float> Penetration1 public Vector<float> Penetration1 Field Value Vector<float> Penetration2 public Vector<float> Penetration2 Field Value Vector<float> Tangent public Vector2Wide Tangent Field Value Vector2Wide Twist public Vector<float> Twist Field Value Vector<float> Properties ContactCount public static int ContactCount { get; } Property Value int Methods GetPenetrationImpulseForContact(ref Contact3AccumulatedImpulses, int) public static ref Vector<float> GetPenetrationImpulseForContact(ref Contact3AccumulatedImpulses impulses, int index) Parameters impulses Contact3AccumulatedImpulses index int Returns Vector<float> GetTangentFriction(ref Contact3AccumulatedImpulses) public static ref Vector2Wide GetTangentFriction(ref Contact3AccumulatedImpulses impulses) Parameters impulses Contact3AccumulatedImpulses Returns Vector2Wide GetTwistFriction(ref Contact3AccumulatedImpulses) public static ref Vector<float> GetTwistFriction(ref Contact3AccumulatedImpulses impulses) Parameters impulses Contact3AccumulatedImpulses Returns Vector<float>"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3Functions.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3Functions.html",
    "title": "Struct Contact3Functions | Bepu API",
    "keywords": "Struct Contact3Functions Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3Functions : ITwoBodyConstraintFunctions<Contact3PrestepData, Contact3AccumulatedImpulses> Implements ITwoBodyConstraintFunctions<Contact3PrestepData, Contact3AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref Contact3PrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocityA, in BodyVelocityWide velocityB, ref Contact3PrestepData prestep) Parameters dt Vector<float> velocityA BodyVelocityWide velocityB BodyVelocityWide prestep Contact3PrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref Contact3PrestepData, ref Contact3AccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref Contact3PrestepData prestep, ref Contact3AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep Contact3PrestepData accumulatedImpulses Contact3AccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref Contact3PrestepData, ref Contact3AccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref Contact3PrestepData prestep, ref Contact3AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep Contact3PrestepData accumulatedImpulses Contact3AccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3Nonconvex.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3Nonconvex.html",
    "title": "Struct Contact3Nonconvex | Bepu API",
    "keywords": "Struct Contact3Nonconvex Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3Nonconvex : INonconvexTwoBodyContactConstraintDescription<Contact3Nonconvex>, ITwoBodyConstraintDescription<Contact3Nonconvex>, IConstraintDescription<Contact3Nonconvex> Implements INonconvexTwoBodyContactConstraintDescription<Contact3Nonconvex> ITwoBodyConstraintDescription<Contact3Nonconvex> IConstraintDescription<Contact3Nonconvex> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Common public NonconvexTwoBodyManifoldConstraintProperties Common Field Value NonconvexTwoBodyManifoldConstraintProperties Contact0 public NonconvexConstraintContactData Contact0 Field Value NonconvexConstraintContactData Contact1 public NonconvexConstraintContactData Contact1 Field Value NonconvexConstraintContactData Contact2 public NonconvexConstraintContactData Contact2 Field Value NonconvexConstraintContactData Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact3Nonconvex) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact3Nonconvex description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact3Nonconvex Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 offsetB, ref PairMaterialProperties material) Parameters offsetB Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetCommonProperties(ref Contact3Nonconvex) public static ref NonconvexTwoBodyManifoldConstraintProperties GetCommonProperties(ref Contact3Nonconvex description) Parameters description Contact3Nonconvex Returns NonconvexTwoBodyManifoldConstraintProperties GetFirstContact(ref Contact3Nonconvex) public static ref NonconvexConstraintContactData GetFirstContact(ref Contact3Nonconvex description) Parameters description Contact3Nonconvex Returns NonconvexConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3NonconvexAccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3NonconvexAccumulatedImpulses.html",
    "title": "Struct Contact3NonconvexAccumulatedImpulses | Bepu API",
    "keywords": "Struct Contact3NonconvexAccumulatedImpulses Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3NonconvexAccumulatedImpulses : INonconvexContactAccumulatedImpulses<Contact3NonconvexAccumulatedImpulses>, IContactAccumulatedImpulses<Contact3NonconvexAccumulatedImpulses> Implements INonconvexContactAccumulatedImpulses<Contact3NonconvexAccumulatedImpulses> IContactAccumulatedImpulses<Contact3NonconvexAccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public NonconvexAccumulatedImpulses Contact0 Field Value NonconvexAccumulatedImpulses Contact1 public NonconvexAccumulatedImpulses Contact1 Field Value NonconvexAccumulatedImpulses Contact2 public NonconvexAccumulatedImpulses Contact2 Field Value NonconvexAccumulatedImpulses Properties ContactCount public static int ContactCount { get; } Property Value int Methods GetImpulsesForContact(ref Contact3NonconvexAccumulatedImpulses, int) public static ref NonconvexAccumulatedImpulses GetImpulsesForContact(ref Contact3NonconvexAccumulatedImpulses impulses, int index) Parameters impulses Contact3NonconvexAccumulatedImpulses index int Returns NonconvexAccumulatedImpulses"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3NonconvexOneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3NonconvexOneBody.html",
    "title": "Struct Contact3NonconvexOneBody | Bepu API",
    "keywords": "Struct Contact3NonconvexOneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3NonconvexOneBody : INonconvexOneBodyContactConstraintDescription<Contact3NonconvexOneBody>, IOneBodyConstraintDescription<Contact3NonconvexOneBody>, IConstraintDescription<Contact3NonconvexOneBody> Implements INonconvexOneBodyContactConstraintDescription<Contact3NonconvexOneBody> IOneBodyConstraintDescription<Contact3NonconvexOneBody> IConstraintDescription<Contact3NonconvexOneBody> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Common public NonconvexOneBodyManifoldConstraintProperties Common Field Value NonconvexOneBodyManifoldConstraintProperties Contact0 public NonconvexConstraintContactData Contact0 Field Value NonconvexConstraintContactData Contact1 public NonconvexConstraintContactData Contact1 Field Value NonconvexConstraintContactData Contact2 public NonconvexConstraintContactData Contact2 Field Value NonconvexConstraintContactData Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact3NonconvexOneBody) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact3NonconvexOneBody description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact3NonconvexOneBody Description of the constraint. CopyManifoldWideProperties(ref PairMaterialProperties) public void CopyManifoldWideProperties(ref PairMaterialProperties material) Parameters material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetCommonProperties(ref Contact3NonconvexOneBody) public static ref NonconvexOneBodyManifoldConstraintProperties GetCommonProperties(ref Contact3NonconvexOneBody description) Parameters description Contact3NonconvexOneBody Returns NonconvexOneBodyManifoldConstraintProperties GetFirstContact(ref Contact3NonconvexOneBody) public static ref NonconvexConstraintContactData GetFirstContact(ref Contact3NonconvexOneBody description) Parameters description Contact3NonconvexOneBody Returns NonconvexConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3NonconvexOneBodyPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3NonconvexOneBodyPrestepData.html",
    "title": "Struct Contact3NonconvexOneBodyPrestepData | Bepu API",
    "keywords": "Struct Contact3NonconvexOneBodyPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3NonconvexOneBodyPrestepData : INonconvexContactPrestep<Contact3NonconvexOneBodyPrestepData>, IContactPrestep<Contact3NonconvexOneBodyPrestepData> Implements INonconvexContactPrestep<Contact3NonconvexOneBodyPrestepData> IContactPrestep<Contact3NonconvexOneBodyPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public NonconvexContactPrestepData Contact0 Field Value NonconvexContactPrestepData Contact1 public NonconvexContactPrestepData Contact1 Field Value NonconvexContactPrestepData Contact2 public NonconvexContactPrestepData Contact2 Field Value NonconvexContactPrestepData MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact3NonconvexOneBodyPrestepData, int) public static ref NonconvexContactPrestepData GetContact(ref Contact3NonconvexOneBodyPrestepData prestep, int index) Parameters prestep Contact3NonconvexOneBodyPrestepData index int Returns NonconvexContactPrestepData GetMaterialProperties(ref Contact3NonconvexOneBodyPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact3NonconvexOneBodyPrestepData prestep) Parameters prestep Contact3NonconvexOneBodyPrestepData Returns MaterialPropertiesWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3NonconvexOneBodyTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3NonconvexOneBodyTypeProcessor.html",
    "title": "Class Contact3NonconvexOneBodyTypeProcessor | Bepu API",
    "keywords": "Class Contact3NonconvexOneBodyTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 3-contact nonconvex one body manifold constraints. public class Contact3NonconvexOneBodyTypeProcessor : OneBodyContactTypeProcessor<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>> Inheritance object TypeProcessor TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses> OneBodyTypeProcessor<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose> OneBodyContactTypeProcessor<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>> Contact3NonconvexOneBodyTypeProcessor Inherited Members OneBodyTypeProcessor<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint OneBodyTypeProcessor<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.Move(ref Vector<int>, ref Contact3NonconvexOneBodyPrestepData, ref Contact3NonconvexAccumulatedImpulses, ConstraintHandle, int, ref Vector<int>, ref Contact3NonconvexOneBodyPrestepData, ref Contact3NonconvexAccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact3NonconvexOneBodyPrestepData, Contact3NonconvexAccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 9 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3NonconvexPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3NonconvexPrestepData.html",
    "title": "Struct Contact3NonconvexPrestepData | Bepu API",
    "keywords": "Struct Contact3NonconvexPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3NonconvexPrestepData : ITwoBodyNonconvexContactPrestep<Contact3NonconvexPrestepData>, INonconvexContactPrestep<Contact3NonconvexPrestepData>, IContactPrestep<Contact3NonconvexPrestepData> Implements ITwoBodyNonconvexContactPrestep<Contact3NonconvexPrestepData> INonconvexContactPrestep<Contact3NonconvexPrestepData> IContactPrestep<Contact3NonconvexPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public NonconvexContactPrestepData Contact0 Field Value NonconvexContactPrestepData Contact1 public NonconvexContactPrestepData Contact1 Field Value NonconvexContactPrestepData Contact2 public NonconvexContactPrestepData Contact2 Field Value NonconvexContactPrestepData MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide OffsetB public Vector3Wide OffsetB Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact3NonconvexPrestepData, int) public static ref NonconvexContactPrestepData GetContact(ref Contact3NonconvexPrestepData prestep, int index) Parameters prestep Contact3NonconvexPrestepData index int Returns NonconvexContactPrestepData GetMaterialProperties(ref Contact3NonconvexPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact3NonconvexPrestepData prestep) Parameters prestep Contact3NonconvexPrestepData Returns MaterialPropertiesWide GetOffsetB(ref Contact3NonconvexPrestepData) public static ref Vector3Wide GetOffsetB(ref Contact3NonconvexPrestepData prestep) Parameters prestep Contact3NonconvexPrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3NonconvexTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3NonconvexTypeProcessor.html",
    "title": "Class Contact3NonconvexTypeProcessor | Bepu API",
    "keywords": "Class Contact3NonconvexTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 3-contact nonconvex two body manifold constraints. public class Contact3NonconvexTypeProcessor : TwoBodyContactTypeProcessor<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses> TwoBodyTypeProcessor<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose> TwoBodyContactTypeProcessor<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>> Contact3NonconvexTypeProcessor Inherited Members TwoBodyTypeProcessor<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.Move(ref TwoBodyReferences, ref Contact3NonconvexPrestepData, ref Contact3NonconvexAccumulatedImpulses, ConstraintHandle, int, ref TwoBodyReferences, ref Contact3NonconvexPrestepData, ref Contact3NonconvexAccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact3NonconvexPrestepData, Contact3NonconvexAccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 16 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3OneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3OneBody.html",
    "title": "Struct Contact3OneBody | Bepu API",
    "keywords": "Struct Contact3OneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3OneBody : IConvexOneBodyContactConstraintDescription<Contact3OneBody>, IOneBodyConstraintDescription<Contact3OneBody>, IConstraintDescription<Contact3OneBody> Implements IConvexOneBodyContactConstraintDescription<Contact3OneBody> IOneBodyConstraintDescription<Contact3OneBody> IConstraintDescription<Contact3OneBody> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConstraintContactData Contact0 Field Value ConstraintContactData Contact1 public ConstraintContactData Contact1 Field Value ConstraintContactData Contact2 public ConstraintContactData Contact2 Field Value ConstraintContactData FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float Normal public Vector3 Normal Field Value Vector3 SpringSettings public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact3OneBody) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact3OneBody description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact3OneBody Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 normal, ref PairMaterialProperties material) Parameters normal Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetFirstContact(ref Contact3OneBody) public static ref ConstraintContactData GetFirstContact(ref Contact3OneBody description) Parameters description Contact3OneBody Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3OneBodyFunctions.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3OneBodyFunctions.html",
    "title": "Struct Contact3OneBodyFunctions | Bepu API",
    "keywords": "Struct Contact3OneBodyFunctions Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3OneBodyFunctions : IOneBodyConstraintFunctions<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses> Implements IOneBodyConstraintFunctions<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref Contact3OneBodyPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocityA, ref Contact3OneBodyPrestepData prestep) Parameters dt Vector<float> velocityA BodyVelocityWide prestep Contact3OneBodyPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref Contact3OneBodyPrestepData, ref Contact3AccumulatedImpulses, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref Contact3OneBodyPrestepData prestep, ref Contact3AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep Contact3OneBodyPrestepData accumulatedImpulses Contact3AccumulatedImpulses wsvA BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref Contact3OneBodyPrestepData, ref Contact3AccumulatedImpulses, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref Contact3OneBodyPrestepData prestep, ref Contact3AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep Contact3OneBodyPrestepData accumulatedImpulses Contact3AccumulatedImpulses wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3OneBodyPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3OneBodyPrestepData.html",
    "title": "Struct Contact3OneBodyPrestepData | Bepu API",
    "keywords": "Struct Contact3OneBodyPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3OneBodyPrestepData : IConvexContactPrestep<Contact3OneBodyPrestepData>, IContactPrestep<Contact3OneBodyPrestepData> Implements IConvexContactPrestep<Contact3OneBodyPrestepData> IContactPrestep<Contact3OneBodyPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConvexContactWide Contact0 Field Value ConvexContactWide Contact1 public ConvexContactWide Contact1 Field Value ConvexContactWide Contact2 public ConvexContactWide Contact2 Field Value ConvexContactWide MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Normal public Vector3Wide Normal Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact3OneBodyPrestepData, int) public static ref ConvexContactWide GetContact(ref Contact3OneBodyPrestepData prestep, int index) Parameters prestep Contact3OneBodyPrestepData index int Returns ConvexContactWide GetMaterialProperties(ref Contact3OneBodyPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact3OneBodyPrestepData prestep) Parameters prestep Contact3OneBodyPrestepData Returns MaterialPropertiesWide GetNormal(ref Contact3OneBodyPrestepData) public static ref Vector3Wide GetNormal(ref Contact3OneBodyPrestepData prestep) Parameters prestep Contact3OneBodyPrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3OneBodyTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3OneBodyTypeProcessor.html",
    "title": "Class Contact3OneBodyTypeProcessor | Bepu API",
    "keywords": "Class Contact3OneBodyTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 3-contact one body manifold constraints. public class Contact3OneBodyTypeProcessor : OneBodyContactTypeProcessor<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses, Contact3OneBodyFunctions> Inheritance object TypeProcessor TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses> OneBodyTypeProcessor<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses, Contact3OneBodyFunctions, AccessNoPose, AccessNoPose> OneBodyContactTypeProcessor<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses, Contact3OneBodyFunctions> Contact3OneBodyTypeProcessor Inherited Members OneBodyTypeProcessor<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses, Contact3OneBodyFunctions, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint OneBodyTypeProcessor<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses, Contact3OneBodyFunctions, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses, Contact3OneBodyFunctions, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses, Contact3OneBodyFunctions, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<Contact3OneBodyPrestepData, Contact3AccumulatedImpulses, Contact3OneBodyFunctions, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.Move(ref Vector<int>, ref Contact3OneBodyPrestepData, ref Contact3AccumulatedImpulses, ConstraintHandle, int, ref Vector<int>, ref Contact3OneBodyPrestepData, ref Contact3AccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact3OneBodyPrestepData, Contact3AccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 2 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3PrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3PrestepData.html",
    "title": "Struct Contact3PrestepData | Bepu API",
    "keywords": "Struct Contact3PrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact3PrestepData : ITwoBodyConvexContactPrestep<Contact3PrestepData>, IConvexContactPrestep<Contact3PrestepData>, IContactPrestep<Contact3PrestepData> Implements ITwoBodyConvexContactPrestep<Contact3PrestepData> IConvexContactPrestep<Contact3PrestepData> IContactPrestep<Contact3PrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConvexContactWide Contact0 Field Value ConvexContactWide Contact1 public ConvexContactWide Contact1 Field Value ConvexContactWide Contact2 public ConvexContactWide Contact2 Field Value ConvexContactWide MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Normal public Vector3Wide Normal Field Value Vector3Wide OffsetB public Vector3Wide OffsetB Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact3PrestepData, int) public static ref ConvexContactWide GetContact(ref Contact3PrestepData prestep, int index) Parameters prestep Contact3PrestepData index int Returns ConvexContactWide GetMaterialProperties(ref Contact3PrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact3PrestepData prestep) Parameters prestep Contact3PrestepData Returns MaterialPropertiesWide GetNormal(ref Contact3PrestepData) public static ref Vector3Wide GetNormal(ref Contact3PrestepData prestep) Parameters prestep Contact3PrestepData Returns Vector3Wide GetOffsetB(ref Contact3PrestepData) public static ref Vector3Wide GetOffsetB(ref Contact3PrestepData prestep) Parameters prestep Contact3PrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact3TypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact3TypeProcessor.html",
    "title": "Class Contact3TypeProcessor | Bepu API",
    "keywords": "Class Contact3TypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 3-contact two body manifold constraints. public class Contact3TypeProcessor : TwoBodyContactTypeProcessor<Contact3PrestepData, Contact3AccumulatedImpulses, Contact3Functions> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses> TwoBodyTypeProcessor<Contact3PrestepData, Contact3AccumulatedImpulses, Contact3Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose> TwoBodyContactTypeProcessor<Contact3PrestepData, Contact3AccumulatedImpulses, Contact3Functions> Contact3TypeProcessor Inherited Members TwoBodyTypeProcessor<Contact3PrestepData, Contact3AccumulatedImpulses, Contact3Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<Contact3PrestepData, Contact3AccumulatedImpulses, Contact3Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<Contact3PrestepData, Contact3AccumulatedImpulses, Contact3Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<Contact3PrestepData, Contact3AccumulatedImpulses, Contact3Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<Contact3PrestepData, Contact3AccumulatedImpulses, Contact3Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.Move(ref TwoBodyReferences, ref Contact3PrestepData, ref Contact3AccumulatedImpulses, ConstraintHandle, int, ref TwoBodyReferences, ref Contact3PrestepData, ref Contact3AccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact3PrestepData, Contact3AccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 6 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4.html",
    "title": "Struct Contact4 | Bepu API",
    "keywords": "Struct Contact4 Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4 : IConvexTwoBodyContactConstraintDescription<Contact4>, ITwoBodyConstraintDescription<Contact4>, IConstraintDescription<Contact4> Implements IConvexTwoBodyContactConstraintDescription<Contact4> ITwoBodyConstraintDescription<Contact4> IConstraintDescription<Contact4> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConstraintContactData Contact0 Field Value ConstraintContactData Contact1 public ConstraintContactData Contact1 Field Value ConstraintContactData Contact2 public ConstraintContactData Contact2 Field Value ConstraintContactData Contact3 public ConstraintContactData Contact3 Field Value ConstraintContactData FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float Normal public Vector3 Normal Field Value Vector3 OffsetB public Vector3 OffsetB Field Value Vector3 SpringSettings public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact4) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact4 description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact4 Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 offsetB, ref Vector3 normal, ref PairMaterialProperties material) Parameters offsetB Vector3 normal Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetFirstContact(ref Contact4) public static ref ConstraintContactData GetFirstContact(ref Contact4 description) Parameters description Contact4 Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4AccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4AccumulatedImpulses.html",
    "title": "Struct Contact4AccumulatedImpulses | Bepu API",
    "keywords": "Struct Contact4AccumulatedImpulses Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4AccumulatedImpulses : IConvexContactAccumulatedImpulses<Contact4AccumulatedImpulses>, IContactAccumulatedImpulses<Contact4AccumulatedImpulses> Implements IConvexContactAccumulatedImpulses<Contact4AccumulatedImpulses> IContactAccumulatedImpulses<Contact4AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Penetration0 public Vector<float> Penetration0 Field Value Vector<float> Penetration1 public Vector<float> Penetration1 Field Value Vector<float> Penetration2 public Vector<float> Penetration2 Field Value Vector<float> Penetration3 public Vector<float> Penetration3 Field Value Vector<float> Tangent public Vector2Wide Tangent Field Value Vector2Wide Twist public Vector<float> Twist Field Value Vector<float> Properties ContactCount public static int ContactCount { get; } Property Value int Methods GetPenetrationImpulseForContact(ref Contact4AccumulatedImpulses, int) public static ref Vector<float> GetPenetrationImpulseForContact(ref Contact4AccumulatedImpulses impulses, int index) Parameters impulses Contact4AccumulatedImpulses index int Returns Vector<float> GetTangentFriction(ref Contact4AccumulatedImpulses) public static ref Vector2Wide GetTangentFriction(ref Contact4AccumulatedImpulses impulses) Parameters impulses Contact4AccumulatedImpulses Returns Vector2Wide GetTwistFriction(ref Contact4AccumulatedImpulses) public static ref Vector<float> GetTwistFriction(ref Contact4AccumulatedImpulses impulses) Parameters impulses Contact4AccumulatedImpulses Returns Vector<float>"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4Functions.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4Functions.html",
    "title": "Struct Contact4Functions | Bepu API",
    "keywords": "Struct Contact4Functions Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4Functions : ITwoBodyConstraintFunctions<Contact4PrestepData, Contact4AccumulatedImpulses> Implements ITwoBodyConstraintFunctions<Contact4PrestepData, Contact4AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref Contact4PrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocityA, in BodyVelocityWide velocityB, ref Contact4PrestepData prestep) Parameters dt Vector<float> velocityA BodyVelocityWide velocityB BodyVelocityWide prestep Contact4PrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref Contact4PrestepData, ref Contact4AccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref Contact4PrestepData prestep, ref Contact4AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep Contact4PrestepData accumulatedImpulses Contact4AccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref Contact4PrestepData, ref Contact4AccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref Contact4PrestepData prestep, ref Contact4AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep Contact4PrestepData accumulatedImpulses Contact4AccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4Nonconvex.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4Nonconvex.html",
    "title": "Struct Contact4Nonconvex | Bepu API",
    "keywords": "Struct Contact4Nonconvex Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4Nonconvex : INonconvexTwoBodyContactConstraintDescription<Contact4Nonconvex>, ITwoBodyConstraintDescription<Contact4Nonconvex>, IConstraintDescription<Contact4Nonconvex> Implements INonconvexTwoBodyContactConstraintDescription<Contact4Nonconvex> ITwoBodyConstraintDescription<Contact4Nonconvex> IConstraintDescription<Contact4Nonconvex> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Common public NonconvexTwoBodyManifoldConstraintProperties Common Field Value NonconvexTwoBodyManifoldConstraintProperties Contact0 public NonconvexConstraintContactData Contact0 Field Value NonconvexConstraintContactData Contact1 public NonconvexConstraintContactData Contact1 Field Value NonconvexConstraintContactData Contact2 public NonconvexConstraintContactData Contact2 Field Value NonconvexConstraintContactData Contact3 public NonconvexConstraintContactData Contact3 Field Value NonconvexConstraintContactData Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact4Nonconvex) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact4Nonconvex description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact4Nonconvex Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 offsetB, ref PairMaterialProperties material) Parameters offsetB Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetCommonProperties(ref Contact4Nonconvex) public static ref NonconvexTwoBodyManifoldConstraintProperties GetCommonProperties(ref Contact4Nonconvex description) Parameters description Contact4Nonconvex Returns NonconvexTwoBodyManifoldConstraintProperties GetFirstContact(ref Contact4Nonconvex) public static ref NonconvexConstraintContactData GetFirstContact(ref Contact4Nonconvex description) Parameters description Contact4Nonconvex Returns NonconvexConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4NonconvexAccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4NonconvexAccumulatedImpulses.html",
    "title": "Struct Contact4NonconvexAccumulatedImpulses | Bepu API",
    "keywords": "Struct Contact4NonconvexAccumulatedImpulses Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4NonconvexAccumulatedImpulses : INonconvexContactAccumulatedImpulses<Contact4NonconvexAccumulatedImpulses>, IContactAccumulatedImpulses<Contact4NonconvexAccumulatedImpulses> Implements INonconvexContactAccumulatedImpulses<Contact4NonconvexAccumulatedImpulses> IContactAccumulatedImpulses<Contact4NonconvexAccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public NonconvexAccumulatedImpulses Contact0 Field Value NonconvexAccumulatedImpulses Contact1 public NonconvexAccumulatedImpulses Contact1 Field Value NonconvexAccumulatedImpulses Contact2 public NonconvexAccumulatedImpulses Contact2 Field Value NonconvexAccumulatedImpulses Contact3 public NonconvexAccumulatedImpulses Contact3 Field Value NonconvexAccumulatedImpulses Properties ContactCount public static int ContactCount { get; } Property Value int Methods GetImpulsesForContact(ref Contact4NonconvexAccumulatedImpulses, int) public static ref NonconvexAccumulatedImpulses GetImpulsesForContact(ref Contact4NonconvexAccumulatedImpulses impulses, int index) Parameters impulses Contact4NonconvexAccumulatedImpulses index int Returns NonconvexAccumulatedImpulses"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4NonconvexOneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4NonconvexOneBody.html",
    "title": "Struct Contact4NonconvexOneBody | Bepu API",
    "keywords": "Struct Contact4NonconvexOneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4NonconvexOneBody : INonconvexOneBodyContactConstraintDescription<Contact4NonconvexOneBody>, IOneBodyConstraintDescription<Contact4NonconvexOneBody>, IConstraintDescription<Contact4NonconvexOneBody> Implements INonconvexOneBodyContactConstraintDescription<Contact4NonconvexOneBody> IOneBodyConstraintDescription<Contact4NonconvexOneBody> IConstraintDescription<Contact4NonconvexOneBody> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Common public NonconvexOneBodyManifoldConstraintProperties Common Field Value NonconvexOneBodyManifoldConstraintProperties Contact0 public NonconvexConstraintContactData Contact0 Field Value NonconvexConstraintContactData Contact1 public NonconvexConstraintContactData Contact1 Field Value NonconvexConstraintContactData Contact2 public NonconvexConstraintContactData Contact2 Field Value NonconvexConstraintContactData Contact3 public NonconvexConstraintContactData Contact3 Field Value NonconvexConstraintContactData Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact4NonconvexOneBody) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact4NonconvexOneBody description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact4NonconvexOneBody Description of the constraint. CopyManifoldWideProperties(ref PairMaterialProperties) public void CopyManifoldWideProperties(ref PairMaterialProperties material) Parameters material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetCommonProperties(ref Contact4NonconvexOneBody) public static ref NonconvexOneBodyManifoldConstraintProperties GetCommonProperties(ref Contact4NonconvexOneBody description) Parameters description Contact4NonconvexOneBody Returns NonconvexOneBodyManifoldConstraintProperties GetFirstContact(ref Contact4NonconvexOneBody) public static ref NonconvexConstraintContactData GetFirstContact(ref Contact4NonconvexOneBody description) Parameters description Contact4NonconvexOneBody Returns NonconvexConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4NonconvexOneBodyPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4NonconvexOneBodyPrestepData.html",
    "title": "Struct Contact4NonconvexOneBodyPrestepData | Bepu API",
    "keywords": "Struct Contact4NonconvexOneBodyPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4NonconvexOneBodyPrestepData : INonconvexContactPrestep<Contact4NonconvexOneBodyPrestepData>, IContactPrestep<Contact4NonconvexOneBodyPrestepData> Implements INonconvexContactPrestep<Contact4NonconvexOneBodyPrestepData> IContactPrestep<Contact4NonconvexOneBodyPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public NonconvexContactPrestepData Contact0 Field Value NonconvexContactPrestepData Contact1 public NonconvexContactPrestepData Contact1 Field Value NonconvexContactPrestepData Contact2 public NonconvexContactPrestepData Contact2 Field Value NonconvexContactPrestepData Contact3 public NonconvexContactPrestepData Contact3 Field Value NonconvexContactPrestepData MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact4NonconvexOneBodyPrestepData, int) public static ref NonconvexContactPrestepData GetContact(ref Contact4NonconvexOneBodyPrestepData prestep, int index) Parameters prestep Contact4NonconvexOneBodyPrestepData index int Returns NonconvexContactPrestepData GetMaterialProperties(ref Contact4NonconvexOneBodyPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact4NonconvexOneBodyPrestepData prestep) Parameters prestep Contact4NonconvexOneBodyPrestepData Returns MaterialPropertiesWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4NonconvexOneBodyTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4NonconvexOneBodyTypeProcessor.html",
    "title": "Class Contact4NonconvexOneBodyTypeProcessor | Bepu API",
    "keywords": "Class Contact4NonconvexOneBodyTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 4-contact nonconvex one body manifold constraints. public class Contact4NonconvexOneBodyTypeProcessor : OneBodyContactTypeProcessor<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>> Inheritance object TypeProcessor TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses> OneBodyTypeProcessor<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose> OneBodyContactTypeProcessor<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>> Contact4NonconvexOneBodyTypeProcessor Inherited Members OneBodyTypeProcessor<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint OneBodyTypeProcessor<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexOneBodyFunctions<Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.Move(ref Vector<int>, ref Contact4NonconvexOneBodyPrestepData, ref Contact4NonconvexAccumulatedImpulses, ConstraintHandle, int, ref Vector<int>, ref Contact4NonconvexOneBodyPrestepData, ref Contact4NonconvexAccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact4NonconvexOneBodyPrestepData, Contact4NonconvexAccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 10 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4NonconvexPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4NonconvexPrestepData.html",
    "title": "Struct Contact4NonconvexPrestepData | Bepu API",
    "keywords": "Struct Contact4NonconvexPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4NonconvexPrestepData : ITwoBodyNonconvexContactPrestep<Contact4NonconvexPrestepData>, INonconvexContactPrestep<Contact4NonconvexPrestepData>, IContactPrestep<Contact4NonconvexPrestepData> Implements ITwoBodyNonconvexContactPrestep<Contact4NonconvexPrestepData> INonconvexContactPrestep<Contact4NonconvexPrestepData> IContactPrestep<Contact4NonconvexPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public NonconvexContactPrestepData Contact0 Field Value NonconvexContactPrestepData Contact1 public NonconvexContactPrestepData Contact1 Field Value NonconvexContactPrestepData Contact2 public NonconvexContactPrestepData Contact2 Field Value NonconvexContactPrestepData Contact3 public NonconvexContactPrestepData Contact3 Field Value NonconvexContactPrestepData MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide OffsetB public Vector3Wide OffsetB Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact4NonconvexPrestepData, int) public static ref NonconvexContactPrestepData GetContact(ref Contact4NonconvexPrestepData prestep, int index) Parameters prestep Contact4NonconvexPrestepData index int Returns NonconvexContactPrestepData GetMaterialProperties(ref Contact4NonconvexPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact4NonconvexPrestepData prestep) Parameters prestep Contact4NonconvexPrestepData Returns MaterialPropertiesWide GetOffsetB(ref Contact4NonconvexPrestepData) public static ref Vector3Wide GetOffsetB(ref Contact4NonconvexPrestepData prestep) Parameters prestep Contact4NonconvexPrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4NonconvexTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4NonconvexTypeProcessor.html",
    "title": "Class Contact4NonconvexTypeProcessor | Bepu API",
    "keywords": "Class Contact4NonconvexTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 4-contact nonconvex two body manifold constraints. public class Contact4NonconvexTypeProcessor : TwoBodyContactTypeProcessor<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses> TwoBodyTypeProcessor<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose> TwoBodyContactTypeProcessor<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>> Contact4NonconvexTypeProcessor Inherited Members TwoBodyTypeProcessor<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses, ContactNonconvexTwoBodyFunctions<Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.Move(ref TwoBodyReferences, ref Contact4NonconvexPrestepData, ref Contact4NonconvexAccumulatedImpulses, ConstraintHandle, int, ref TwoBodyReferences, ref Contact4NonconvexPrestepData, ref Contact4NonconvexAccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact4NonconvexPrestepData, Contact4NonconvexAccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 17 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4OneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4OneBody.html",
    "title": "Struct Contact4OneBody | Bepu API",
    "keywords": "Struct Contact4OneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4OneBody : IConvexOneBodyContactConstraintDescription<Contact4OneBody>, IOneBodyConstraintDescription<Contact4OneBody>, IConstraintDescription<Contact4OneBody> Implements IConvexOneBodyContactConstraintDescription<Contact4OneBody> IOneBodyConstraintDescription<Contact4OneBody> IConstraintDescription<Contact4OneBody> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConstraintContactData Contact0 Field Value ConstraintContactData Contact1 public ConstraintContactData Contact1 Field Value ConstraintContactData Contact2 public ConstraintContactData Contact2 Field Value ConstraintContactData Contact3 public ConstraintContactData Contact3 Field Value ConstraintContactData FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float Normal public Vector3 Normal Field Value Vector3 SpringSettings public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Contact4OneBody) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Contact4OneBody description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Contact4OneBody Description of the constraint. CopyManifoldWideProperties(ref Vector3, ref PairMaterialProperties) public void CopyManifoldWideProperties(ref Vector3 normal, ref PairMaterialProperties material) Parameters normal Vector3 material PairMaterialProperties CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor GetFirstContact(ref Contact4OneBody) public static ref ConstraintContactData GetFirstContact(ref Contact4OneBody description) Parameters description Contact4OneBody Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4OneBodyFunctions.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4OneBodyFunctions.html",
    "title": "Struct Contact4OneBodyFunctions | Bepu API",
    "keywords": "Struct Contact4OneBodyFunctions Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4OneBodyFunctions : IOneBodyConstraintFunctions<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses> Implements IOneBodyConstraintFunctions<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref Contact4OneBodyPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocityA, ref Contact4OneBodyPrestepData prestep) Parameters dt Vector<float> velocityA BodyVelocityWide prestep Contact4OneBodyPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref Contact4OneBodyPrestepData, ref Contact4AccumulatedImpulses, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref Contact4OneBodyPrestepData prestep, ref Contact4AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep Contact4OneBodyPrestepData accumulatedImpulses Contact4AccumulatedImpulses wsvA BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref Contact4OneBodyPrestepData, ref Contact4AccumulatedImpulses, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref Contact4OneBodyPrestepData prestep, ref Contact4AccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep Contact4OneBodyPrestepData accumulatedImpulses Contact4AccumulatedImpulses wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4OneBodyPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4OneBodyPrestepData.html",
    "title": "Struct Contact4OneBodyPrestepData | Bepu API",
    "keywords": "Struct Contact4OneBodyPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4OneBodyPrestepData : IConvexContactPrestep<Contact4OneBodyPrestepData>, IContactPrestep<Contact4OneBodyPrestepData> Implements IConvexContactPrestep<Contact4OneBodyPrestepData> IContactPrestep<Contact4OneBodyPrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConvexContactWide Contact0 Field Value ConvexContactWide Contact1 public ConvexContactWide Contact1 Field Value ConvexContactWide Contact2 public ConvexContactWide Contact2 Field Value ConvexContactWide Contact3 public ConvexContactWide Contact3 Field Value ConvexContactWide MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Normal public Vector3Wide Normal Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact4OneBodyPrestepData, int) public static ref ConvexContactWide GetContact(ref Contact4OneBodyPrestepData prestep, int index) Parameters prestep Contact4OneBodyPrestepData index int Returns ConvexContactWide GetMaterialProperties(ref Contact4OneBodyPrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact4OneBodyPrestepData prestep) Parameters prestep Contact4OneBodyPrestepData Returns MaterialPropertiesWide GetNormal(ref Contact4OneBodyPrestepData) public static ref Vector3Wide GetNormal(ref Contact4OneBodyPrestepData prestep) Parameters prestep Contact4OneBodyPrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4OneBodyTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4OneBodyTypeProcessor.html",
    "title": "Class Contact4OneBodyTypeProcessor | Bepu API",
    "keywords": "Class Contact4OneBodyTypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 4-contact one body manifold constraints. public class Contact4OneBodyTypeProcessor : OneBodyContactTypeProcessor<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses, Contact4OneBodyFunctions> Inheritance object TypeProcessor TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses> OneBodyTypeProcessor<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses, Contact4OneBodyFunctions, AccessNoPose, AccessNoPose> OneBodyContactTypeProcessor<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses, Contact4OneBodyFunctions> Contact4OneBodyTypeProcessor Inherited Members OneBodyTypeProcessor<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses, Contact4OneBodyFunctions, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint OneBodyTypeProcessor<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses, Contact4OneBodyFunctions, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses, Contact4OneBodyFunctions, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses, Contact4OneBodyFunctions, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<Contact4OneBodyPrestepData, Contact4AccumulatedImpulses, Contact4OneBodyFunctions, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.Move(ref Vector<int>, ref Contact4OneBodyPrestepData, ref Contact4AccumulatedImpulses, ConstraintHandle, int, ref Vector<int>, ref Contact4OneBodyPrestepData, ref Contact4AccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, Contact4OneBodyPrestepData, Contact4AccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 3 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4PrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4PrestepData.html",
    "title": "Struct Contact4PrestepData | Bepu API",
    "keywords": "Struct Contact4PrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct Contact4PrestepData : ITwoBodyConvexContactPrestep<Contact4PrestepData>, IConvexContactPrestep<Contact4PrestepData>, IContactPrestep<Contact4PrestepData> Implements ITwoBodyConvexContactPrestep<Contact4PrestepData> IConvexContactPrestep<Contact4PrestepData> IContactPrestep<Contact4PrestepData> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Contact0 public ConvexContactWide Contact0 Field Value ConvexContactWide Contact1 public ConvexContactWide Contact1 Field Value ConvexContactWide Contact2 public ConvexContactWide Contact2 Field Value ConvexContactWide Contact3 public ConvexContactWide Contact3 Field Value ConvexContactWide MaterialProperties public MaterialPropertiesWide MaterialProperties Field Value MaterialPropertiesWide Normal public Vector3Wide Normal Field Value Vector3Wide OffsetB public Vector3Wide OffsetB Field Value Vector3Wide Properties BodyCount public static int BodyCount { get; } Property Value int ContactCount public static int ContactCount { get; } Property Value int Methods GetContact(ref Contact4PrestepData, int) public static ref ConvexContactWide GetContact(ref Contact4PrestepData prestep, int index) Parameters prestep Contact4PrestepData index int Returns ConvexContactWide GetMaterialProperties(ref Contact4PrestepData) public static ref MaterialPropertiesWide GetMaterialProperties(ref Contact4PrestepData prestep) Parameters prestep Contact4PrestepData Returns MaterialPropertiesWide GetNormal(ref Contact4PrestepData) public static ref Vector3Wide GetNormal(ref Contact4PrestepData prestep) Parameters prestep Contact4PrestepData Returns Vector3Wide GetOffsetB(ref Contact4PrestepData) public static ref Vector3Wide GetOffsetB(ref Contact4PrestepData prestep) Parameters prestep Contact4PrestepData Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.Contact4TypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.Contact4TypeProcessor.html",
    "title": "Class Contact4TypeProcessor | Bepu API",
    "keywords": "Class Contact4TypeProcessor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the solve iterations of a bunch of 4-contact two body manifold constraints. public class Contact4TypeProcessor : TwoBodyContactTypeProcessor<Contact4PrestepData, Contact4AccumulatedImpulses, Contact4Functions> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses> TwoBodyTypeProcessor<Contact4PrestepData, Contact4AccumulatedImpulses, Contact4Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose> TwoBodyContactTypeProcessor<Contact4PrestepData, Contact4AccumulatedImpulses, Contact4Functions> Contact4TypeProcessor Inherited Members TwoBodyTypeProcessor<Contact4PrestepData, Contact4AccumulatedImpulses, Contact4Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<Contact4PrestepData, Contact4AccumulatedImpulses, Contact4Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<Contact4PrestepData, Contact4AccumulatedImpulses, Contact4Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<Contact4PrestepData, Contact4AccumulatedImpulses, Contact4Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<Contact4PrestepData, Contact4AccumulatedImpulses, Contact4Functions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.Move(ref TwoBodyReferences, ref Contact4PrestepData, ref Contact4AccumulatedImpulses, ConstraintHandle, int, ref TwoBodyReferences, ref Contact4PrestepData, ref Contact4AccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, Contact4PrestepData, Contact4AccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 7 Field Value int"
  },
  "api/BepuPhysics.Constraints.Contact.ContactNonconvexOneBodyFunctions-2.html": {
    "href": "api/BepuPhysics.Constraints.Contact.ContactNonconvexOneBodyFunctions-2.html",
    "title": "Struct ContactNonconvexOneBodyFunctions<TPrestep, TAccumulatedImpulses> | Bepu API",
    "keywords": "Struct ContactNonconvexOneBodyFunctions<TPrestep, TAccumulatedImpulses> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct ContactNonconvexOneBodyFunctions<TPrestep, TAccumulatedImpulses> : IOneBodyConstraintFunctions<TPrestep, TAccumulatedImpulses> where TPrestep : struct, INonconvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct Type Parameters TPrestep TAccumulatedImpulses Implements IOneBodyConstraintFunctions<TPrestep, TAccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateContactData(in Vector<float>, in BodyVelocityWide, ref TPrestep) public void IncrementallyUpdateContactData(in Vector<float> dt, in BodyVelocityWide velocity, ref TPrestep prestep) Parameters dt Vector<float> velocity BodyVelocityWide prestep TPrestep IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref TPrestep) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, ref TPrestep prestep) Parameters dt Vector<float> wsvA BodyVelocityWide prestep TPrestep Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref TPrestep, ref TAccumulatedImpulses, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref TPrestep prestep, ref TAccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep TPrestep accumulatedImpulses TAccumulatedImpulses wsvA BodyVelocityWide UpdateForNewPose(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in BodyVelocityWide, in Vector<float>, in TAccumulatedImpulses, ref TPrestep) public void UpdateForNewPose(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in BodyVelocityWide wsvA, in Vector<float> dt, in TAccumulatedImpulses accumulatedImpulses, ref TPrestep prestep) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide wsvA BodyVelocityWide dt Vector<float> accumulatedImpulses TAccumulatedImpulses prestep TPrestep WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref TPrestep, ref TAccumulatedImpulses, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref TPrestep prestep, ref TAccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep TPrestep accumulatedImpulses TAccumulatedImpulses wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.ContactNonconvexTwoBodyFunctions-2.html": {
    "href": "api/BepuPhysics.Constraints.Contact.ContactNonconvexTwoBodyFunctions-2.html",
    "title": "Struct ContactNonconvexTwoBodyFunctions<TPrestep, TAccumulatedImpulses> | Bepu API",
    "keywords": "Struct ContactNonconvexTwoBodyFunctions<TPrestep, TAccumulatedImpulses> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct ContactNonconvexTwoBodyFunctions<TPrestep, TAccumulatedImpulses> : ITwoBodyConstraintFunctions<TPrestep, TAccumulatedImpulses> where TPrestep : struct, ITwoBodyNonconvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct Type Parameters TPrestep TAccumulatedImpulses Implements ITwoBodyConstraintFunctions<TPrestep, TAccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref TPrestep) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref TPrestep prestep) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestep TPrestep Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref TPrestep, ref TAccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref TPrestep prestep, ref TAccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep TPrestep accumulatedImpulses TAccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref TPrestep, ref TAccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref TPrestep prestep, ref TAccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep TPrestep accumulatedImpulses TAccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.ConvexContactWide.html": {
    "href": "api/BepuPhysics.Constraints.Contact.ConvexContactWide.html",
    "title": "Struct ConvexContactWide | Bepu API",
    "keywords": "Struct ConvexContactWide Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct ConvexContactWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Depth public Vector<float> Depth Field Value Vector<float> OffsetA public Vector3Wide OffsetA Field Value Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.IContactAccumulatedImpulses-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.IContactAccumulatedImpulses-1.html",
    "title": "Interface IContactAccumulatedImpulses<TAccumulatedImpulses> | Bepu API",
    "keywords": "Interface IContactAccumulatedImpulses<TAccumulatedImpulses> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface IContactAccumulatedImpulses<TAccumulatedImpulses> where TAccumulatedImpulses : struct, IContactAccumulatedImpulses<TAccumulatedImpulses> Type Parameters TAccumulatedImpulses Properties ContactCount public static abstract int ContactCount { get; } Property Value int"
  },
  "api/BepuPhysics.Constraints.Contact.IContactPrestep-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.IContactPrestep-1.html",
    "title": "Interface IContactPrestep<TPrestep> | Bepu API",
    "keywords": "Interface IContactPrestep<TPrestep> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface IContactPrestep<TPrestep> where TPrestep : struct, IContactPrestep<TPrestep> Type Parameters TPrestep Properties BodyCount public static abstract int BodyCount { get; } Property Value int ContactCount public static abstract int ContactCount { get; } Property Value int Methods GetMaterialProperties(ref TPrestep) public static abstract ref MaterialPropertiesWide GetMaterialProperties(ref TPrestep prestep) Parameters prestep TPrestep Returns MaterialPropertiesWide"
  },
  "api/BepuPhysics.Constraints.Contact.IConvexContactAccumulatedImpulses-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.IConvexContactAccumulatedImpulses-1.html",
    "title": "Interface IConvexContactAccumulatedImpulses<TAccumulatedImpulses> | Bepu API",
    "keywords": "Interface IConvexContactAccumulatedImpulses<TAccumulatedImpulses> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface IConvexContactAccumulatedImpulses<TAccumulatedImpulses> : IContactAccumulatedImpulses<TAccumulatedImpulses> where TAccumulatedImpulses : struct, IConvexContactAccumulatedImpulses<TAccumulatedImpulses> Type Parameters TAccumulatedImpulses Inherited Members IContactAccumulatedImpulses<TAccumulatedImpulses>.ContactCount Methods GetPenetrationImpulseForContact(ref TAccumulatedImpulses, int) public static abstract ref Vector<float> GetPenetrationImpulseForContact(ref TAccumulatedImpulses impulses, int index) Parameters impulses TAccumulatedImpulses index int Returns Vector<float> GetTangentFriction(ref TAccumulatedImpulses) public static abstract ref Vector2Wide GetTangentFriction(ref TAccumulatedImpulses impulses) Parameters impulses TAccumulatedImpulses Returns Vector2Wide GetTwistFriction(ref TAccumulatedImpulses) public static abstract ref Vector<float> GetTwistFriction(ref TAccumulatedImpulses impulses) Parameters impulses TAccumulatedImpulses Returns Vector<float>"
  },
  "api/BepuPhysics.Constraints.Contact.IConvexContactPrestep-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.IConvexContactPrestep-1.html",
    "title": "Interface IConvexContactPrestep<TPrestep> | Bepu API",
    "keywords": "Interface IConvexContactPrestep<TPrestep> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface IConvexContactPrestep<TPrestep> : IContactPrestep<TPrestep> where TPrestep : struct, IConvexContactPrestep<TPrestep> Type Parameters TPrestep Inherited Members IContactPrestep<TPrestep>.GetMaterialProperties(ref TPrestep) IContactPrestep<TPrestep>.ContactCount IContactPrestep<TPrestep>.BodyCount Methods GetContact(ref TPrestep, int) public static abstract ref ConvexContactWide GetContact(ref TPrestep prestep, int index) Parameters prestep TPrestep index int Returns ConvexContactWide GetNormal(ref TPrestep) public static abstract ref Vector3Wide GetNormal(ref TPrestep prestep) Parameters prestep TPrestep Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.IConvexOneBodyContactConstraintDescription-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.IConvexOneBodyContactConstraintDescription-1.html",
    "title": "Interface IConvexOneBodyContactConstraintDescription<TDescription> | Bepu API",
    "keywords": "Interface IConvexOneBodyContactConstraintDescription<TDescription> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface IConvexOneBodyContactConstraintDescription<TDescription> : IOneBodyConstraintDescription<TDescription>, IConstraintDescription<TDescription> where TDescription : unmanaged, IConvexOneBodyContactConstraintDescription<TDescription> Type Parameters TDescription Inherited Members IConstraintDescription<TDescription>.ApplyDescription(ref TypeBatch, int, int) IConstraintDescription<TDescription>.BuildDescription(ref TypeBatch, int, int, out TDescription) IConstraintDescription<TDescription>.ConstraintTypeId IConstraintDescription<TDescription>.TypeProcessorType IConstraintDescription<TDescription>.CreateTypeProcessor() Methods CopyManifoldWideProperties(ref Vector3, ref PairMaterialProperties) void CopyManifoldWideProperties(ref Vector3 normal, ref PairMaterialProperties material) Parameters normal Vector3 material PairMaterialProperties GetFirstContact(ref TDescription) public static abstract ref ConstraintContactData GetFirstContact(ref TDescription description) Parameters description TDescription Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.IConvexTwoBodyContactConstraintDescription-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.IConvexTwoBodyContactConstraintDescription-1.html",
    "title": "Interface IConvexTwoBodyContactConstraintDescription<TDescription> | Bepu API",
    "keywords": "Interface IConvexTwoBodyContactConstraintDescription<TDescription> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface IConvexTwoBodyContactConstraintDescription<TDescription> : ITwoBodyConstraintDescription<TDescription>, IConstraintDescription<TDescription> where TDescription : unmanaged, IConvexTwoBodyContactConstraintDescription<TDescription> Type Parameters TDescription Inherited Members IConstraintDescription<TDescription>.ApplyDescription(ref TypeBatch, int, int) IConstraintDescription<TDescription>.BuildDescription(ref TypeBatch, int, int, out TDescription) IConstraintDescription<TDescription>.ConstraintTypeId IConstraintDescription<TDescription>.TypeProcessorType IConstraintDescription<TDescription>.CreateTypeProcessor() Methods CopyManifoldWideProperties(ref Vector3, ref Vector3, ref PairMaterialProperties) void CopyManifoldWideProperties(ref Vector3 offsetB, ref Vector3 normal, ref PairMaterialProperties material) Parameters offsetB Vector3 normal Vector3 material PairMaterialProperties GetFirstContact(ref TDescription) public static abstract ref ConstraintContactData GetFirstContact(ref TDescription description) Parameters description TDescription Returns ConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.INonconvexContactAccumulatedImpulses-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.INonconvexContactAccumulatedImpulses-1.html",
    "title": "Interface INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> | Bepu API",
    "keywords": "Interface INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> : IContactAccumulatedImpulses<TAccumulatedImpulses> where TAccumulatedImpulses : struct, INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> Type Parameters TAccumulatedImpulses Inherited Members IContactAccumulatedImpulses<TAccumulatedImpulses>.ContactCount Methods GetImpulsesForContact(ref TAccumulatedImpulses, int) public static abstract ref NonconvexAccumulatedImpulses GetImpulsesForContact(ref TAccumulatedImpulses impulses, int index) Parameters impulses TAccumulatedImpulses index int Returns NonconvexAccumulatedImpulses"
  },
  "api/BepuPhysics.Constraints.Contact.INonconvexContactPrestep-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.INonconvexContactPrestep-1.html",
    "title": "Interface INonconvexContactPrestep<TPrestep> | Bepu API",
    "keywords": "Interface INonconvexContactPrestep<TPrestep> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface INonconvexContactPrestep<TPrestep> : IContactPrestep<TPrestep> where TPrestep : struct, INonconvexContactPrestep<TPrestep> Type Parameters TPrestep Inherited Members IContactPrestep<TPrestep>.GetMaterialProperties(ref TPrestep) IContactPrestep<TPrestep>.ContactCount IContactPrestep<TPrestep>.BodyCount Methods GetContact(ref TPrestep, int) public static abstract ref NonconvexContactPrestepData GetContact(ref TPrestep prestep, int index) Parameters prestep TPrestep index int Returns NonconvexContactPrestepData"
  },
  "api/BepuPhysics.Constraints.Contact.INonconvexOneBodyContactConstraintDescription-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.INonconvexOneBodyContactConstraintDescription-1.html",
    "title": "Interface INonconvexOneBodyContactConstraintDescription<TDescription> | Bepu API",
    "keywords": "Interface INonconvexOneBodyContactConstraintDescription<TDescription> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface INonconvexOneBodyContactConstraintDescription<TDescription> : IOneBodyConstraintDescription<TDescription>, IConstraintDescription<TDescription> where TDescription : unmanaged, INonconvexOneBodyContactConstraintDescription<TDescription> Type Parameters TDescription Inherited Members IConstraintDescription<TDescription>.ApplyDescription(ref TypeBatch, int, int) IConstraintDescription<TDescription>.BuildDescription(ref TypeBatch, int, int, out TDescription) IConstraintDescription<TDescription>.ConstraintTypeId IConstraintDescription<TDescription>.TypeProcessorType IConstraintDescription<TDescription>.CreateTypeProcessor() Properties ContactCount public static abstract int ContactCount { get; } Property Value int Methods CopyManifoldWideProperties(ref PairMaterialProperties) void CopyManifoldWideProperties(ref PairMaterialProperties material) Parameters material PairMaterialProperties GetCommonProperties(ref TDescription) public static abstract ref NonconvexOneBodyManifoldConstraintProperties GetCommonProperties(ref TDescription description) Parameters description TDescription Returns NonconvexOneBodyManifoldConstraintProperties GetFirstContact(ref TDescription) public static abstract ref NonconvexConstraintContactData GetFirstContact(ref TDescription description) Parameters description TDescription Returns NonconvexConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.INonconvexTwoBodyContactConstraintDescription-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.INonconvexTwoBodyContactConstraintDescription-1.html",
    "title": "Interface INonconvexTwoBodyContactConstraintDescription<TDescription> | Bepu API",
    "keywords": "Interface INonconvexTwoBodyContactConstraintDescription<TDescription> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface INonconvexTwoBodyContactConstraintDescription<TDescription> : ITwoBodyConstraintDescription<TDescription>, IConstraintDescription<TDescription> where TDescription : unmanaged, INonconvexTwoBodyContactConstraintDescription<TDescription> Type Parameters TDescription Inherited Members IConstraintDescription<TDescription>.ApplyDescription(ref TypeBatch, int, int) IConstraintDescription<TDescription>.BuildDescription(ref TypeBatch, int, int, out TDescription) IConstraintDescription<TDescription>.ConstraintTypeId IConstraintDescription<TDescription>.TypeProcessorType IConstraintDescription<TDescription>.CreateTypeProcessor() Properties ContactCount public static abstract int ContactCount { get; } Property Value int Methods CopyManifoldWideProperties(ref Vector3, ref PairMaterialProperties) void CopyManifoldWideProperties(ref Vector3 offsetB, ref PairMaterialProperties material) Parameters offsetB Vector3 material PairMaterialProperties GetCommonProperties(ref TDescription) public static abstract ref NonconvexTwoBodyManifoldConstraintProperties GetCommonProperties(ref TDescription description) Parameters description TDescription Returns NonconvexTwoBodyManifoldConstraintProperties GetFirstContact(ref TDescription) public static abstract ref NonconvexConstraintContactData GetFirstContact(ref TDescription description) Parameters description TDescription Returns NonconvexConstraintContactData"
  },
  "api/BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.ISolverContactDataExtractor.html",
    "title": "Interface ISolverContactDataExtractor | Bepu API",
    "keywords": "Interface ISolverContactDataExtractor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Callbacks for direct references to the solver's contact constraint data. public interface ISolverContactDataExtractor Methods ConvexOneBody<TPrestep, TAccumulatedImpulses>(BodyHandle, ref TPrestep, ref TAccumulatedImpulses) Provides a reference to a convex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors). void ConvexOneBody<TPrestep, TAccumulatedImpulses>(BodyHandle bodyHandle, ref TPrestep prestep, ref TAccumulatedImpulses impulses) where TPrestep : struct, IConvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct, IConvexContactAccumulatedImpulses<TAccumulatedImpulses> Parameters bodyHandle BodyHandle Body handle referenced by the constraint. prestep TPrestep Prestep data associated with the constraint. impulses TAccumulatedImpulses Accumulated impulses associated with the constraint. Type Parameters TPrestep Type of the prestep data returned. TAccumulatedImpulses Type of the accumulated impulses data returned. ConvexTwoBody<TPrestep, TAccumulatedImpulses>(BodyHandle, BodyHandle, ref TPrestep, ref TAccumulatedImpulses) Provides a reference to a convex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors). void ConvexTwoBody<TPrestep, TAccumulatedImpulses>(BodyHandle bodyHandleA, BodyHandle bodyHandleB, ref TPrestep prestep, ref TAccumulatedImpulses impulses) where TPrestep : struct, ITwoBodyConvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct, IConvexContactAccumulatedImpulses<TAccumulatedImpulses> Parameters bodyHandleA BodyHandle First body handle referenced by the constraint. bodyHandleB BodyHandle Second body handle referenced by the constraint. prestep TPrestep Prestep data associated with the constraint. impulses TAccumulatedImpulses Accumulated impulses associated with the constraint. Type Parameters TPrestep Type of the prestep data returned. TAccumulatedImpulses Type of the accumulated impulses data returned. NonconvexOneBody<TPrestep, TAccumulatedImpulses>(BodyHandle, ref TPrestep, ref TAccumulatedImpulses) Provides a reference to a nonconvex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors). void NonconvexOneBody<TPrestep, TAccumulatedImpulses>(BodyHandle bodyHandle, ref TPrestep prestep, ref TAccumulatedImpulses impulses) where TPrestep : struct, INonconvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct, INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> Parameters bodyHandle BodyHandle Body handle referenced by the constraint. prestep TPrestep Prestep data associated with the constraint. impulses TAccumulatedImpulses Accumulated impulses associated with the constraint. Type Parameters TPrestep Type of the prestep data returned. TAccumulatedImpulses Type of the accumulated impulses data returned. NonconvexTwoBody<TPrestep, TAccumulatedImpulses>(BodyHandle, BodyHandle, ref TPrestep, ref TAccumulatedImpulses) Provides a reference to a nonconvex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors). void NonconvexTwoBody<TPrestep, TAccumulatedImpulses>(BodyHandle bodyHandleA, BodyHandle bodyHandleB, ref TPrestep prestep, ref TAccumulatedImpulses impulses) where TPrestep : struct, ITwoBodyNonconvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct, INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> Parameters bodyHandleA BodyHandle First body handle referenced by the constraint. bodyHandleB BodyHandle Second body handle referenced by the constraint. prestep TPrestep Prestep data associated with the constraint. impulses TAccumulatedImpulses Accumulated impulses associated with the constraint. Type Parameters TPrestep Type of the prestep data returned. TAccumulatedImpulses Type of the accumulated impulses data returned."
  },
  "api/BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.html": {
    "href": "api/BepuPhysics.Constraints.Contact.ISolverContactPrestepAndImpulsesExtractor.html",
    "title": "Interface ISolverContactPrestepAndImpulsesExtractor | Bepu API",
    "keywords": "Interface ISolverContactPrestepAndImpulsesExtractor Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Callbacks for direct references to the solver's contact constraint data. Includes only prestep and impulse data. public interface ISolverContactPrestepAndImpulsesExtractor Methods ConvexOneBody<TPrestep, TAccumulatedImpulses>(ref TPrestep, ref TAccumulatedImpulses) Provides a reference to a convex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors). void ConvexOneBody<TPrestep, TAccumulatedImpulses>(ref TPrestep prestep, ref TAccumulatedImpulses impulses) where TPrestep : struct, IConvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct, IConvexContactAccumulatedImpulses<TAccumulatedImpulses> Parameters prestep TPrestep Prestep data associated with the constraint. impulses TAccumulatedImpulses Accumulated impulses associated with the constraint. Type Parameters TPrestep Type of the prestep data returned. TAccumulatedImpulses Type of the accumulated impulses data returned. ConvexTwoBody<TPrestep, TAccumulatedImpulses>(ref TPrestep, ref TAccumulatedImpulses) Provides a reference to a convex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors). void ConvexTwoBody<TPrestep, TAccumulatedImpulses>(ref TPrestep prestep, ref TAccumulatedImpulses impulses) where TPrestep : struct, ITwoBodyConvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct, IConvexContactAccumulatedImpulses<TAccumulatedImpulses> Parameters prestep TPrestep Prestep data associated with the constraint. impulses TAccumulatedImpulses Accumulated impulses associated with the constraint. Type Parameters TPrestep Type of the prestep data returned. TAccumulatedImpulses Type of the accumulated impulses data returned. NonconvexOneBody<TPrestep, TAccumulatedImpulses>(ref TPrestep, ref TAccumulatedImpulses) Provides a reference to a nonconvex one body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors). void NonconvexOneBody<TPrestep, TAccumulatedImpulses>(ref TPrestep prestep, ref TAccumulatedImpulses impulses) where TPrestep : struct, INonconvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct, INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> Parameters prestep TPrestep Prestep data associated with the constraint. impulses TAccumulatedImpulses Accumulated impulses associated with the constraint. Type Parameters TPrestep Type of the prestep data returned. TAccumulatedImpulses Type of the accumulated impulses data returned. NonconvexTwoBody<TPrestep, TAccumulatedImpulses>(ref TPrestep, ref TAccumulatedImpulses) Provides a reference to a nonconvex two body contact constraint. Constraint data is in the first lane of the direct reference (slot 0 of vectors). void NonconvexTwoBody<TPrestep, TAccumulatedImpulses>(ref TPrestep prestep, ref TAccumulatedImpulses impulses) where TPrestep : struct, ITwoBodyNonconvexContactPrestep<TPrestep> where TAccumulatedImpulses : struct, INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> Parameters prestep TPrestep Prestep data associated with the constraint. impulses TAccumulatedImpulses Accumulated impulses associated with the constraint. Type Parameters TPrestep Type of the prestep data returned. TAccumulatedImpulses Type of the accumulated impulses data returned."
  },
  "api/BepuPhysics.Constraints.Contact.ITwoBodyConvexContactPrestep-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.ITwoBodyConvexContactPrestep-1.html",
    "title": "Interface ITwoBodyConvexContactPrestep<TPrestep> | Bepu API",
    "keywords": "Interface ITwoBodyConvexContactPrestep<TPrestep> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface ITwoBodyConvexContactPrestep<TPrestep> : IConvexContactPrestep<TPrestep>, IContactPrestep<TPrestep> where TPrestep : struct, ITwoBodyConvexContactPrestep<TPrestep> Type Parameters TPrestep Inherited Members IConvexContactPrestep<TPrestep>.GetNormal(ref TPrestep) IConvexContactPrestep<TPrestep>.GetContact(ref TPrestep, int) IContactPrestep<TPrestep>.GetMaterialProperties(ref TPrestep) IContactPrestep<TPrestep>.ContactCount IContactPrestep<TPrestep>.BodyCount Methods GetOffsetB(ref TPrestep) public static abstract ref Vector3Wide GetOffsetB(ref TPrestep prestep) Parameters prestep TPrestep Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.ITwoBodyNonconvexContactPrestep-1.html": {
    "href": "api/BepuPhysics.Constraints.Contact.ITwoBodyNonconvexContactPrestep-1.html",
    "title": "Interface ITwoBodyNonconvexContactPrestep<TPrestep> | Bepu API",
    "keywords": "Interface ITwoBodyNonconvexContactPrestep<TPrestep> Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public interface ITwoBodyNonconvexContactPrestep<TPrestep> : INonconvexContactPrestep<TPrestep>, IContactPrestep<TPrestep> where TPrestep : struct, ITwoBodyNonconvexContactPrestep<TPrestep> Type Parameters TPrestep Inherited Members INonconvexContactPrestep<TPrestep>.GetContact(ref TPrestep, int) IContactPrestep<TPrestep>.GetMaterialProperties(ref TPrestep) IContactPrestep<TPrestep>.ContactCount IContactPrestep<TPrestep>.BodyCount Methods GetOffsetB(ref TPrestep) public static abstract ref Vector3Wide GetOffsetB(ref TPrestep prestep) Parameters prestep TPrestep Returns Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.MaterialPropertiesWide.html": {
    "href": "api/BepuPhysics.Constraints.Contact.MaterialPropertiesWide.html",
    "title": "Struct MaterialPropertiesWide | Bepu API",
    "keywords": "Struct MaterialPropertiesWide Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct MaterialPropertiesWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields FrictionCoefficient public Vector<float> FrictionCoefficient Field Value Vector<float> MaximumRecoveryVelocity public Vector<float> MaximumRecoveryVelocity Field Value Vector<float> SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.Contact.NonconvexAccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.Contact.NonconvexAccumulatedImpulses.html",
    "title": "Struct NonconvexAccumulatedImpulses | Bepu API",
    "keywords": "Struct NonconvexAccumulatedImpulses Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct NonconvexAccumulatedImpulses Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Penetration public Vector<float> Penetration Field Value Vector<float> Tangent public Vector2Wide Tangent Field Value Vector2Wide"
  },
  "api/BepuPhysics.Constraints.Contact.NonconvexConstraintContactData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.NonconvexConstraintContactData.html",
    "title": "Struct NonconvexConstraintContactData | Bepu API",
    "keywords": "Struct NonconvexConstraintContactData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct NonconvexConstraintContactData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Normal public Vector3 Normal Field Value Vector3 OffsetA public Vector3 OffsetA Field Value Vector3 PenetrationDepth public float PenetrationDepth Field Value float"
  },
  "api/BepuPhysics.Constraints.Contact.NonconvexContactPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.Contact.NonconvexContactPrestepData.html",
    "title": "Struct NonconvexContactPrestepData | Bepu API",
    "keywords": "Struct NonconvexContactPrestepData Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct NonconvexContactPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Depth public Vector<float> Depth Field Value Vector<float> Normal public Vector3Wide Normal Field Value Vector3Wide Offset public Vector3Wide Offset Field Value Vector3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.NonconvexOneBodyManifoldConstraintProperties.html": {
    "href": "api/BepuPhysics.Constraints.Contact.NonconvexOneBodyManifoldConstraintProperties.html",
    "title": "Struct NonconvexOneBodyManifoldConstraintProperties | Bepu API",
    "keywords": "Struct NonconvexOneBodyManifoldConstraintProperties Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct NonconvexOneBodyManifoldConstraintProperties Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float SpringSettings public SpringSettings SpringSettings Field Value SpringSettings"
  },
  "api/BepuPhysics.Constraints.Contact.NonconvexTwoBodyManifoldConstraintProperties.html": {
    "href": "api/BepuPhysics.Constraints.Contact.NonconvexTwoBodyManifoldConstraintProperties.html",
    "title": "Struct NonconvexTwoBodyManifoldConstraintProperties | Bepu API",
    "keywords": "Struct NonconvexTwoBodyManifoldConstraintProperties Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct NonconvexTwoBodyManifoldConstraintProperties Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields FrictionCoefficient public float FrictionCoefficient Field Value float MaximumRecoveryVelocity public float MaximumRecoveryVelocity Field Value float OffsetB public Vector3 OffsetB Field Value Vector3 SpringSettings public SpringSettings SpringSettings Field Value SpringSettings"
  },
  "api/BepuPhysics.Constraints.Contact.PenetrationLimit.html": {
    "href": "api/BepuPhysics.Constraints.Contact.PenetrationLimit.html",
    "title": "Class PenetrationLimit | Bepu API",
    "keywords": "Class PenetrationLimit Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public static class PenetrationLimit Inheritance object PenetrationLimit Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ApplyImpulse(in BodyInertiaWide, in BodyInertiaWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void ApplyImpulse(in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector3Wide normal, in Vector3Wide angularA, in Vector3Wide angularB, in Vector<float> correctiveImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters inertiaA BodyInertiaWide inertiaB BodyInertiaWide normal Vector3Wide angularA Vector3Wide angularB Vector3Wide correctiveImpulse Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide ComputeCorrectiveImpulse(in BodyVelocityWide, in BodyVelocityWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector<float>, in Vector<float>, in Vector<float>, ref Vector<float>, out Vector<float>) public static void ComputeCorrectiveImpulse(in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, in Vector3Wide normal, in Vector3Wide angularA, in Vector3Wide angularB, in Vector<float> biasVelocity, in Vector<float> softnessImpulseScale, in Vector<float> effectiveMass, ref Vector<float> accumulatedImpulse, out Vector<float> correctiveCSI) Parameters wsvA BodyVelocityWide wsvB BodyVelocityWide normal Vector3Wide angularA Vector3Wide angularB Vector3Wide biasVelocity Vector<float> softnessImpulseScale Vector<float> effectiveMass Vector<float> accumulatedImpulse Vector<float> correctiveCSI Vector<float> Solve(in BodyInertiaWide, in BodyInertiaWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector<float>, in Vector<float>, in Vector<float>, in Vector<float>, in Vector<float>, in Vector<float>, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector3Wide normal, in Vector3Wide contactOffsetA, in Vector3Wide contactOffsetB, in Vector<float> depth, in Vector<float> positionErrorToVelocity, in Vector<float> effectiveMassCFMScale, in Vector<float> maximumRecoveryVelocity, in Vector<float> inverseDt, in Vector<float> softnessImpulseScale, ref Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters inertiaA BodyInertiaWide inertiaB BodyInertiaWide normal Vector3Wide contactOffsetA Vector3Wide contactOffsetB Vector3Wide depth Vector<float> positionErrorToVelocity Vector<float> effectiveMassCFMScale Vector<float> maximumRecoveryVelocity Vector<float> inverseDt Vector<float> softnessImpulseScale Vector<float> accumulatedImpulse Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide UpdatePenetrationDepth(in Vector<float>, in Vector3Wide, in Vector3Wide, in Vector3Wide, in BodyVelocityWide, in BodyVelocityWide, ref Vector<float>) public static void UpdatePenetrationDepth(in Vector<float> dt, in Vector3Wide contactOffsetA, in Vector3Wide offsetB, in Vector3Wide normal, in BodyVelocityWide velocityA, in BodyVelocityWide velocityB, ref Vector<float> penetrationDepth) Parameters dt Vector<float> contactOffsetA Vector3Wide offsetB Vector3Wide normal Vector3Wide velocityA BodyVelocityWide velocityB BodyVelocityWide penetrationDepth Vector<float> WarmStart(in BodyInertiaWide, in BodyInertiaWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector3Wide normal, in Vector3Wide contactOffsetA, in Vector3Wide contactOffsetB, in Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters inertiaA BodyInertiaWide inertiaB BodyInertiaWide normal Vector3Wide contactOffsetA Vector3Wide contactOffsetB Vector3Wide accumulatedImpulse Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.PenetrationLimitOneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.PenetrationLimitOneBody.html",
    "title": "Class PenetrationLimitOneBody | Bepu API",
    "keywords": "Class PenetrationLimitOneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public static class PenetrationLimitOneBody Inheritance object PenetrationLimitOneBody Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ApplyImpulse(in BodyInertiaWide, in Vector3Wide, in Vector3Wide, in Vector<float>, ref BodyVelocityWide) public static void ApplyImpulse(in BodyInertiaWide inertiaA, in Vector3Wide normal, in Vector3Wide angularA, in Vector<float> correctiveImpulse, ref BodyVelocityWide wsvA) Parameters inertiaA BodyInertiaWide normal Vector3Wide angularA Vector3Wide correctiveImpulse Vector<float> wsvA BodyVelocityWide ComputeCorrectiveImpulse(in BodyVelocityWide, in Vector3Wide, in Vector3Wide, in Vector<float>, in Vector<float>, in Vector<float>, ref Vector<float>, out Vector<float>) public static void ComputeCorrectiveImpulse(in BodyVelocityWide wsvA, in Vector3Wide normal, in Vector3Wide angularA, in Vector<float> biasVelocity, in Vector<float> softnessImpulseScale, in Vector<float> effectiveMass, ref Vector<float> accumulatedImpulse, out Vector<float> correctiveCSI) Parameters wsvA BodyVelocityWide normal Vector3Wide angularA Vector3Wide biasVelocity Vector<float> softnessImpulseScale Vector<float> effectiveMass Vector<float> accumulatedImpulse Vector<float> correctiveCSI Vector<float> Solve(in BodyInertiaWide, in Vector3Wide, in Vector3Wide, in Vector<float>, in Vector<float>, in Vector<float>, in Vector<float>, in Vector<float>, in Vector<float>, ref Vector<float>, ref BodyVelocityWide) public static void Solve(in BodyInertiaWide inertiaA, in Vector3Wide normal, in Vector3Wide contactOffsetA, in Vector<float> depth, in Vector<float> positionErrorToVelocity, in Vector<float> effectiveMassCFMScale, in Vector<float> maximumRecoveryVelocity, in Vector<float> inverseDt, in Vector<float> softnessImpulseScale, ref Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA) Parameters inertiaA BodyInertiaWide normal Vector3Wide contactOffsetA Vector3Wide depth Vector<float> positionErrorToVelocity Vector<float> effectiveMassCFMScale Vector<float> maximumRecoveryVelocity Vector<float> inverseDt Vector<float> softnessImpulseScale Vector<float> accumulatedImpulse Vector<float> wsvA BodyVelocityWide UpdatePenetrationDepth(in Vector<float>, in Vector3Wide, in Vector3Wide, in BodyVelocityWide, ref Vector<float>) public static void UpdatePenetrationDepth(in Vector<float> dt, in Vector3Wide contactOffset, in Vector3Wide normal, in BodyVelocityWide velocity, ref Vector<float> penetrationDepth) Parameters dt Vector<float> contactOffset Vector3Wide normal Vector3Wide velocity BodyVelocityWide penetrationDepth Vector<float> WarmStart(in BodyInertiaWide, in Vector3Wide, in Vector3Wide, in Vector<float>, ref BodyVelocityWide) public static void WarmStart(in BodyInertiaWide inertiaA, in Vector3Wide normal, in Vector3Wide contactOffsetA, in Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA) Parameters inertiaA BodyInertiaWide normal Vector3Wide contactOffsetA Vector3Wide accumulatedImpulse Vector<float> wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.TangentFriction.Jacobians.html": {
    "href": "api/BepuPhysics.Constraints.Contact.TangentFriction.Jacobians.html",
    "title": "Struct TangentFriction.Jacobians | Bepu API",
    "keywords": "Struct TangentFriction.Jacobians Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct TangentFriction.Jacobians Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AngularA public Matrix2x3Wide AngularA Field Value Matrix2x3Wide AngularB public Matrix2x3Wide AngularB Field Value Matrix2x3Wide LinearA public Matrix2x3Wide LinearA Field Value Matrix2x3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.TangentFriction.html": {
    "href": "api/BepuPhysics.Constraints.Contact.TangentFriction.html",
    "title": "Class TangentFriction | Bepu API",
    "keywords": "Class TangentFriction Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the tangent friction implementation. public static class TangentFriction Inheritance object TangentFriction Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ApplyImpulse(in Jacobians, in BodyInertiaWide, in BodyInertiaWide, in Vector2Wide, ref BodyVelocityWide, ref BodyVelocityWide) Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies. public static void ApplyImpulse(in TangentFriction.Jacobians jacobians, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector2Wide correctiveImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters jacobians TangentFriction.Jacobians inertiaA BodyInertiaWide inertiaB BodyInertiaWide correctiveImpulse Vector2Wide wsvA BodyVelocityWide wsvB BodyVelocityWide ComputeCorrectiveImpulse(in BodyVelocityWide, in BodyVelocityWide, in Symmetric2x2Wide, in Jacobians, in Vector<float>, ref Vector2Wide, out Vector2Wide) public static void ComputeCorrectiveImpulse(in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, in Symmetric2x2Wide effectiveMass, in TangentFriction.Jacobians jacobians, in Vector<float> maximumImpulse, ref Vector2Wide accumulatedImpulse, out Vector2Wide correctiveCSI) Parameters wsvA BodyVelocityWide wsvB BodyVelocityWide effectiveMass Symmetric2x2Wide jacobians TangentFriction.Jacobians maximumImpulse Vector<float> accumulatedImpulse Vector2Wide correctiveCSI Vector2Wide ComputeJacobians(in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector3Wide, out Jacobians) public static void ComputeJacobians(in Vector3Wide tangentX, in Vector3Wide tangentY, in Vector3Wide offsetA, in Vector3Wide offsetB, out TangentFriction.Jacobians jacobians) Parameters tangentX Vector3Wide tangentY Vector3Wide offsetA Vector3Wide offsetB Vector3Wide jacobians TangentFriction.Jacobians Solve(in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in BodyInertiaWide, in BodyInertiaWide, in Vector<float>, ref Vector2Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide tangentX, in Vector3Wide tangentY, in Vector3Wide offsetToManifoldCenterA, in Vector3Wide offsetToManifoldCenterB, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector<float> maximumImpulse, ref Vector2Wide accumulatedImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters tangentX Vector3Wide tangentY Vector3Wide offsetToManifoldCenterA Vector3Wide offsetToManifoldCenterB Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide maximumImpulse Vector<float> accumulatedImpulse Vector2Wide wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in BodyInertiaWide, in BodyInertiaWide, in Vector2Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide tangentX, in Vector3Wide tangentY, in Vector3Wide offsetToManifoldCenterA, in Vector3Wide offsetToManifoldCenterB, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector2Wide accumulatedImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters tangentX Vector3Wide tangentY Vector3Wide offsetToManifoldCenterA Vector3Wide offsetToManifoldCenterB Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide accumulatedImpulse Vector2Wide wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.TangentFrictionOneBody.Jacobians.html": {
    "href": "api/BepuPhysics.Constraints.Contact.TangentFrictionOneBody.Jacobians.html",
    "title": "Struct TangentFrictionOneBody.Jacobians | Bepu API",
    "keywords": "Struct TangentFrictionOneBody.Jacobians Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll public struct TangentFrictionOneBody.Jacobians Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AngularA public Matrix2x3Wide AngularA Field Value Matrix2x3Wide LinearA public Matrix2x3Wide LinearA Field Value Matrix2x3Wide"
  },
  "api/BepuPhysics.Constraints.Contact.TangentFrictionOneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.TangentFrictionOneBody.html",
    "title": "Class TangentFrictionOneBody | Bepu API",
    "keywords": "Class TangentFrictionOneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the tangent friction implementation for one body contact constraints. public static class TangentFrictionOneBody Inheritance object TangentFrictionOneBody Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ApplyImpulse(in Jacobians, in BodyInertiaWide, in Vector2Wide, ref BodyVelocityWide) Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies. public static void ApplyImpulse(in TangentFrictionOneBody.Jacobians jacobians, in BodyInertiaWide inertiaA, in Vector2Wide correctiveImpulse, ref BodyVelocityWide wsvA) Parameters jacobians TangentFrictionOneBody.Jacobians inertiaA BodyInertiaWide correctiveImpulse Vector2Wide wsvA BodyVelocityWide ComputeCorrectiveImpulse(in BodyVelocityWide, in Symmetric2x2Wide, in Jacobians, in Vector<float>, ref Vector2Wide, out Vector2Wide) public static void ComputeCorrectiveImpulse(in BodyVelocityWide wsvA, in Symmetric2x2Wide effectiveMass, in TangentFrictionOneBody.Jacobians jacobians, in Vector<float> maximumImpulse, ref Vector2Wide accumulatedImpulse, out Vector2Wide correctiveCSI) Parameters wsvA BodyVelocityWide effectiveMass Symmetric2x2Wide jacobians TangentFrictionOneBody.Jacobians maximumImpulse Vector<float> accumulatedImpulse Vector2Wide correctiveCSI Vector2Wide ComputeJacobians(in Vector3Wide, in Vector3Wide, in Vector3Wide, out Jacobians) public static void ComputeJacobians(in Vector3Wide tangentX, in Vector3Wide tangentY, in Vector3Wide offsetA, out TangentFrictionOneBody.Jacobians jacobians) Parameters tangentX Vector3Wide tangentY Vector3Wide offsetA Vector3Wide jacobians TangentFrictionOneBody.Jacobians Solve(in Vector3Wide, in Vector3Wide, in Vector3Wide, in BodyInertiaWide, in Vector<float>, ref Vector2Wide, ref BodyVelocityWide) public static void Solve(in Vector3Wide tangentX, in Vector3Wide tangentY, in Vector3Wide offsetToManifoldCenterA, in BodyInertiaWide inertiaA, in Vector<float> maximumImpulse, ref Vector2Wide accumulatedImpulse, ref BodyVelocityWide wsvA) Parameters tangentX Vector3Wide tangentY Vector3Wide offsetToManifoldCenterA Vector3Wide inertiaA BodyInertiaWide maximumImpulse Vector<float> accumulatedImpulse Vector2Wide wsvA BodyVelocityWide WarmStart(in Vector3Wide, in Vector3Wide, in Vector3Wide, in BodyInertiaWide, in Vector2Wide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide tangentX, in Vector3Wide tangentY, in Vector3Wide offsetToManifoldCenterA, in BodyInertiaWide inertiaA, in Vector2Wide accumulatedImpulse, ref BodyVelocityWide wsvA) Parameters tangentX Vector3Wide tangentY Vector3Wide offsetToManifoldCenterA Vector3Wide inertiaA BodyInertiaWide accumulatedImpulse Vector2Wide wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.TwistFriction.html": {
    "href": "api/BepuPhysics.Constraints.Contact.TwistFriction.html",
    "title": "Class TwistFriction | Bepu API",
    "keywords": "Class TwistFriction Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the tangent friction implementation. public static class TwistFriction Inheritance object TwistFriction Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ApplyImpulse(in Vector3Wide, in BodyInertiaWide, in BodyInertiaWide, in Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies. public static void ApplyImpulse(in Vector3Wide angularJacobianA, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector<float> correctiveImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters angularJacobianA Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide correctiveImpulse Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide ComputeCorrectiveImpulse(in Vector3Wide, in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, in Vector<float>, ref Vector<float>, out Vector<float>) public static void ComputeCorrectiveImpulse(in Vector3Wide angularJacobianA, in Vector<float> effectiveMass, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, in Vector<float> maximumImpulse, ref Vector<float> accumulatedImpulse, out Vector<float> correctiveCSI) Parameters angularJacobianA Vector3Wide effectiveMass Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide maximumImpulse Vector<float> accumulatedImpulse Vector<float> correctiveCSI Vector<float> Solve(in Vector3Wide, in BodyInertiaWide, in BodyInertiaWide, in Vector<float>, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide angularJacobianA, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector<float> maximumImpulse, ref Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters angularJacobianA Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide maximumImpulse Vector<float> accumulatedImpulse Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in BodyInertiaWide, in BodyInertiaWide, in Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide angularJacobianA, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters angularJacobianA Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide accumulatedImpulse Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.TwistFrictionOneBody.html": {
    "href": "api/BepuPhysics.Constraints.Contact.TwistFrictionOneBody.html",
    "title": "Class TwistFrictionOneBody | Bepu API",
    "keywords": "Class TwistFrictionOneBody Namespace BepuPhysics.Constraints.Contact Assembly BepuPhysics.dll Handles the tangent friction implementation. public static class TwistFrictionOneBody Inheritance object TwistFrictionOneBody Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ApplyImpulse(in Vector3Wide, in BodyInertiaWide, in Vector<float>, ref BodyVelocityWide) Transforms an impulse from constraint space to world space, uses it to modify the cached world space velocities of the bodies. public static void ApplyImpulse(in Vector3Wide angularJacobianA, in BodyInertiaWide inertiaA, in Vector<float> correctiveImpulse, ref BodyVelocityWide wsvA) Parameters angularJacobianA Vector3Wide inertiaA BodyInertiaWide correctiveImpulse Vector<float> wsvA BodyVelocityWide ComputeCorrectiveImpulse(in Vector3Wide, in Vector<float>, in BodyVelocityWide, in Vector<float>, ref Vector<float>, out Vector<float>) public static void ComputeCorrectiveImpulse(in Vector3Wide angularJacobianA, in Vector<float> effectiveMass, in BodyVelocityWide wsvA, in Vector<float> maximumImpulse, ref Vector<float> accumulatedImpulse, out Vector<float> correctiveCSI) Parameters angularJacobianA Vector3Wide effectiveMass Vector<float> wsvA BodyVelocityWide maximumImpulse Vector<float> accumulatedImpulse Vector<float> correctiveCSI Vector<float> Solve(in Vector3Wide, in BodyInertiaWide, in Vector<float>, ref Vector<float>, ref BodyVelocityWide) public static void Solve(in Vector3Wide angularJacobianA, in BodyInertiaWide inertiaA, in Vector<float> maximumImpulse, ref Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA) Parameters angularJacobianA Vector3Wide inertiaA BodyInertiaWide maximumImpulse Vector<float> accumulatedImpulse Vector<float> wsvA BodyVelocityWide WarmStart(in Vector3Wide, in BodyInertiaWide, in Vector<float>, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide angularJacobianA, in BodyInertiaWide inertiaA, in Vector<float> accumulatedImpulse, ref BodyVelocityWide wsvA) Parameters angularJacobianA Vector3Wide inertiaA BodyInertiaWide accumulatedImpulse Vector<float> wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.Contact.html": {
    "href": "api/BepuPhysics.Constraints.Contact.html",
    "title": "Namespace BepuPhysics.Constraints.Contact | Bepu API",
    "keywords": "Namespace BepuPhysics.Constraints.Contact Classes Contact1OneBodyTypeProcessor Handles the solve iterations of a bunch of 1-contact one body manifold constraints. Contact1TypeProcessor Handles the solve iterations of a bunch of 1-contact two body manifold constraints. Contact2NonconvexOneBodyTypeProcessor Handles the solve iterations of a bunch of 2-contact nonconvex one body manifold constraints. Contact2NonconvexTypeProcessor Handles the solve iterations of a bunch of 2-contact nonconvex two body manifold constraints. Contact2OneBodyTypeProcessor Handles the solve iterations of a bunch of 2-contact one body manifold constraints. Contact2TypeProcessor Handles the solve iterations of a bunch of 2-contact two body manifold constraints. Contact3NonconvexOneBodyTypeProcessor Handles the solve iterations of a bunch of 3-contact nonconvex one body manifold constraints. Contact3NonconvexTypeProcessor Handles the solve iterations of a bunch of 3-contact nonconvex two body manifold constraints. Contact3OneBodyTypeProcessor Handles the solve iterations of a bunch of 3-contact one body manifold constraints. Contact3TypeProcessor Handles the solve iterations of a bunch of 3-contact two body manifold constraints. Contact4NonconvexOneBodyTypeProcessor Handles the solve iterations of a bunch of 4-contact nonconvex one body manifold constraints. Contact4NonconvexTypeProcessor Handles the solve iterations of a bunch of 4-contact nonconvex two body manifold constraints. Contact4OneBodyTypeProcessor Handles the solve iterations of a bunch of 4-contact one body manifold constraints. Contact4TypeProcessor Handles the solve iterations of a bunch of 4-contact two body manifold constraints. PenetrationLimit PenetrationLimitOneBody TangentFriction Handles the tangent friction implementation. TangentFrictionOneBody Handles the tangent friction implementation for one body contact constraints. TwistFriction Handles the tangent friction implementation. TwistFrictionOneBody Handles the tangent friction implementation. Structs ConstraintContactData Contact1 Contact1AccumulatedImpulses Contact1Functions Contact1OneBody Contact1OneBodyFunctions Contact1OneBodyPrestepData Contact1PrestepData Contact2 Contact2AccumulatedImpulses Contact2Functions Contact2Nonconvex Contact2NonconvexAccumulatedImpulses Contact2NonconvexOneBody Contact2NonconvexOneBodyPrestepData Contact2NonconvexPrestepData Contact2OneBody Contact2OneBodyFunctions Contact2OneBodyPrestepData Contact2PrestepData Contact3 Contact3AccumulatedImpulses Contact3Functions Contact3Nonconvex Contact3NonconvexAccumulatedImpulses Contact3NonconvexOneBody Contact3NonconvexOneBodyPrestepData Contact3NonconvexPrestepData Contact3OneBody Contact3OneBodyFunctions Contact3OneBodyPrestepData Contact3PrestepData Contact4 Contact4AccumulatedImpulses Contact4Functions Contact4Nonconvex Contact4NonconvexAccumulatedImpulses Contact4NonconvexOneBody Contact4NonconvexOneBodyPrestepData Contact4NonconvexPrestepData Contact4OneBody Contact4OneBodyFunctions Contact4OneBodyPrestepData Contact4PrestepData ContactNonconvexOneBodyFunctions<TPrestep, TAccumulatedImpulses> ContactNonconvexTwoBodyFunctions<TPrestep, TAccumulatedImpulses> ConvexContactWide MaterialPropertiesWide NonconvexAccumulatedImpulses NonconvexConstraintContactData NonconvexContactPrestepData NonconvexOneBodyManifoldConstraintProperties NonconvexTwoBodyManifoldConstraintProperties TangentFriction.Jacobians TangentFrictionOneBody.Jacobians Interfaces IContactAccumulatedImpulses<TAccumulatedImpulses> IContactPrestep<TPrestep> IConvexContactAccumulatedImpulses<TAccumulatedImpulses> IConvexContactPrestep<TPrestep> IConvexOneBodyContactConstraintDescription<TDescription> IConvexTwoBodyContactConstraintDescription<TDescription> INonconvexContactAccumulatedImpulses<TAccumulatedImpulses> INonconvexContactPrestep<TPrestep> INonconvexOneBodyContactConstraintDescription<TDescription> INonconvexTwoBodyContactConstraintDescription<TDescription> ISolverContactDataExtractor Callbacks for direct references to the solver's contact constraint data. ISolverContactPrestepAndImpulsesExtractor Callbacks for direct references to the solver's contact constraint data. Includes only prestep and impulse data. ITwoBodyConvexContactPrestep<TPrestep> ITwoBodyNonconvexContactPrestep<TPrestep>"
  },
  "api/BepuPhysics.Constraints.DisallowPoseIntegration.html": {
    "href": "api/BepuPhysics.Constraints.DisallowPoseIntegration.html",
    "title": "Struct DisallowPoseIntegration | Bepu API",
    "keywords": "Struct DisallowPoseIntegration Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks a batch as not integrating poses for any bodies within the constraint batch. public struct DisallowPoseIntegration : IBatchPoseIntegrationAllowed Implements IBatchPoseIntegrationAllowed Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object)"
  },
  "api/BepuPhysics.Constraints.DistanceLimit.html": {
    "href": "api/BepuPhysics.Constraints.DistanceLimit.html",
    "title": "Struct DistanceLimit | Bepu API",
    "keywords": "Struct DistanceLimit Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains points on two bodies to be separated by a distance within a range. public struct DistanceLimit : ITwoBodyConstraintDescription<DistanceLimit>, IConstraintDescription<DistanceLimit> Implements ITwoBodyConstraintDescription<DistanceLimit> IConstraintDescription<DistanceLimit> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors DistanceLimit(Vector3, Vector3, float, float, in SpringSettings) Creates a distance limit description. public DistanceLimit(Vector3 localOffsetA, Vector3 localOffsetB, float minimumDistance, float maximumDistance, in SpringSettings springSettings) Parameters localOffsetA Vector3 Local offset from the center of body A to its attachment point. localOffsetB Vector3 Local offset from the center of body B to its attachment point. minimumDistance float Minimum distance permitted between the point on A and the point on B. maximumDistance float Maximum distance permitted between the point on A and the point on B. springSettings SpringSettings Spring frequency and damping parameters. Fields LocalOffsetA Local offset from the center of body A to its attachment point. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Local offset from the center of body B to its attachment point. public Vector3 LocalOffsetB Field Value Vector3 MaximumDistance Maximum distance permitted between the point on A and the point on B. public float MaximumDistance Field Value float MinimumDistance Minimum distance permitted between the point on A and the point on B. public float MinimumDistance Field Value float SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out DistanceLimit) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out DistanceLimit description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description DistanceLimit Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.DistanceLimitFunctions.html": {
    "href": "api/BepuPhysics.Constraints.DistanceLimitFunctions.html",
    "title": "Struct DistanceLimitFunctions | Bepu API",
    "keywords": "Struct DistanceLimitFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct DistanceLimitFunctions : ITwoBodyConstraintFunctions<DistanceLimitPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<DistanceLimitPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(in Vector3Wide, in Vector3Wide, in Vector3Wide, in BodyInertiaWide, in BodyInertiaWide, in Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void ApplyImpulse(in Vector3Wide linearJacobianA, in Vector3Wide angularJacobianA, in Vector3Wide angularJacobianB, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector<float> csi, ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB) Parameters linearJacobianA Vector3Wide angularJacobianA Vector3Wide angularJacobianB Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide csi Vector<float> velocityA BodyVelocityWide velocityB BodyVelocityWide ComputeJacobians(in Vector3Wide, in Vector3Wide, in QuaternionWide, in Vector3Wide, in Vector3Wide, in QuaternionWide, in Vector<float>, in Vector<float>, out Vector<int>, out Vector<float>, out Vector3Wide, out Vector3Wide, out Vector3Wide) public static void ComputeJacobians(in Vector3Wide localOffsetA, in Vector3Wide positionA, in QuaternionWide orientationA, in Vector3Wide localOffsetB, in Vector3Wide positionB, in QuaternionWide orientationB, in Vector<float> minimumDistance, in Vector<float> maximumDistance, out Vector<int> useMinimum, out Vector<float> distance, out Vector3Wide direction, out Vector3Wide angularJA, out Vector3Wide angularJB) Parameters localOffsetA Vector3Wide positionA Vector3Wide orientationA QuaternionWide localOffsetB Vector3Wide positionB Vector3Wide orientationB QuaternionWide minimumDistance Vector<float> maximumDistance Vector<float> useMinimum Vector<int> distance Vector<float> direction Vector3Wide angularJA Vector3Wide angularJB Vector3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref DistanceLimitPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref DistanceLimitPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData DistanceLimitPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref DistanceLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref DistanceLimitPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep DistanceLimitPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref DistanceLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref DistanceLimitPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep DistanceLimitPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.DistanceLimitPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.DistanceLimitPrestepData.html",
    "title": "Struct DistanceLimitPrestepData | Bepu API",
    "keywords": "Struct DistanceLimitPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct DistanceLimitPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide MaximumDistance public Vector<float> MaximumDistance Field Value Vector<float> MinimumDistance public Vector<float> MinimumDistance Field Value Vector<float> SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.DistanceLimitTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.DistanceLimitTypeProcessor.html",
    "title": "Class DistanceLimitTypeProcessor | Bepu API",
    "keywords": "Class DistanceLimitTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of distance servos. public class DistanceLimitTypeProcessor : TwoBodyTypeProcessor<DistanceLimitPrestepData, Vector<float>, DistanceLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>> TwoBodyTypeProcessor<DistanceLimitPrestepData, Vector<float>, DistanceLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll> DistanceLimitTypeProcessor Inherited Members TwoBodyTypeProcessor<DistanceLimitPrestepData, Vector<float>, DistanceLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<DistanceLimitPrestepData, Vector<float>, DistanceLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<DistanceLimitPrestepData, Vector<float>, DistanceLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<DistanceLimitPrestepData, Vector<float>, DistanceLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<DistanceLimitPrestepData, Vector<float>, DistanceLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref DistanceLimitPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref DistanceLimitPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, DistanceLimitPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 34 Field Value int"
  },
  "api/BepuPhysics.Constraints.DistanceServo.html": {
    "href": "api/BepuPhysics.Constraints.DistanceServo.html",
    "title": "Struct DistanceServo | Bepu API",
    "keywords": "Struct DistanceServo Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains points on two bodies to be separated by a goal distance. public struct DistanceServo : ITwoBodyConstraintDescription<DistanceServo>, IConstraintDescription<DistanceServo> Implements ITwoBodyConstraintDescription<DistanceServo> IConstraintDescription<DistanceServo> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors DistanceServo(Vector3, Vector3, float, in SpringSettings) public DistanceServo(Vector3 localOffsetA, Vector3 localOffsetB, float targetDistance, in SpringSettings springSettings) Parameters localOffsetA Vector3 localOffsetB Vector3 targetDistance float springSettings SpringSettings DistanceServo(Vector3, Vector3, float, in SpringSettings, in ServoSettings) Creates a distance servo description. public DistanceServo(Vector3 localOffsetA, Vector3 localOffsetB, float targetDistance, in SpringSettings springSettings, in ServoSettings servoSettings) Parameters localOffsetA Vector3 Local offset from the center of body A to its attachment point. localOffsetB Vector3 Local offset from the center of body B to its attachment point. targetDistance float Distance that the constraint will try to reach between the attachment points. springSettings SpringSettings Spring frequency and damping parameters. servoSettings ServoSettings Servo control parameters. Fields LocalOffsetA Local offset from the center of body A to its attachment point. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Local offset from the center of body B to its attachment point. public Vector3 LocalOffsetB Field Value Vector3 ServoSettings Servo control parameters. public ServoSettings ServoSettings Field Value ServoSettings SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings TargetDistance Distance that the constraint will try to reach between the attachment points. public float TargetDistance Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out DistanceServo) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out DistanceServo description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description DistanceServo Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.DistanceServoFunctions.html": {
    "href": "api/BepuPhysics.Constraints.DistanceServoFunctions.html",
    "title": "Struct DistanceServoFunctions | Bepu API",
    "keywords": "Struct DistanceServoFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct DistanceServoFunctions : ITwoBodyConstraintFunctions<DistanceServoPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<DistanceServoPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(in Vector<float>, in Vector<float>, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void ApplyImpulse(in Vector<float> inverseMassA, in Vector<float> inverseMassB, in Vector3Wide direction, in Vector3Wide angularImpulseToVelocityA, in Vector3Wide angularImpulseToVelocityB, in Vector<float> csi, ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB) Parameters inverseMassA Vector<float> inverseMassB Vector<float> direction Vector3Wide angularImpulseToVelocityA Vector3Wide angularImpulseToVelocityB Vector3Wide csi Vector<float> velocityA BodyVelocityWide velocityB BodyVelocityWide ComputeJacobian(in Vector<float>, in Vector3Wide, in Vector3Wide, ref Vector3Wide, out Vector3Wide, out Vector3Wide) public static void ComputeJacobian(in Vector<float> distance, in Vector3Wide anchorOffsetA, in Vector3Wide anchorOffsetB, ref Vector3Wide direction, out Vector3Wide angularJA, out Vector3Wide angularJB) Parameters distance Vector<float> anchorOffsetA Vector3Wide anchorOffsetB Vector3Wide direction Vector3Wide angularJA Vector3Wide angularJB Vector3Wide ComputeTransforms(in BodyInertiaWide, in BodyInertiaWide, in Vector3Wide, in Vector3Wide, in Vector<float>, ref Vector3Wide, float, in SpringSettingsWide, out Vector<float>, out Vector<float>, out Vector<float>, out Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector3Wide) public static void ComputeTransforms(in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector3Wide anchorOffsetA, in Vector3Wide anchorOffsetB, in Vector<float> distance, ref Vector3Wide direction, float dt, in SpringSettingsWide springSettings, out Vector<float> positionErrorToVelocity, out Vector<float> softnessImpulseScale, out Vector<float> effectiveMass, out Vector3Wide angularJA, out Vector3Wide angularJB, out Vector3Wide angularImpulseToVelocityA, out Vector3Wide angularImpulseToVelocityB) Parameters inertiaA BodyInertiaWide inertiaB BodyInertiaWide anchorOffsetA Vector3Wide anchorOffsetB Vector3Wide distance Vector<float> direction Vector3Wide dt float springSettings SpringSettingsWide positionErrorToVelocity Vector<float> softnessImpulseScale Vector<float> effectiveMass Vector<float> angularJA Vector3Wide angularJB Vector3Wide angularImpulseToVelocityA Vector3Wide angularImpulseToVelocityB Vector3Wide GetDistance(in QuaternionWide, in Vector3Wide, in QuaternionWide, in Vector3Wide, in Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector<float>) public static void GetDistance(in QuaternionWide orientationA, in Vector3Wide ab, in QuaternionWide orientationB, in Vector3Wide localOffsetA, in Vector3Wide localOffsetB, out Vector3Wide anchorOffsetA, out Vector3Wide anchorOffsetB, out Vector3Wide anchorOffset, out Vector<float> distance) Parameters orientationA QuaternionWide ab Vector3Wide orientationB QuaternionWide localOffsetA Vector3Wide localOffsetB Vector3Wide anchorOffsetA Vector3Wide anchorOffsetB Vector3Wide anchorOffset Vector3Wide distance Vector<float> IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref DistanceServoPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref DistanceServoPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData DistanceServoPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref DistanceServoPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref DistanceServoPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep DistanceServoPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref DistanceServoPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref DistanceServoPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep DistanceServoPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.DistanceServoPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.DistanceServoPrestepData.html",
    "title": "Struct DistanceServoPrestepData | Bepu API",
    "keywords": "Struct DistanceServoPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct DistanceServoPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide ServoSettings public ServoSettingsWide ServoSettings Field Value ServoSettingsWide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide TargetDistance public Vector<float> TargetDistance Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.DistanceServoTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.DistanceServoTypeProcessor.html",
    "title": "Class DistanceServoTypeProcessor | Bepu API",
    "keywords": "Class DistanceServoTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of distance servos. public class DistanceServoTypeProcessor : TwoBodyTypeProcessor<DistanceServoPrestepData, Vector<float>, DistanceServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>> TwoBodyTypeProcessor<DistanceServoPrestepData, Vector<float>, DistanceServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll> DistanceServoTypeProcessor Inherited Members TwoBodyTypeProcessor<DistanceServoPrestepData, Vector<float>, DistanceServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<DistanceServoPrestepData, Vector<float>, DistanceServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<DistanceServoPrestepData, Vector<float>, DistanceServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<DistanceServoPrestepData, Vector<float>, DistanceServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<DistanceServoPrestepData, Vector<float>, DistanceServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref DistanceServoPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref DistanceServoPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, DistanceServoPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 33 Field Value int"
  },
  "api/BepuPhysics.Constraints.FourBodyReferences.html": {
    "href": "api/BepuPhysics.Constraints.FourBodyReferences.html",
    "title": "Struct FourBodyReferences | Bepu API",
    "keywords": "Struct FourBodyReferences Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve. public struct FourBodyReferences Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields IndexA public Vector<int> IndexA Field Value Vector<int> IndexB public Vector<int> IndexB Field Value Vector<int> IndexC public Vector<int> IndexC Field Value Vector<int> IndexD public Vector<int> IndexD Field Value Vector<int>"
  },
  "api/BepuPhysics.Constraints.FourBodyTypeProcessor-11.html": {
    "href": "api/BepuPhysics.Constraints.FourBodyTypeProcessor-11.html",
    "title": "Class FourBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TWarmStartAccessFilterD, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC, TSolveAccessFilterD> | Bepu API",
    "keywords": "Class FourBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TWarmStartAccessFilterD, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC, TSolveAccessFilterD> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Shared implementation across all four body constraints. public abstract class FourBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TWarmStartAccessFilterD, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC, TSolveAccessFilterD> : TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse> where TPrestepData : unmanaged where TAccumulatedImpulse : unmanaged where TConstraintFunctions : unmanaged, IFourBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> where TWarmStartAccessFilterA : unmanaged, IBodyAccessFilter where TWarmStartAccessFilterB : unmanaged, IBodyAccessFilter where TWarmStartAccessFilterC : unmanaged, IBodyAccessFilter where TWarmStartAccessFilterD : unmanaged, IBodyAccessFilter where TSolveAccessFilterA : unmanaged, IBodyAccessFilter where TSolveAccessFilterB : unmanaged, IBodyAccessFilter where TSolveAccessFilterC : unmanaged, IBodyAccessFilter where TSolveAccessFilterD : unmanaged, IBodyAccessFilter Type Parameters TPrestepData TAccumulatedImpulse TConstraintFunctions TWarmStartAccessFilterA TWarmStartAccessFilterB TWarmStartAccessFilterC TWarmStartAccessFilterD TSolveAccessFilterA TSolveAccessFilterB TSolveAccessFilterC TSolveAccessFilterD Inheritance object TypeProcessor TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse> FourBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TWarmStartAccessFilterD, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC, TSolveAccessFilterD> Derived VolumeConstraintTypeProcessor Inherited Members TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.InternalConstrainedDegreesOfFreedom TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.SetBodyReferencesLane(ref FourBodyReferences, int, Span<int>) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.AddBodyReferencesLane(ref FourBodyReferences, int, Span<int>) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.RemoveBodyReferencesLane(ref FourBodyReferences, int) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.Move(ref FourBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ConstraintHandle, int, ref FourBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<FourBodyReferences, TPrestepData, TAccumulatedImpulse>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties InternalBodiesPerConstraint protected override sealed int InternalBodiesPerConstraint { get; } Property Value int RequiresIncrementalSubstepUpdates Gets whether this type requires incremental updates for each substep in a frame beyond the first. public override bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) public override void IncrementallyUpdateForSubstep(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int exclusiveEndBundle) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int exclusiveEndBundle int Solve(ref TypeBatch, Bodies, float, float, int, int) public override void Solve(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int exclusiveEndBundle) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int exclusiveEndBundle int WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) public override void WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch typeBatch, ref Buffer<IndexSet> integrationFlags, Bodies bodies, ref TIntegratorCallbacks integratorCallbacks, float dt, float inverseDt, int startBundle, int exclusiveEndBundle, int workerIndex) where TIntegratorCallbacks : struct, IPoseIntegratorCallbacks where TBatchIntegrationMode : unmanaged, IBatchIntegrationMode where TAllowPoseIntegration : unmanaged, IBatchPoseIntegrationAllowed Parameters typeBatch TypeBatch integrationFlags Buffer<IndexSet> bodies Bodies integratorCallbacks TIntegratorCallbacks dt float inverseDt float startBundle int exclusiveEndBundle int workerIndex int Type Parameters TIntegratorCallbacks TBatchIntegrationMode TAllowPoseIntegration"
  },
  "api/BepuPhysics.Constraints.Hinge.html": {
    "href": "api/BepuPhysics.Constraints.Hinge.html",
    "title": "Struct Hinge | Bepu API",
    "keywords": "Struct Hinge Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains two bodies with a hinge. Equivalent to a BallSocket constraint and an AngularHinge constraint solved together. public struct Hinge : ITwoBodyConstraintDescription<Hinge>, IConstraintDescription<Hinge> Implements ITwoBodyConstraintDescription<Hinge> IConstraintDescription<Hinge> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalHingeAxisA Hinge axis in the local space of A. public Vector3 LocalHingeAxisA Field Value Vector3 LocalHingeAxisB Hinge axis in the local space of B. public Vector3 LocalHingeAxisB Field Value Vector3 LocalOffsetA Local offset from the center of body A to its attachment point. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Local offset from the center of body B to its attachment point. public Vector3 LocalOffsetB Field Value Vector3 SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Hinge) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Hinge description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Hinge Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.HingeAccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.HingeAccumulatedImpulses.html",
    "title": "Struct HingeAccumulatedImpulses | Bepu API",
    "keywords": "Struct HingeAccumulatedImpulses Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct HingeAccumulatedImpulses Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields BallSocket public Vector3Wide BallSocket Field Value Vector3Wide Hinge public Vector2Wide Hinge Field Value Vector2Wide"
  },
  "api/BepuPhysics.Constraints.HingeFunctions.html": {
    "href": "api/BepuPhysics.Constraints.HingeFunctions.html",
    "title": "Struct HingeFunctions | Bepu API",
    "keywords": "Struct HingeFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct HingeFunctions : ITwoBodyConstraintFunctions<HingePrestepData, HingeAccumulatedImpulses> Implements ITwoBodyConstraintFunctions<HingePrestepData, HingeAccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref HingePrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref HingePrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData HingePrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref HingePrestepData, ref HingeAccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref HingePrestepData prestep, ref HingeAccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep HingePrestepData accumulatedImpulses HingeAccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref HingePrestepData, ref HingeAccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref HingePrestepData prestep, ref HingeAccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep HingePrestepData accumulatedImpulses HingeAccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.HingePrestepData.html": {
    "href": "api/BepuPhysics.Constraints.HingePrestepData.html",
    "title": "Struct HingePrestepData | Bepu API",
    "keywords": "Struct HingePrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct HingePrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalHingeAxisA public Vector3Wide LocalHingeAxisA Field Value Vector3Wide LocalHingeAxisB public Vector3Wide LocalHingeAxisB Field Value Vector3Wide LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.HingeTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.HingeTypeProcessor.html",
    "title": "Class HingeTypeProcessor | Bepu API",
    "keywords": "Class HingeTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class HingeTypeProcessor : TwoBodyTypeProcessor<HingePrestepData, HingeAccumulatedImpulses, HingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses> TwoBodyTypeProcessor<HingePrestepData, HingeAccumulatedImpulses, HingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll> HingeTypeProcessor Inherited Members TwoBodyTypeProcessor<HingePrestepData, HingeAccumulatedImpulses, HingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<HingePrestepData, HingeAccumulatedImpulses, HingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<HingePrestepData, HingeAccumulatedImpulses, HingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<HingePrestepData, HingeAccumulatedImpulses, HingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<HingePrestepData, HingeAccumulatedImpulses, HingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.Move(ref TwoBodyReferences, ref HingePrestepData, ref HingeAccumulatedImpulses, ConstraintHandle, int, ref TwoBodyReferences, ref HingePrestepData, ref HingeAccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, HingePrestepData, HingeAccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 47 Field Value int"
  },
  "api/BepuPhysics.Constraints.IBatchIntegrationMode.html": {
    "href": "api/BepuPhysics.Constraints.IBatchIntegrationMode.html",
    "title": "Interface IBatchIntegrationMode | Bepu API",
    "keywords": "Interface IBatchIntegrationMode Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks a type as determining the integration mode for a solver batch. public interface IBatchIntegrationMode"
  },
  "api/BepuPhysics.Constraints.IBatchPoseIntegrationAllowed.html": {
    "href": "api/BepuPhysics.Constraints.IBatchPoseIntegrationAllowed.html",
    "title": "Interface IBatchPoseIntegrationAllowed | Bepu API",
    "keywords": "Interface IBatchPoseIntegrationAllowed Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks a type as determining whether pose integration should be performed on bodies within the constraint batch. public interface IBatchPoseIntegrationAllowed"
  },
  "api/BepuPhysics.Constraints.IBodyAccessFilter.html": {
    "href": "api/BepuPhysics.Constraints.IBodyAccessFilter.html",
    "title": "Interface IBodyAccessFilter | Bepu API",
    "keywords": "Interface IBodyAccessFilter Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains which body properties should be accessed in a body during constraint data gathering/scattering. public interface IBodyAccessFilter Properties AccessAngularVelocity Gets whether to load or store body linear velocity in this constraint. bool AccessAngularVelocity { get; } Property Value bool AccessLinearVelocity Gets whether to load or store body linear velocity in this constraint. bool AccessLinearVelocity { get; } Property Value bool GatherInertiaTensor Gets whether body inertia tensor is loaded by this constraint. bool GatherInertiaTensor { get; } Property Value bool GatherMass Gets whether body mass is loaded by this constraint. bool GatherMass { get; } Property Value bool GatherOrientation Gets whether orientation is loaded by the constraint. bool GatherOrientation { get; } Property Value bool GatherPosition Gets whether position is loaded by the constraint. bool GatherPosition { get; } Property Value bool"
  },
  "api/BepuPhysics.Constraints.IConstraintDescription-1.html": {
    "href": "api/BepuPhysics.Constraints.IConstraintDescription-1.html",
    "title": "Interface IConstraintDescription<TDescription> | Bepu API",
    "keywords": "Interface IConstraintDescription<TDescription> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks a type as a description of a constraint associated with a particular batch. public interface IConstraintDescription<TDescription> where TDescription : unmanaged, IConstraintDescription<TDescription> Type Parameters TDescription Type of the description object. Remarks Note that one batch may have multiple description types associated with it, each one potentially offering a different subset of properties or translation logic. Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static abstract int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static abstract Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out TDescription) Creates a description from the batch-held memory at a given location. public static abstract void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out TDescription description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description TDescription Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static abstract TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.IFourBodyConstraintDescription-1.html": {
    "href": "api/BepuPhysics.Constraints.IFourBodyConstraintDescription-1.html",
    "title": "Interface IFourBodyConstraintDescription<TDescription> | Bepu API",
    "keywords": "Interface IFourBodyConstraintDescription<TDescription> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks a type as a four body constraint description. public interface IFourBodyConstraintDescription<TDescription> : IConstraintDescription<TDescription> where TDescription : unmanaged, IFourBodyConstraintDescription<TDescription> Type Parameters TDescription Type of the description. Inherited Members IConstraintDescription<TDescription>.ApplyDescription(ref TypeBatch, int, int) IConstraintDescription<TDescription>.BuildDescription(ref TypeBatch, int, int, out TDescription) IConstraintDescription<TDescription>.ConstraintTypeId IConstraintDescription<TDescription>.TypeProcessorType IConstraintDescription<TDescription>.CreateTypeProcessor() Remarks This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts."
  },
  "api/BepuPhysics.Constraints.IFourBodyConstraintFunctions-2.html": {
    "href": "api/BepuPhysics.Constraints.IFourBodyConstraintFunctions-2.html",
    "title": "Interface IFourBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> | Bepu API",
    "keywords": "Interface IFourBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Prestep, warm start and solve iteration functions for a four body constraint type. public interface IFourBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Type Parameters TPrestepData Type of the prestep data used by the constraint. TAccumulatedImpulse Type of the accumulated impulses used by the constraint. Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static abstract bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, in BodyVelocityWide, in BodyVelocityWide, ref TPrestepData) public static abstract void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, in BodyVelocityWide wsvC, in BodyVelocityWide wsvD, ref TPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide wsvD BodyVelocityWide prestepData TPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref TPrestepData, ref TAccumulatedImpulse, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide) public static abstract void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, in Vector3Wide positionC, in QuaternionWide orientationC, in BodyInertiaWide inertiaC, in Vector3Wide positionD, in QuaternionWide orientationD, in BodyInertiaWide inertiaD, float dt, float inverseDt, ref TPrestepData prestep, ref TAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB, ref BodyVelocityWide wsvC, ref BodyVelocityWide wsvD) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide positionC Vector3Wide orientationC QuaternionWide inertiaC BodyInertiaWide positionD Vector3Wide orientationD QuaternionWide inertiaD BodyInertiaWide dt float inverseDt float prestep TPrestepData accumulatedImpulses TAccumulatedImpulse wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide wsvD BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref TPrestepData, ref TAccumulatedImpulse, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide) public static abstract void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, in Vector3Wide positionC, in QuaternionWide orientationC, in BodyInertiaWide inertiaC, in Vector3Wide positionD, in QuaternionWide orientationD, in BodyInertiaWide inertiaD, ref TPrestepData prestep, ref TAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB, ref BodyVelocityWide wsvC, ref BodyVelocityWide wsvD) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide positionC Vector3Wide orientationC QuaternionWide inertiaC BodyInertiaWide positionD Vector3Wide orientationD QuaternionWide inertiaD BodyInertiaWide prestep TPrestepData accumulatedImpulses TAccumulatedImpulse wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide wsvD BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.IOneBodyConstraintDescription-1.html": {
    "href": "api/BepuPhysics.Constraints.IOneBodyConstraintDescription-1.html",
    "title": "Interface IOneBodyConstraintDescription<TDescription> | Bepu API",
    "keywords": "Interface IOneBodyConstraintDescription<TDescription> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks a type as a one body constraint description. public interface IOneBodyConstraintDescription<TDescription> : IConstraintDescription<TDescription> where TDescription : unmanaged, IOneBodyConstraintDescription<TDescription> Type Parameters TDescription Type of the description. Inherited Members IConstraintDescription<TDescription>.ApplyDescription(ref TypeBatch, int, int) IConstraintDescription<TDescription>.BuildDescription(ref TypeBatch, int, int, out TDescription) IConstraintDescription<TDescription>.ConstraintTypeId IConstraintDescription<TDescription>.TypeProcessorType IConstraintDescription<TDescription>.CreateTypeProcessor() Remarks This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts."
  },
  "api/BepuPhysics.Constraints.IOneBodyConstraintFunctions-2.html": {
    "href": "api/BepuPhysics.Constraints.IOneBodyConstraintFunctions-2.html",
    "title": "Interface IOneBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> | Bepu API",
    "keywords": "Interface IOneBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Prestep, warm start and solve iteration functions for a constraint type. public interface IOneBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Type Parameters TPrestepData Type of the prestep data used by the constraint. TAccumulatedImpulse Type of the accumulated impulses used by the constraint. Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static abstract bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref TPrestepData) public static abstract void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide velocity, ref TPrestepData prestepData) Parameters dt Vector<float> velocity BodyVelocityWide prestepData TPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref TPrestepData, ref TAccumulatedImpulse, ref BodyVelocityWide) public static abstract void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref TPrestepData prestep, ref TAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep TPrestepData accumulatedImpulses TAccumulatedImpulse wsvA BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref TPrestepData, ref TAccumulatedImpulse, ref BodyVelocityWide) public static abstract void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref TPrestepData prestep, ref TAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep TPrestepData accumulatedImpulses TAccumulatedImpulse wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.ISortKeyGenerator-1.html": {
    "href": "api/BepuPhysics.Constraints.ISortKeyGenerator-1.html",
    "title": "Interface ISortKeyGenerator<TBodyReferences> | Bepu API",
    "keywords": "Interface ISortKeyGenerator<TBodyReferences> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Defines a function that creates a sort key from body references in a type batch. Used by constraint layout optimization. public interface ISortKeyGenerator<TBodyReferences> where TBodyReferences : unmanaged Type Parameters TBodyReferences Methods GetSortKey(int, ref Buffer<TBodyReferences>) public static abstract int GetSortKey(int constraintIndex, ref Buffer<TBodyReferences> bodyReferences) Parameters constraintIndex int bodyReferences Buffer<TBodyReferences> Returns int"
  },
  "api/BepuPhysics.Constraints.IThreeBodyConstraintDescription-1.html": {
    "href": "api/BepuPhysics.Constraints.IThreeBodyConstraintDescription-1.html",
    "title": "Interface IThreeBodyConstraintDescription<TDescription> | Bepu API",
    "keywords": "Interface IThreeBodyConstraintDescription<TDescription> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks a type as a three body constraint description. public interface IThreeBodyConstraintDescription<TDescription> : IConstraintDescription<TDescription> where TDescription : unmanaged, IThreeBodyConstraintDescription<TDescription> Type Parameters TDescription Type of the description. Inherited Members IConstraintDescription<TDescription>.ApplyDescription(ref TypeBatch, int, int) IConstraintDescription<TDescription>.BuildDescription(ref TypeBatch, int, int, out TDescription) IConstraintDescription<TDescription>.ConstraintTypeId IConstraintDescription<TDescription>.TypeProcessorType IConstraintDescription<TDescription>.CreateTypeProcessor() Remarks This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts."
  },
  "api/BepuPhysics.Constraints.IThreeBodyConstraintFunctions-2.html": {
    "href": "api/BepuPhysics.Constraints.IThreeBodyConstraintFunctions-2.html",
    "title": "Interface IThreeBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> | Bepu API",
    "keywords": "Interface IThreeBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Prestep, warm start and solve iteration functions for a three body constraint type. public interface IThreeBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Type Parameters TPrestepData Type of the prestep data used by the constraint. TAccumulatedImpulse Type of the accumulated impulses used by the constraint. Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static abstract bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, in BodyVelocityWide, ref TPrestepData) public static abstract void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, in BodyVelocityWide wsvC, ref TPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide prestepData TPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref TPrestepData, ref TAccumulatedImpulse, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide) public static abstract void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, in Vector3Wide positionC, in QuaternionWide orientationC, in BodyInertiaWide inertiaC, float dt, float inverseDt, ref TPrestepData prestep, ref TAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB, ref BodyVelocityWide wsvC) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide positionC Vector3Wide orientationC QuaternionWide inertiaC BodyInertiaWide dt float inverseDt float prestep TPrestepData accumulatedImpulses TAccumulatedImpulse wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref TPrestepData, ref TAccumulatedImpulse, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide) public static abstract void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, in Vector3Wide positionC, in QuaternionWide orientationC, in BodyInertiaWide inertiaC, ref TPrestepData prestep, ref TAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB, ref BodyVelocityWide wsvC) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide positionC Vector3Wide orientationC QuaternionWide inertiaC BodyInertiaWide prestep TPrestepData accumulatedImpulses TAccumulatedImpulse wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.ITwoBodyConstraintDescription-1.html": {
    "href": "api/BepuPhysics.Constraints.ITwoBodyConstraintDescription-1.html",
    "title": "Interface ITwoBodyConstraintDescription<TDescription> | Bepu API",
    "keywords": "Interface ITwoBodyConstraintDescription<TDescription> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Marks a type as a two body constraint description. public interface ITwoBodyConstraintDescription<TDescription> : IConstraintDescription<TDescription> where TDescription : unmanaged, ITwoBodyConstraintDescription<TDescription> Type Parameters TDescription Type of the description. Inherited Members IConstraintDescription<TDescription>.ApplyDescription(ref TypeBatch, int, int) IConstraintDescription<TDescription>.BuildDescription(ref TypeBatch, int, int, out TDescription) IConstraintDescription<TDescription>.ConstraintTypeId IConstraintDescription<TDescription>.TypeProcessorType IConstraintDescription<TDescription>.CreateTypeProcessor() Remarks This and the other body-count aware interfaces exist to give the compiler a way to report errors when using Solver.Add with different body counts."
  },
  "api/BepuPhysics.Constraints.ITwoBodyConstraintFunctions-2.html": {
    "href": "api/BepuPhysics.Constraints.ITwoBodyConstraintFunctions-2.html",
    "title": "Interface ITwoBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> | Bepu API",
    "keywords": "Interface ITwoBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Prestep, warm start and solve iteration functions for a two body constraint type. public interface ITwoBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Type Parameters TPrestepData Type of the prestep data used by the constraint. TAccumulatedImpulse Type of the accumulated impulses used by the constraint. Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static abstract bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref TPrestepData) public static abstract void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref TPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData TPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref TPrestepData, ref TAccumulatedImpulse, ref BodyVelocityWide, ref BodyVelocityWide) public static abstract void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref TPrestepData prestep, ref TAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep TPrestepData accumulatedImpulses TAccumulatedImpulse wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref TPrestepData, ref TAccumulatedImpulse, ref BodyVelocityWide, ref BodyVelocityWide) public static abstract void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref TPrestepData prestep, ref TAccumulatedImpulse accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep TPrestepData accumulatedImpulses TAccumulatedImpulse wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.InequalityHelpers.html": {
    "href": "api/BepuPhysics.Constraints.InequalityHelpers.html",
    "title": "Class InequalityHelpers | Bepu API",
    "keywords": "Class InequalityHelpers Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public static class InequalityHelpers Inheritance object InequalityHelpers Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ClampPositive(ref Vector<float>, ref Vector<float>) public static void ClampPositive(ref Vector<float> accumulatedImpulse, ref Vector<float> impulse) Parameters accumulatedImpulse Vector<float> impulse Vector<float> ComputeBiasVelocity(Vector<float>, in Vector<float>, float, out Vector<float>) public static void ComputeBiasVelocity(Vector<float> error, in Vector<float> positionErrorToVelocity, float inverseDt, out Vector<float> biasVelocity) Parameters error Vector<float> positionErrorToVelocity Vector<float> inverseDt float biasVelocity Vector<float>"
  },
  "api/BepuPhysics.Constraints.LinearAxisLimit.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisLimit.html",
    "title": "Struct LinearAxisLimit | Bepu API",
    "keywords": "Struct LinearAxisLimit Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains points on two bodies to a range of offsets from each other along a direction anchored to body A. public struct LinearAxisLimit : ITwoBodyConstraintDescription<LinearAxisLimit>, IConstraintDescription<LinearAxisLimit> Implements ITwoBodyConstraintDescription<LinearAxisLimit> IConstraintDescription<LinearAxisLimit> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalAxis Direction of the motorized axis in the local space of body A. public Vector3 LocalAxis Field Value Vector3 LocalOffsetA Local offset from the center of body A to its attachment point. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Local offset from the center of body B to its attachment point. public Vector3 LocalOffsetB Field Value Vector3 MaximumOffset Maximum offset along the world axis between A and B's anchor points. public float MaximumOffset Field Value float MinimumOffset Minimum offset along the world axis between A and B's anchor points. public float MinimumOffset Field Value float SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out LinearAxisLimit) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out LinearAxisLimit description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description LinearAxisLimit Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.LinearAxisLimitFunctions.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisLimitFunctions.html",
    "title": "Struct LinearAxisLimitFunctions | Bepu API",
    "keywords": "Struct LinearAxisLimitFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct LinearAxisLimitFunctions : ITwoBodyConstraintFunctions<LinearAxisLimitPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<LinearAxisLimitPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref LinearAxisLimitPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref LinearAxisLimitPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData LinearAxisLimitPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref LinearAxisLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref LinearAxisLimitPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep LinearAxisLimitPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref LinearAxisLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref LinearAxisLimitPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep LinearAxisLimitPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.LinearAxisLimitPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisLimitPrestepData.html",
    "title": "Struct LinearAxisLimitPrestepData | Bepu API",
    "keywords": "Struct LinearAxisLimitPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct LinearAxisLimitPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide LocalPlaneNormal public Vector3Wide LocalPlaneNormal Field Value Vector3Wide MaximumOffset public Vector<float> MaximumOffset Field Value Vector<float> MinimumOffset public Vector<float> MinimumOffset Field Value Vector<float> SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.LinearAxisLimitTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisLimitTypeProcessor.html",
    "title": "Class LinearAxisLimitTypeProcessor | Bepu API",
    "keywords": "Class LinearAxisLimitTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class LinearAxisLimitTypeProcessor : TwoBodyTypeProcessor<LinearAxisLimitPrestepData, Vector<float>, LinearAxisLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>> TwoBodyTypeProcessor<LinearAxisLimitPrestepData, Vector<float>, LinearAxisLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll> LinearAxisLimitTypeProcessor Inherited Members TwoBodyTypeProcessor<LinearAxisLimitPrestepData, Vector<float>, LinearAxisLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<LinearAxisLimitPrestepData, Vector<float>, LinearAxisLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<LinearAxisLimitPrestepData, Vector<float>, LinearAxisLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<LinearAxisLimitPrestepData, Vector<float>, LinearAxisLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<LinearAxisLimitPrestepData, Vector<float>, LinearAxisLimitFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref LinearAxisLimitPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref LinearAxisLimitPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, LinearAxisLimitPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 40 Field Value int"
  },
  "api/BepuPhysics.Constraints.LinearAxisMotor.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisMotor.html",
    "title": "Struct LinearAxisMotor | Bepu API",
    "keywords": "Struct LinearAxisMotor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains points on two bodies to move relative to each other along a direction. public struct LinearAxisMotor : ITwoBodyConstraintDescription<LinearAxisMotor>, IConstraintDescription<LinearAxisMotor> Implements ITwoBodyConstraintDescription<LinearAxisMotor> IConstraintDescription<LinearAxisMotor> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalAxis Direction of the motorized axis in the local space of body A. public Vector3 LocalAxis Field Value Vector3 LocalOffsetA Local offset from the center of body A to its attachment point. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Local offset from the center of body B to its attachment point. public Vector3 LocalOffsetB Field Value Vector3 Settings Motor control parameters. public MotorSettings Settings Field Value MotorSettings TargetVelocity Target relative velocity along the world axis between A and B's anchor points. public float TargetVelocity Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out LinearAxisMotor) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out LinearAxisMotor description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description LinearAxisMotor Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.LinearAxisMotorFunctions.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisMotorFunctions.html",
    "title": "Struct LinearAxisMotorFunctions | Bepu API",
    "keywords": "Struct LinearAxisMotorFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct LinearAxisMotorFunctions : ITwoBodyConstraintFunctions<LinearAxisMotorPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<LinearAxisMotorPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref LinearAxisMotorPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref LinearAxisMotorPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData LinearAxisMotorPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref LinearAxisMotorPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref LinearAxisMotorPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep LinearAxisMotorPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref LinearAxisMotorPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref LinearAxisMotorPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep LinearAxisMotorPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.LinearAxisMotorPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisMotorPrestepData.html",
    "title": "Struct LinearAxisMotorPrestepData | Bepu API",
    "keywords": "Struct LinearAxisMotorPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct LinearAxisMotorPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide LocalPlaneNormal public Vector3Wide LocalPlaneNormal Field Value Vector3Wide Settings public MotorSettingsWide Settings Field Value MotorSettingsWide TargetVelocity public Vector<float> TargetVelocity Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.LinearAxisMotorTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisMotorTypeProcessor.html",
    "title": "Class LinearAxisMotorTypeProcessor | Bepu API",
    "keywords": "Class LinearAxisMotorTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class LinearAxisMotorTypeProcessor : TwoBodyTypeProcessor<LinearAxisMotorPrestepData, Vector<float>, LinearAxisMotorFunctions, AccessAll, AccessAll, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>> TwoBodyTypeProcessor<LinearAxisMotorPrestepData, Vector<float>, LinearAxisMotorFunctions, AccessAll, AccessAll, AccessAll, AccessAll> LinearAxisMotorTypeProcessor Inherited Members TwoBodyTypeProcessor<LinearAxisMotorPrestepData, Vector<float>, LinearAxisMotorFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<LinearAxisMotorPrestepData, Vector<float>, LinearAxisMotorFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<LinearAxisMotorPrestepData, Vector<float>, LinearAxisMotorFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<LinearAxisMotorPrestepData, Vector<float>, LinearAxisMotorFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<LinearAxisMotorPrestepData, Vector<float>, LinearAxisMotorFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref LinearAxisMotorPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref LinearAxisMotorPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, LinearAxisMotorPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 39 Field Value int"
  },
  "api/BepuPhysics.Constraints.LinearAxisServo.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisServo.html",
    "title": "Struct LinearAxisServo | Bepu API",
    "keywords": "Struct LinearAxisServo Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains points on two bodies to be on a plane defined in the local space of one of the bodies. public struct LinearAxisServo : ITwoBodyConstraintDescription<LinearAxisServo>, IConstraintDescription<LinearAxisServo> Implements ITwoBodyConstraintDescription<LinearAxisServo> IConstraintDescription<LinearAxisServo> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA Local offset from the center of body A to its attachment point. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Local offset from the center of body B to its attachment point. public Vector3 LocalOffsetB Field Value Vector3 LocalPlaneNormal Direction of the plane normal in the local space of body A. public Vector3 LocalPlaneNormal Field Value Vector3 ServoSettings Servo control parameters. public ServoSettings ServoSettings Field Value ServoSettings SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings TargetOffset Target offset from A's plane anchor to B's anchor along the plane normal. public float TargetOffset Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out LinearAxisServo) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out LinearAxisServo description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description LinearAxisServo Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.LinearAxisServoFunctions.IJacobianModifier.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisServoFunctions.IJacobianModifier.html",
    "title": "Interface LinearAxisServoFunctions.IJacobianModifier | Bepu API",
    "keywords": "Interface LinearAxisServoFunctions.IJacobianModifier Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public interface LinearAxisServoFunctions.IJacobianModifier Methods Modify(in Vector3Wide, in Vector3Wide, ref Vector3Wide) void Modify(in Vector3Wide anchorA, in Vector3Wide anchorB, ref Vector3Wide normal) Parameters anchorA Vector3Wide anchorB Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.Constraints.LinearAxisServoFunctions.NoChangeModifier.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisServoFunctions.NoChangeModifier.html",
    "title": "Struct LinearAxisServoFunctions.NoChangeModifier | Bepu API",
    "keywords": "Struct LinearAxisServoFunctions.NoChangeModifier Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct LinearAxisServoFunctions.NoChangeModifier : LinearAxisServoFunctions.IJacobianModifier Implements LinearAxisServoFunctions.IJacobianModifier Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Methods Modify(in Vector3Wide, in Vector3Wide, ref Vector3Wide) public void Modify(in Vector3Wide anchorA, in Vector3Wide anchorB, ref Vector3Wide normal) Parameters anchorA Vector3Wide anchorB Vector3Wide normal Vector3Wide"
  },
  "api/BepuPhysics.Constraints.LinearAxisServoFunctions.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisServoFunctions.html",
    "title": "Struct LinearAxisServoFunctions | Bepu API",
    "keywords": "Struct LinearAxisServoFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct LinearAxisServoFunctions : ITwoBodyConstraintFunctions<LinearAxisServoPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<LinearAxisServoPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(ref BodyVelocityWide, ref BodyVelocityWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector3Wide, ref Vector<float>) public static void ApplyImpulse(ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB, in Vector3Wide linearImpulseToVelocityA, in Vector3Wide angularImpulseToVelocityA, in Vector3Wide negatedLinearImpulseToVelocityB, in Vector3Wide angularImpulseToVelocityB, ref Vector<float> csi) Parameters velocityA BodyVelocityWide velocityB BodyVelocityWide linearImpulseToVelocityA Vector3Wide angularImpulseToVelocityA Vector3Wide negatedLinearImpulseToVelocityB Vector3Wide angularImpulseToVelocityB Vector3Wide csi Vector<float> ApplyImpulse(in Vector3Wide, in Vector3Wide, in Vector3Wide, in BodyInertiaWide, in BodyInertiaWide, in Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void ApplyImpulse(in Vector3Wide linearJA, in Vector3Wide angularImpulseToVelocityA, in Vector3Wide angularImpulseToVelocityB, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector<float> csi, ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB) Parameters linearJA Vector3Wide angularImpulseToVelocityA Vector3Wide angularImpulseToVelocityB Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide csi Vector<float> velocityA BodyVelocityWide velocityB BodyVelocityWide ComputeCorrectiveImpulse(ref BodyVelocityWide, ref BodyVelocityWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector<float>, in Vector<float>, in Vector<float>, out Vector<float>) public static void ComputeCorrectiveImpulse(ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB, in Vector3Wide linearVelocityToImpulseA, in Vector3Wide angularVelocityToImpulseA, in Vector3Wide angularVelocityToImpulseB, in Vector<float> biasImpulse, in Vector<float> softnessImpulseScale, in Vector<float> accumulatedImpulse, out Vector<float> csi) Parameters velocityA BodyVelocityWide velocityB BodyVelocityWide linearVelocityToImpulseA Vector3Wide angularVelocityToImpulseA Vector3Wide angularVelocityToImpulseB Vector3Wide biasImpulse Vector<float> softnessImpulseScale Vector<float> accumulatedImpulse Vector<float> csi Vector<float> ComputeEffectiveMass(in Vector3Wide, in Vector3Wide, in BodyInertiaWide, in BodyInertiaWide, in Vector<float>, out Vector3Wide, out Vector3Wide, out Vector<float>) public static void ComputeEffectiveMass(in Vector3Wide angularJA, in Vector3Wide angularJB, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, in Vector<float> effectiveMassCFMScale, out Vector3Wide angularImpulseToVelocityA, out Vector3Wide angularImpulseToVelocityB, out Vector<float> effectiveMass) Parameters angularJA Vector3Wide angularJB Vector3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide effectiveMassCFMScale Vector<float> angularImpulseToVelocityA Vector3Wide angularImpulseToVelocityB Vector3Wide effectiveMass Vector<float> ComputeJacobians(in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, out Vector<float>, out Vector3Wide, out Vector3Wide, out Vector3Wide) public static void ComputeJacobians(in Vector3Wide ab, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector3Wide localPlaneNormalA, in Vector3Wide localOffsetA, in Vector3Wide localOffsetB, out Vector<float> planeNormalDot, out Vector3Wide normal, out Vector3Wide angularJA, out Vector3Wide angularJB) Parameters ab Vector3Wide orientationA QuaternionWide orientationB QuaternionWide localPlaneNormalA Vector3Wide localOffsetA Vector3Wide localOffsetB Vector3Wide planeNormalDot Vector<float> normal Vector3Wide angularJA Vector3Wide angularJB Vector3Wide ComputeTransforms<TJacobianModifier>(ref TJacobianModifier, in Vector3Wide, in Vector3Wide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector<float>, out Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector<float>, out Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector3Wide) public static void ComputeTransforms<TJacobianModifier>(ref TJacobianModifier jacobianModifier, in Vector3Wide localOffsetA, in Vector3Wide localOffsetB, in Vector3Wide localPlaneNormal, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide ab, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, in Vector<float> effectiveMassCFMScale, out Vector3Wide anchorA, out Vector3Wide anchorB, out Vector3Wide normal, out Vector<float> effectiveMass, out Vector3Wide linearVelocityToImpulseA, out Vector3Wide angularVelocityToImpulseA, out Vector3Wide angularVelocityToImpulseB, out Vector3Wide linearImpulseToVelocityA, out Vector3Wide angularImpulseToVelocityA, out Vector3Wide negatedLinearImpulseToVelocityB, out Vector3Wide angularImpulseToVelocityB) where TJacobianModifier : LinearAxisServoFunctions.IJacobianModifier Parameters jacobianModifier TJacobianModifier localOffsetA Vector3Wide localOffsetB Vector3Wide localPlaneNormal Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide ab Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide effectiveMassCFMScale Vector<float> anchorA Vector3Wide anchorB Vector3Wide normal Vector3Wide effectiveMass Vector<float> linearVelocityToImpulseA Vector3Wide angularVelocityToImpulseA Vector3Wide angularVelocityToImpulseB Vector3Wide linearImpulseToVelocityA Vector3Wide angularImpulseToVelocityA Vector3Wide negatedLinearImpulseToVelocityB Vector3Wide angularImpulseToVelocityB Vector3Wide Type Parameters TJacobianModifier IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref LinearAxisServoPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref LinearAxisServoPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData LinearAxisServoPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref LinearAxisServoPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref LinearAxisServoPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep LinearAxisServoPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref LinearAxisServoPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref LinearAxisServoPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep LinearAxisServoPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.LinearAxisServoPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisServoPrestepData.html",
    "title": "Struct LinearAxisServoPrestepData | Bepu API",
    "keywords": "Struct LinearAxisServoPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct LinearAxisServoPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide LocalPlaneNormal public Vector3Wide LocalPlaneNormal Field Value Vector3Wide ServoSettings public ServoSettingsWide ServoSettings Field Value ServoSettingsWide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide TargetOffset public Vector<float> TargetOffset Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.LinearAxisServoTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.LinearAxisServoTypeProcessor.html",
    "title": "Class LinearAxisServoTypeProcessor | Bepu API",
    "keywords": "Class LinearAxisServoTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class LinearAxisServoTypeProcessor : TwoBodyTypeProcessor<LinearAxisServoPrestepData, Vector<float>, LinearAxisServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>> TwoBodyTypeProcessor<LinearAxisServoPrestepData, Vector<float>, LinearAxisServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll> LinearAxisServoTypeProcessor Inherited Members TwoBodyTypeProcessor<LinearAxisServoPrestepData, Vector<float>, LinearAxisServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<LinearAxisServoPrestepData, Vector<float>, LinearAxisServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<LinearAxisServoPrestepData, Vector<float>, LinearAxisServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<LinearAxisServoPrestepData, Vector<float>, LinearAxisServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<LinearAxisServoPrestepData, Vector<float>, LinearAxisServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref LinearAxisServoPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref LinearAxisServoPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, LinearAxisServoPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 38 Field Value int"
  },
  "api/BepuPhysics.Constraints.MotorSettings.html": {
    "href": "api/BepuPhysics.Constraints.MotorSettings.html",
    "title": "Struct MotorSettings | Bepu API",
    "keywords": "Struct MotorSettings Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Defines some of the shared behavior across motor constraints. public struct MotorSettings Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors MotorSettings(float, float) Defines settings for a motor constraint. public MotorSettings(float maximumForce, float softness) Parameters maximumForce float Maximum amount of force the motor can apply in one unit of time. softness float Gets or sets how soft the constraint is. Values range from 0 to infinity. Softness is inverse damping; 0 is perfectly rigid, 1 is very soft, float.MaxValue is effectively nonexistent. Fields Damping Mass-scaled damping constant. If you want to simulate a viscous damping coefficient of D with an object of mass M, set this damping value to D / M. public float Damping Field Value float MaximumForce Maximum amount of force the motor can apply in one unit of time. public float MaximumForce Field Value float Properties Softness Gets or sets how soft the constraint is. Values range from 0 to infinity. Softness is inverse damping; 0 is perfectly rigid, 1 is very soft, float.MaxValue is effectively nonexistent. public float Softness { get; set; } Property Value float Methods Validate(in MotorSettings) Checks if a settings instance has valid nonnegative values. public static bool Validate(in MotorSettings settings) Parameters settings MotorSettings Instance to examine. Returns bool True if the settings are valid, false otherwise."
  },
  "api/BepuPhysics.Constraints.MotorSettingsWide.html": {
    "href": "api/BepuPhysics.Constraints.MotorSettingsWide.html",
    "title": "Struct MotorSettingsWide | Bepu API",
    "keywords": "Struct MotorSettingsWide Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct MotorSettingsWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Damping public Vector<float> Damping Field Value Vector<float> MaximumForce public Vector<float> MaximumForce Field Value Vector<float> Methods ComputeSoftness(in MotorSettingsWide, float, out Vector<float>, out Vector<float>, out Vector<float>) public static void ComputeSoftness(in MotorSettingsWide settings, float dt, out Vector<float> effectiveMassCFMScale, out Vector<float> softnessImpulseScale, out Vector<float> maximumImpulse) Parameters settings MotorSettingsWide dt float effectiveMassCFMScale Vector<float> softnessImpulseScale Vector<float> maximumImpulse Vector<float> ReadFirst(in MotorSettingsWide, out MotorSettings) public static void ReadFirst(in MotorSettingsWide source, out MotorSettings target) Parameters source MotorSettingsWide target MotorSettings WriteFirst(in MotorSettings, ref MotorSettingsWide) public static void WriteFirst(in MotorSettings source, ref MotorSettingsWide target) Parameters source MotorSettings target MotorSettingsWide"
  },
  "api/BepuPhysics.Constraints.OneBodyAngularMotor.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyAngularMotor.html",
    "title": "Struct OneBodyAngularMotor | Bepu API",
    "keywords": "Struct OneBodyAngularMotor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains the angular velocity of one body to the target. public struct OneBodyAngularMotor : IOneBodyConstraintDescription<OneBodyAngularMotor>, IConstraintDescription<OneBodyAngularMotor> Implements IOneBodyConstraintDescription<OneBodyAngularMotor> IConstraintDescription<OneBodyAngularMotor> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Settings Motor control parameters. public MotorSettings Settings Field Value MotorSettings TargetVelocity Target angular velocity. public Vector3 TargetVelocity Field Value Vector3 Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out OneBodyAngularMotor) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out OneBodyAngularMotor description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description OneBodyAngularMotor Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.OneBodyAngularMotorFunctions.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyAngularMotorFunctions.html",
    "title": "Struct OneBodyAngularMotorFunctions | Bepu API",
    "keywords": "Struct OneBodyAngularMotorFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct OneBodyAngularMotorFunctions : IOneBodyConstraintFunctions<OneBodyAngularMotorPrestepData, Vector3Wide> Implements IOneBodyConstraintFunctions<OneBodyAngularMotorPrestepData, Vector3Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(ref Vector3Wide, in Symmetric3x3Wide, in Vector3Wide) public static void ApplyImpulse(ref Vector3Wide angularVelocity, in Symmetric3x3Wide impulseToVelocity, in Vector3Wide csi) Parameters angularVelocity Vector3Wide impulseToVelocity Symmetric3x3Wide csi Vector3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref OneBodyAngularMotorPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, ref OneBodyAngularMotorPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide prestepData OneBodyAngularMotorPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref OneBodyAngularMotorPrestepData, ref Vector3Wide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref OneBodyAngularMotorPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep OneBodyAngularMotorPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref OneBodyAngularMotorPrestepData, ref Vector3Wide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref OneBodyAngularMotorPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep OneBodyAngularMotorPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.OneBodyAngularMotorPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyAngularMotorPrestepData.html",
    "title": "Struct OneBodyAngularMotorPrestepData | Bepu API",
    "keywords": "Struct OneBodyAngularMotorPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct OneBodyAngularMotorPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Settings public MotorSettingsWide Settings Field Value MotorSettingsWide TargetVelocity public Vector3Wide TargetVelocity Field Value Vector3Wide"
  },
  "api/BepuPhysics.Constraints.OneBodyAngularMotorTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyAngularMotorTypeProcessor.html",
    "title": "Class OneBodyAngularMotorTypeProcessor | Bepu API",
    "keywords": "Class OneBodyAngularMotorTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class OneBodyAngularMotorTypeProcessor : OneBodyTypeProcessor<OneBodyAngularMotorPrestepData, Vector3Wide, OneBodyAngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide> OneBodyTypeProcessor<OneBodyAngularMotorPrestepData, Vector3Wide, OneBodyAngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngular> OneBodyAngularMotorTypeProcessor Inherited Members OneBodyTypeProcessor<OneBodyAngularMotorPrestepData, Vector3Wide, OneBodyAngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngular>.InternalBodiesPerConstraint OneBodyTypeProcessor<OneBodyAngularMotorPrestepData, Vector3Wide, OneBodyAngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<OneBodyAngularMotorPrestepData, Vector3Wide, OneBodyAngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<OneBodyAngularMotorPrestepData, Vector3Wide, OneBodyAngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<OneBodyAngularMotorPrestepData, Vector3Wide, OneBodyAngularMotorFunctions, AccessOnlyAngularWithoutPose, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.Move(ref Vector<int>, ref OneBodyAngularMotorPrestepData, ref Vector3Wide, ConstraintHandle, int, ref Vector<int>, ref OneBodyAngularMotorPrestepData, ref Vector3Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, OneBodyAngularMotorPrestepData, Vector3Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 43 Field Value int"
  },
  "api/BepuPhysics.Constraints.OneBodyAngularServo.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyAngularServo.html",
    "title": "Struct OneBodyAngularServo | Bepu API",
    "keywords": "Struct OneBodyAngularServo Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains a single body to a target orientation. public struct OneBodyAngularServo : IOneBodyConstraintDescription<OneBodyAngularServo>, IConstraintDescription<OneBodyAngularServo> Implements IOneBodyConstraintDescription<OneBodyAngularServo> IConstraintDescription<OneBodyAngularServo> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ServoSettings Servo control parameters. public ServoSettings ServoSettings Field Value ServoSettings SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings TargetOrientation Target orientation of the constraint. public Quaternion TargetOrientation Field Value Quaternion Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out OneBodyAngularServo) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out OneBodyAngularServo description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description OneBodyAngularServo Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.OneBodyAngularServoFunctions.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyAngularServoFunctions.html",
    "title": "Struct OneBodyAngularServoFunctions | Bepu API",
    "keywords": "Struct OneBodyAngularServoFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct OneBodyAngularServoFunctions : IOneBodyConstraintFunctions<OneBodyAngularServoPrestepData, Vector3Wide> Implements IOneBodyConstraintFunctions<OneBodyAngularServoPrestepData, Vector3Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(in Symmetric3x3Wide, in Vector3Wide, ref Vector3Wide) public static void ApplyImpulse(in Symmetric3x3Wide inverseInertia, in Vector3Wide csi, ref Vector3Wide angularVelocity) Parameters inverseInertia Symmetric3x3Wide csi Vector3Wide angularVelocity Vector3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref OneBodyAngularServoPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, ref OneBodyAngularServoPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide prestepData OneBodyAngularServoPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref OneBodyAngularServoPrestepData, ref Vector3Wide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref OneBodyAngularServoPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep OneBodyAngularServoPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref OneBodyAngularServoPrestepData, ref Vector3Wide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref OneBodyAngularServoPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep OneBodyAngularServoPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.OneBodyAngularServoPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyAngularServoPrestepData.html",
    "title": "Struct OneBodyAngularServoPrestepData | Bepu API",
    "keywords": "Struct OneBodyAngularServoPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct OneBodyAngularServoPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ServoSettings public ServoSettingsWide ServoSettings Field Value ServoSettingsWide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide TargetOrientation public QuaternionWide TargetOrientation Field Value QuaternionWide"
  },
  "api/BepuPhysics.Constraints.OneBodyAngularServoTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyAngularServoTypeProcessor.html",
    "title": "Class OneBodyAngularServoTypeProcessor | Bepu API",
    "keywords": "Class OneBodyAngularServoTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class OneBodyAngularServoTypeProcessor : OneBodyTypeProcessor<OneBodyAngularServoPrestepData, Vector3Wide, OneBodyAngularServoFunctions, AccessOnlyAngular, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide> OneBodyTypeProcessor<OneBodyAngularServoPrestepData, Vector3Wide, OneBodyAngularServoFunctions, AccessOnlyAngular, AccessOnlyAngular> OneBodyAngularServoTypeProcessor Inherited Members OneBodyTypeProcessor<OneBodyAngularServoPrestepData, Vector3Wide, OneBodyAngularServoFunctions, AccessOnlyAngular, AccessOnlyAngular>.InternalBodiesPerConstraint OneBodyTypeProcessor<OneBodyAngularServoPrestepData, Vector3Wide, OneBodyAngularServoFunctions, AccessOnlyAngular, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<OneBodyAngularServoPrestepData, Vector3Wide, OneBodyAngularServoFunctions, AccessOnlyAngular, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<OneBodyAngularServoPrestepData, Vector3Wide, OneBodyAngularServoFunctions, AccessOnlyAngular, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<OneBodyAngularServoPrestepData, Vector3Wide, OneBodyAngularServoFunctions, AccessOnlyAngular, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.Move(ref Vector<int>, ref OneBodyAngularServoPrestepData, ref Vector3Wide, ConstraintHandle, int, ref Vector<int>, ref OneBodyAngularServoPrestepData, ref Vector3Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, OneBodyAngularServoPrestepData, Vector3Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 42 Field Value int"
  },
  "api/BepuPhysics.Constraints.OneBodyContactTypeProcessor-3.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyContactTypeProcessor-3.html",
    "title": "Class OneBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> | Bepu API",
    "keywords": "Class OneBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public abstract class OneBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> : OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose> where TPrestepData : unmanaged where TAccumulatedImpulse : unmanaged where TConstraintFunctions : unmanaged, IOneBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Type Parameters TPrestepData TAccumulatedImpulse TConstraintFunctions Inheritance object TypeProcessor TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse> OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose> OneBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> Derived Contact1OneBodyTypeProcessor Contact2NonconvexOneBodyTypeProcessor Contact2OneBodyTypeProcessor Contact3NonconvexOneBodyTypeProcessor Contact3OneBodyTypeProcessor Contact4NonconvexOneBodyTypeProcessor Contact4OneBodyTypeProcessor Inherited Members OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Move(ref Vector<int>, ref TPrestepData, ref TAccumulatedImpulse, ConstraintHandle, int, ref Vector<int>, ref TPrestepData, ref TAccumulatedImpulse, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/BepuPhysics.Constraints.OneBodyLinearMotor.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyLinearMotor.html",
    "title": "Struct OneBodyLinearMotor | Bepu API",
    "keywords": "Struct OneBodyLinearMotor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains a point on a body to have a target linear velocity. public struct OneBodyLinearMotor : IOneBodyConstraintDescription<OneBodyLinearMotor>, IConstraintDescription<OneBodyLinearMotor> Implements IOneBodyConstraintDescription<OneBodyLinearMotor> IConstraintDescription<OneBodyLinearMotor> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffset Offset to the attachment point in the local space of the body. public Vector3 LocalOffset Field Value Vector3 Settings Motor control parameters. public MotorSettings Settings Field Value MotorSettings TargetVelocity Target velocity of the attachment point. public Vector3 TargetVelocity Field Value Vector3 Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out OneBodyLinearMotor) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out OneBodyLinearMotor description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description OneBodyLinearMotor Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.OneBodyLinearMotorFunctions.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyLinearMotorFunctions.html",
    "title": "Struct OneBodyLinearMotorFunctions | Bepu API",
    "keywords": "Struct OneBodyLinearMotorFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct OneBodyLinearMotorFunctions : IOneBodyConstraintFunctions<OneBodyLinearMotorPrestepData, Vector3Wide> Implements IOneBodyConstraintFunctions<OneBodyLinearMotorPrestepData, Vector3Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref OneBodyLinearMotorPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, ref OneBodyLinearMotorPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide prestepData OneBodyLinearMotorPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref OneBodyLinearMotorPrestepData, ref Vector3Wide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref OneBodyLinearMotorPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep OneBodyLinearMotorPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref OneBodyLinearMotorPrestepData, ref Vector3Wide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref OneBodyLinearMotorPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep OneBodyLinearMotorPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.OneBodyLinearMotorPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyLinearMotorPrestepData.html",
    "title": "Struct OneBodyLinearMotorPrestepData | Bepu API",
    "keywords": "Struct OneBodyLinearMotorPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct OneBodyLinearMotorPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffset public Vector3Wide LocalOffset Field Value Vector3Wide Settings public MotorSettingsWide Settings Field Value MotorSettingsWide TargetVelocity public Vector3Wide TargetVelocity Field Value Vector3Wide"
  },
  "api/BepuPhysics.Constraints.OneBodyLinearMotorTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyLinearMotorTypeProcessor.html",
    "title": "Class OneBodyLinearMotorTypeProcessor | Bepu API",
    "keywords": "Class OneBodyLinearMotorTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class OneBodyLinearMotorTypeProcessor : OneBodyTypeProcessor<OneBodyLinearMotorPrestepData, Vector3Wide, OneBodyLinearMotorFunctions, AccessNoPosition, AccessNoPosition> Inheritance object TypeProcessor TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide> OneBodyTypeProcessor<OneBodyLinearMotorPrestepData, Vector3Wide, OneBodyLinearMotorFunctions, AccessNoPosition, AccessNoPosition> OneBodyLinearMotorTypeProcessor Inherited Members OneBodyTypeProcessor<OneBodyLinearMotorPrestepData, Vector3Wide, OneBodyLinearMotorFunctions, AccessNoPosition, AccessNoPosition>.InternalBodiesPerConstraint OneBodyTypeProcessor<OneBodyLinearMotorPrestepData, Vector3Wide, OneBodyLinearMotorFunctions, AccessNoPosition, AccessNoPosition>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<OneBodyLinearMotorPrestepData, Vector3Wide, OneBodyLinearMotorFunctions, AccessNoPosition, AccessNoPosition>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<OneBodyLinearMotorPrestepData, Vector3Wide, OneBodyLinearMotorFunctions, AccessNoPosition, AccessNoPosition>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<OneBodyLinearMotorPrestepData, Vector3Wide, OneBodyLinearMotorFunctions, AccessNoPosition, AccessNoPosition>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.Move(ref Vector<int>, ref OneBodyLinearMotorPrestepData, ref Vector3Wide, ConstraintHandle, int, ref Vector<int>, ref OneBodyLinearMotorPrestepData, ref Vector3Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, OneBodyLinearMotorPrestepData, Vector3Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 45 Field Value int"
  },
  "api/BepuPhysics.Constraints.OneBodyLinearServo.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyLinearServo.html",
    "title": "Struct OneBodyLinearServo | Bepu API",
    "keywords": "Struct OneBodyLinearServo Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains a point on a body to a target location. public struct OneBodyLinearServo : IOneBodyConstraintDescription<OneBodyLinearServo>, IConstraintDescription<OneBodyLinearServo> Implements IOneBodyConstraintDescription<OneBodyLinearServo> IConstraintDescription<OneBodyLinearServo> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffset Offset to the attachment point in the local space of the body. public Vector3 LocalOffset Field Value Vector3 ServoSettings Servo control parameters. public ServoSettings ServoSettings Field Value ServoSettings SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Target Target position. public Vector3 Target Field Value Vector3 Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out OneBodyLinearServo) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out OneBodyLinearServo description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description OneBodyLinearServo Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.OneBodyLinearServoFunctions.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyLinearServoFunctions.html",
    "title": "Struct OneBodyLinearServoFunctions | Bepu API",
    "keywords": "Struct OneBodyLinearServoFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct OneBodyLinearServoFunctions : IOneBodyConstraintFunctions<OneBodyLinearServoPrestepData, Vector3Wide> Implements IOneBodyConstraintFunctions<OneBodyLinearServoPrestepData, Vector3Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(in Vector3Wide, in BodyInertiaWide, ref BodyVelocityWide, in Vector3Wide) public static void ApplyImpulse(in Vector3Wide offset, in BodyInertiaWide inertia, ref BodyVelocityWide velocityA, in Vector3Wide csi) Parameters offset Vector3Wide inertia BodyInertiaWide velocityA BodyVelocityWide csi Vector3Wide ComputeTransforms(in Vector3Wide, in QuaternionWide, in Vector<float>, in BodyInertiaWide, out Vector3Wide, out Symmetric3x3Wide) public static void ComputeTransforms(in Vector3Wide localOffset, in QuaternionWide orientation, in Vector<float> effectiveMassCFMScale, in BodyInertiaWide inertia, out Vector3Wide offset, out Symmetric3x3Wide effectiveMass) Parameters localOffset Vector3Wide orientation QuaternionWide effectiveMassCFMScale Vector<float> inertia BodyInertiaWide offset Vector3Wide effectiveMass Symmetric3x3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, ref OneBodyLinearServoPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, ref OneBodyLinearServoPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide prestepData OneBodyLinearServoPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref OneBodyLinearServoPrestepData, ref Vector3Wide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, float dt, float inverseDt, ref OneBodyLinearServoPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide dt float inverseDt float prestep OneBodyLinearServoPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref OneBodyLinearServoPrestepData, ref Vector3Wide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, ref OneBodyLinearServoPrestepData prestep, ref Vector3Wide accumulatedImpulses, ref BodyVelocityWide wsvA) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide prestep OneBodyLinearServoPrestepData accumulatedImpulses Vector3Wide wsvA BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.OneBodyLinearServoPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyLinearServoPrestepData.html",
    "title": "Struct OneBodyLinearServoPrestepData | Bepu API",
    "keywords": "Struct OneBodyLinearServoPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct OneBodyLinearServoPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffset public Vector3Wide LocalOffset Field Value Vector3Wide ServoSettings public ServoSettingsWide ServoSettings Field Value ServoSettingsWide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide Target public Vector3Wide Target Field Value Vector3Wide"
  },
  "api/BepuPhysics.Constraints.OneBodyLinearServoTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyLinearServoTypeProcessor.html",
    "title": "Class OneBodyLinearServoTypeProcessor | Bepu API",
    "keywords": "Class OneBodyLinearServoTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class OneBodyLinearServoTypeProcessor : OneBodyTypeProcessor<OneBodyLinearServoPrestepData, Vector3Wide, OneBodyLinearServoFunctions, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide> OneBodyTypeProcessor<OneBodyLinearServoPrestepData, Vector3Wide, OneBodyLinearServoFunctions, AccessAll, AccessAll> OneBodyLinearServoTypeProcessor Inherited Members OneBodyTypeProcessor<OneBodyLinearServoPrestepData, Vector3Wide, OneBodyLinearServoFunctions, AccessAll, AccessAll>.InternalBodiesPerConstraint OneBodyTypeProcessor<OneBodyLinearServoPrestepData, Vector3Wide, OneBodyLinearServoFunctions, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) OneBodyTypeProcessor<OneBodyLinearServoPrestepData, Vector3Wide, OneBodyLinearServoFunctions, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) OneBodyTypeProcessor<OneBodyLinearServoPrestepData, Vector3Wide, OneBodyLinearServoFunctions, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates OneBodyTypeProcessor<OneBodyLinearServoPrestepData, Vector3Wide, OneBodyLinearServoFunctions, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.Move(ref Vector<int>, ref OneBodyLinearServoPrestepData, ref Vector3Wide, ConstraintHandle, int, ref Vector<int>, ref OneBodyLinearServoPrestepData, ref Vector3Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, OneBodyLinearServoPrestepData, Vector3Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 44 Field Value int"
  },
  "api/BepuPhysics.Constraints.OneBodyTypeProcessor-5.html": {
    "href": "api/BepuPhysics.Constraints.OneBodyTypeProcessor-5.html",
    "title": "Class OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TSolveAccessFilterA> | Bepu API",
    "keywords": "Class OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TSolveAccessFilterA> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Shared implementation across all one body constraints. public abstract class OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TSolveAccessFilterA> : TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse> where TPrestepData : unmanaged where TAccumulatedImpulse : unmanaged where TConstraintFunctions : unmanaged, IOneBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> where TWarmStartAccessFilterA : unmanaged, IBodyAccessFilter where TSolveAccessFilterA : unmanaged, IBodyAccessFilter Type Parameters TPrestepData TAccumulatedImpulse TConstraintFunctions TWarmStartAccessFilterA TSolveAccessFilterA Inheritance object TypeProcessor TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse> OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TSolveAccessFilterA> Derived OneBodyAngularMotorTypeProcessor OneBodyAngularServoTypeProcessor OneBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> OneBodyLinearMotorTypeProcessor OneBodyLinearServoTypeProcessor Inherited Members TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.InternalConstrainedDegreesOfFreedom TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.SetBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.AddBodyReferencesLane(ref Vector<int>, int, Span<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.RemoveBodyReferencesLane(ref Vector<int>, int) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Move(ref Vector<int>, ref TPrestepData, ref TAccumulatedImpulse, ConstraintHandle, int, ref Vector<int>, ref TPrestepData, ref TAccumulatedImpulse, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<Vector<int>, TPrestepData, TAccumulatedImpulse>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties InternalBodiesPerConstraint protected override sealed int InternalBodiesPerConstraint { get; } Property Value int RequiresIncrementalSubstepUpdates Gets whether this type requires incremental updates for each substep in a frame beyond the first. public override bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) public override void IncrementallyUpdateForSubstep(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int exclusiveEndBundle) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int exclusiveEndBundle int Solve(ref TypeBatch, Bodies, float, float, int, int) public override void Solve(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int exclusiveEndBundle) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int exclusiveEndBundle int WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) public override void WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch typeBatch, ref Buffer<IndexSet> integrationFlags, Bodies bodies, ref TIntegratorCallbacks integratorCallbacks, float dt, float inverseDt, int startBundle, int exclusiveEndBundle, int workerIndex) where TIntegratorCallbacks : struct, IPoseIntegratorCallbacks where TBatchIntegrationMode : unmanaged, IBatchIntegrationMode where TAllowPoseIntegration : unmanaged, IBatchPoseIntegrationAllowed Parameters typeBatch TypeBatch integrationFlags Buffer<IndexSet> bodies Bodies integratorCallbacks TIntegratorCallbacks dt float inverseDt float startBundle int exclusiveEndBundle int workerIndex int Type Parameters TIntegratorCallbacks TBatchIntegrationMode TAllowPoseIntegration"
  },
  "api/BepuPhysics.Constraints.PointOnLineServo.html": {
    "href": "api/BepuPhysics.Constraints.PointOnLineServo.html",
    "title": "Struct PointOnLineServo | Bepu API",
    "keywords": "Struct PointOnLineServo Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains a point on body B to be on a line attached to body A. public struct PointOnLineServo : ITwoBodyConstraintDescription<PointOnLineServo>, IConstraintDescription<PointOnLineServo> Implements ITwoBodyConstraintDescription<PointOnLineServo> IConstraintDescription<PointOnLineServo> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalDirection Direction of the line in the local space of body A. public Vector3 LocalDirection Field Value Vector3 LocalOffsetA Local offset from the center of body A to its attachment point. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Local offset from the center of body B to its attachment point. public Vector3 LocalOffsetB Field Value Vector3 ServoSettings Servo control parameters. public ServoSettings ServoSettings Field Value ServoSettings SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out PointOnLineServo) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out PointOnLineServo description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description PointOnLineServo Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.PointOnLineServoFunctions.html": {
    "href": "api/BepuPhysics.Constraints.PointOnLineServoFunctions.html",
    "title": "Struct PointOnLineServoFunctions | Bepu API",
    "keywords": "Struct PointOnLineServoFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct PointOnLineServoFunctions : ITwoBodyConstraintFunctions<PointOnLineServoPrestepData, Vector2Wide> Implements ITwoBodyConstraintFunctions<PointOnLineServoPrestepData, Vector2Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(ref BodyVelocityWide, ref BodyVelocityWide, in Matrix2x3Wide, in Matrix2x3Wide, in Matrix2x3Wide, in BodyInertiaWide, in BodyInertiaWide, ref Vector2Wide) public static void ApplyImpulse(ref BodyVelocityWide velocityA, ref BodyVelocityWide velocityB, in Matrix2x3Wide linearJacobian, in Matrix2x3Wide angularJacobianA, in Matrix2x3Wide angularJacobianB, in BodyInertiaWide inertiaA, in BodyInertiaWide inertiaB, ref Vector2Wide csi) Parameters velocityA BodyVelocityWide velocityB BodyVelocityWide linearJacobian Matrix2x3Wide angularJacobianA Matrix2x3Wide angularJacobianB Matrix2x3Wide inertiaA BodyInertiaWide inertiaB BodyInertiaWide csi Vector2Wide ComputeJacobians(in Vector3Wide, in QuaternionWide, in QuaternionWide, in Vector3Wide, in Vector3Wide, in Vector3Wide, out Vector3Wide, out Matrix2x3Wide, out Matrix2x3Wide, out Matrix2x3Wide) public static void ComputeJacobians(in Vector3Wide ab, in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector3Wide localDirection, in Vector3Wide localOffsetA, in Vector3Wide localOffsetB, out Vector3Wide anchorOffset, out Matrix2x3Wide linearJacobian, out Matrix2x3Wide angularJA, out Matrix2x3Wide angularJB) Parameters ab Vector3Wide orientationA QuaternionWide orientationB QuaternionWide localDirection Vector3Wide localOffsetA Vector3Wide localOffsetB Vector3Wide anchorOffset Vector3Wide linearJacobian Matrix2x3Wide angularJA Matrix2x3Wide angularJB Matrix2x3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref PointOnLineServoPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref PointOnLineServoPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData PointOnLineServoPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref PointOnLineServoPrestepData, ref Vector2Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref PointOnLineServoPrestepData prestep, ref Vector2Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep PointOnLineServoPrestepData accumulatedImpulses Vector2Wide wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref PointOnLineServoPrestepData, ref Vector2Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref PointOnLineServoPrestepData prestep, ref Vector2Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep PointOnLineServoPrestepData accumulatedImpulses Vector2Wide wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.PointOnLineServoPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.PointOnLineServoPrestepData.html",
    "title": "Struct PointOnLineServoPrestepData | Bepu API",
    "keywords": "Struct PointOnLineServoPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct PointOnLineServoPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalDirection public Vector3Wide LocalDirection Field Value Vector3Wide LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide ServoSettings public ServoSettingsWide ServoSettings Field Value ServoSettingsWide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.PointOnLineServoTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.PointOnLineServoTypeProcessor.html",
    "title": "Class PointOnLineServoTypeProcessor | Bepu API",
    "keywords": "Class PointOnLineServoTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class PointOnLineServoTypeProcessor : TwoBodyTypeProcessor<PointOnLineServoPrestepData, Vector2Wide, PointOnLineServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide> TwoBodyTypeProcessor<PointOnLineServoPrestepData, Vector2Wide, PointOnLineServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll> PointOnLineServoTypeProcessor Inherited Members TwoBodyTypeProcessor<PointOnLineServoPrestepData, Vector2Wide, PointOnLineServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<PointOnLineServoPrestepData, Vector2Wide, PointOnLineServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<PointOnLineServoPrestepData, Vector2Wide, PointOnLineServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<PointOnLineServoPrestepData, Vector2Wide, PointOnLineServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<PointOnLineServoPrestepData, Vector2Wide, PointOnLineServoFunctions, AccessAll, AccessAll, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.Move(ref TwoBodyReferences, ref PointOnLineServoPrestepData, ref Vector2Wide, ConstraintHandle, int, ref TwoBodyReferences, ref PointOnLineServoPrestepData, ref Vector2Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, PointOnLineServoPrestepData, Vector2Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 37 Field Value int"
  },
  "api/BepuPhysics.Constraints.ServoSettings.html": {
    "href": "api/BepuPhysics.Constraints.ServoSettings.html",
    "title": "Struct ServoSettings | Bepu API",
    "keywords": "Struct ServoSettings Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Describes how a quickly and strongly a servo constraint should move towards a position target. public struct ServoSettings Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The constraint will attempt to reach a speed between BaseSpeed and MaximumSpeed using a force no greater than MaximumForce. The speed that the constraint will attempt to use before clamping is based on its spring settings. Note that a 'position' target for the purposes of this type could also be an orientation target. For those constraints, speeds/forces are in terms of angular speed and torque. Constructors ServoSettings(float, float, float) Creates a new servo settings instance with the specified properties. public ServoSettings(float maximumSpeed, float baseSpeed, float maximumForce) Parameters maximumSpeed float Sets the MaximumSpeed property. baseSpeed float Sets the BaseSpeed property. maximumForce float Sets the MaximumForce property. Fields BaseSpeed Minimum speed that the constraint will try to use to move towards the target. If the speed implied by the spring configuration is higher than this, the servo will attempt to use the higher speed. Will be clamped by the MaximumSpeed. public float BaseSpeed Field Value float MaximumForce The maximum force that the constraint can apply to move towards the target. public float MaximumForce Field Value float Remarks This value is specified in terms of force: a change in momentum over time. It is approximated as a maximum impulse (an instantaneous change in momentum) on a per-substep basis. In other words, for a given velocity iteration, the constraint's impulse can be no larger than MaximumForce * dt where dt is the substep duration. MaximumSpeed Maximum speed that the constraint can try to use to move towards the target. public float MaximumSpeed Field Value float Properties Default Gets settings representing a servo with unlimited force, speed, and no base speed. A servo with these settings will behave like a conventional position-level constraint. public static ServoSettings Default { get; } Property Value ServoSettings Methods Validate(in ServoSettings) Checks servo settings to ensure valid values. public static bool Validate(in ServoSettings settings) Parameters settings ServoSettings Settings to check. Returns bool True if the settings contain valid values, false otherwise."
  },
  "api/BepuPhysics.Constraints.ServoSettingsWide.html": {
    "href": "api/BepuPhysics.Constraints.ServoSettingsWide.html",
    "title": "Struct ServoSettingsWide | Bepu API",
    "keywords": "Struct ServoSettingsWide Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct ServoSettingsWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields BaseSpeed public Vector<float> BaseSpeed Field Value Vector<float> MaximumForce public Vector<float> MaximumForce Field Value Vector<float> MaximumSpeed public Vector<float> MaximumSpeed Field Value Vector<float> Methods ClampImpulse(in Vector<float>, ref Vector2Wide, ref Vector2Wide) public static void ClampImpulse(in Vector<float> maximumImpulse, ref Vector2Wide accumulatedImpulse, ref Vector2Wide csi) Parameters maximumImpulse Vector<float> accumulatedImpulse Vector2Wide csi Vector2Wide ClampImpulse(in Vector<float>, ref Vector3Wide, ref Vector3Wide) public static void ClampImpulse(in Vector<float> maximumImpulse, ref Vector3Wide accumulatedImpulse, ref Vector3Wide csi) Parameters maximumImpulse Vector<float> accumulatedImpulse Vector3Wide csi Vector3Wide ClampImpulse(in Vector<float>, ref Vector<float>, ref Vector<float>) public static void ClampImpulse(in Vector<float> maximumImpulse, ref Vector<float> accumulatedImpulse, ref Vector<float> csi) Parameters maximumImpulse Vector<float> accumulatedImpulse Vector<float> csi Vector<float> ComputeClampedBiasVelocity(in Vector2Wide, in Vector<float>, in ServoSettingsWide, float, float, out Vector2Wide, out Vector<float>) public static void ComputeClampedBiasVelocity(in Vector2Wide error, in Vector<float> positionErrorToBiasVelocity, in ServoSettingsWide servoSettings, float dt, float inverseDt, out Vector2Wide clampedBiasVelocity, out Vector<float> maximumImpulse) Parameters error Vector2Wide positionErrorToBiasVelocity Vector<float> servoSettings ServoSettingsWide dt float inverseDt float clampedBiasVelocity Vector2Wide maximumImpulse Vector<float> ComputeClampedBiasVelocity(in Vector2Wide, in Vector<float>, in Vector<float>, in ServoSettingsWide, float, float, out Vector2Wide, out Vector<float>) public static void ComputeClampedBiasVelocity(in Vector2Wide errorAxis, in Vector<float> errorLength, in Vector<float> positionErrorToBiasVelocity, in ServoSettingsWide servoSettings, float dt, float inverseDt, out Vector2Wide clampedBiasVelocity, out Vector<float> maximumImpulse) Parameters errorAxis Vector2Wide errorLength Vector<float> positionErrorToBiasVelocity Vector<float> servoSettings ServoSettingsWide dt float inverseDt float clampedBiasVelocity Vector2Wide maximumImpulse Vector<float> ComputeClampedBiasVelocity(in Vector3Wide, in Vector<float>, in ServoSettingsWide, float, float, out Vector3Wide, out Vector<float>) public static void ComputeClampedBiasVelocity(in Vector3Wide error, in Vector<float> positionErrorToBiasVelocity, in ServoSettingsWide servoSettings, float dt, float inverseDt, out Vector3Wide clampedBiasVelocity, out Vector<float> maximumImpulse) Parameters error Vector3Wide positionErrorToBiasVelocity Vector<float> servoSettings ServoSettingsWide dt float inverseDt float clampedBiasVelocity Vector3Wide maximumImpulse Vector<float> ComputeClampedBiasVelocity(in Vector3Wide, in Vector<float>, in Vector<float>, in ServoSettingsWide, float, float, out Vector3Wide, out Vector<float>) public static void ComputeClampedBiasVelocity(in Vector3Wide errorAxis, in Vector<float> errorLength, in Vector<float> positionErrorToBiasVelocity, in ServoSettingsWide servoSettings, float dt, float inverseDt, out Vector3Wide clampedBiasVelocity, out Vector<float> maximumImpulse) Parameters errorAxis Vector3Wide errorLength Vector<float> positionErrorToBiasVelocity Vector<float> servoSettings ServoSettingsWide dt float inverseDt float clampedBiasVelocity Vector3Wide maximumImpulse Vector<float> ComputeClampedBiasVelocity(in Vector<float>, in Vector<float>, in ServoSettingsWide, float, float, out Vector<float>, out Vector<float>) public static void ComputeClampedBiasVelocity(in Vector<float> error, in Vector<float> positionErrorToVelocity, in ServoSettingsWide servoSettings, float dt, float inverseDt, out Vector<float> clampedBiasVelocity, out Vector<float> maximumImpulse) Parameters error Vector<float> positionErrorToVelocity Vector<float> servoSettings ServoSettingsWide dt float inverseDt float clampedBiasVelocity Vector<float> maximumImpulse Vector<float> ReadFirst(in ServoSettingsWide, out ServoSettings) public static void ReadFirst(in ServoSettingsWide source, out ServoSettings target) Parameters source ServoSettingsWide target ServoSettings WriteFirst(in ServoSettings, ref ServoSettingsWide) public static void WriteFirst(in ServoSettings source, ref ServoSettingsWide target) Parameters source ServoSettings target ServoSettingsWide"
  },
  "api/BepuPhysics.Constraints.SpringSettings.html": {
    "href": "api/BepuPhysics.Constraints.SpringSettings.html",
    "title": "Struct SpringSettings | Bepu API",
    "keywords": "Struct SpringSettings Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct SpringSettings Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors SpringSettings(float, float) Constructs a new spring settings instance. public SpringSettings(float frequency, float dampingRatio) Parameters frequency float Target number of undamped oscillations per unit of time. dampingRatio float Ratio of the spring's actual damping to its critical damping. 0 is undamped, 1 is critically damped, and higher values are overdamped. Fields AngularFrequency Target number of undamped oscillations per unit of time, scaled by 2 * PI. public float AngularFrequency Field Value float TwiceDampingRatio Twice the ratio of the spring's actual damping to its critical damping. public float TwiceDampingRatio Field Value float Properties DampingRatio Gets or sets the ratio of the spring's actual damping to its critical damping. 0 is undamped, 1 is critically damped, and higher values are overdamped. public float DampingRatio { get; set; } Property Value float Frequency Gets or sets the target number of undamped oscillations per unit of time. public float Frequency { get; set; } Property Value float Methods Validate(in SpringSettings) Checks if a spring settings instance contains valid values. public static bool Validate(in SpringSettings springSettings) Parameters springSettings SpringSettings Settings to check. Returns bool True if the spring settings are valid, false otherwise."
  },
  "api/BepuPhysics.Constraints.SpringSettingsWide.html": {
    "href": "api/BepuPhysics.Constraints.SpringSettingsWide.html",
    "title": "Struct SpringSettingsWide | Bepu API",
    "keywords": "Struct SpringSettingsWide Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct SpringSettingsWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AngularFrequency public Vector<float> AngularFrequency Field Value Vector<float> TwiceDampingRatio public Vector<float> TwiceDampingRatio Field Value Vector<float> Methods ComputeSpringiness(in SpringSettingsWide, float, out Vector<float>, out Vector<float>, out Vector<float>) Computes springiness values for a set of constraints. public static void ComputeSpringiness(in SpringSettingsWide settings, float dt, out Vector<float> positionErrorToVelocity, out Vector<float> effectiveMassCFMScale, out Vector<float> softnessImpulseScale) Parameters settings SpringSettingsWide Spring settings associated with the constraints. dt float Duration of the time step. positionErrorToVelocity Vector<float> The multiplier applied to error to get bias velocity. effectiveMassCFMScale Vector<float> Scaling factor to apply to the effective mass to get the softened effective mass. softnessImpulseScale Vector<float> Scaling factor to apply to the accumulated impulse during the solve to soften the target velocity. ReadFirst(in SpringSettingsWide, out SpringSettings) public static void ReadFirst(in SpringSettingsWide source, out SpringSettings target) Parameters source SpringSettingsWide target SpringSettings WriteFirst(in SpringSettings, ref SpringSettingsWide) public static void WriteFirst(in SpringSettings source, ref SpringSettingsWide target) Parameters source SpringSettings target SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.SwingLimit.html": {
    "href": "api/BepuPhysics.Constraints.SwingLimit.html",
    "title": "Struct SwingLimit | Bepu API",
    "keywords": "Struct SwingLimit Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Restricts axes attached to two bodies to fall within a maximum swing angle. public struct SwingLimit : ITwoBodyConstraintDescription<SwingLimit>, IConstraintDescription<SwingLimit> Implements ITwoBodyConstraintDescription<SwingLimit> IConstraintDescription<SwingLimit> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AxisLocalA Axis attached to body A in its local space. public Vector3 AxisLocalA Field Value Vector3 AxisLocalB Axis attached to body B in its local space. public Vector3 AxisLocalB Field Value Vector3 MinimumDot Minimum dot product between the world space A and B axes that the constraint attempts to maintain. public float MinimumDot Field Value float SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int MaximumSwingAngle Gets or sets the maximum swing angle that the constraint allows between world axis A and B. Based on the MinimumDot field. public float MaximumSwingAngle { readonly get; set; } Property Value float TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out SwingLimit) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out SwingLimit description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description SwingLimit Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.SwingLimitFunctions.html": {
    "href": "api/BepuPhysics.Constraints.SwingLimitFunctions.html",
    "title": "Struct SwingLimitFunctions | Bepu API",
    "keywords": "Struct SwingLimitFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct SwingLimitFunctions : ITwoBodyConstraintFunctions<SwingLimitPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<SwingLimitPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref SwingLimitPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref SwingLimitPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData SwingLimitPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref SwingLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref SwingLimitPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep SwingLimitPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref SwingLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref SwingLimitPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep SwingLimitPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.SwingLimitPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.SwingLimitPrestepData.html",
    "title": "Struct SwingLimitPrestepData | Bepu API",
    "keywords": "Struct SwingLimitPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct SwingLimitPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AxisLocalA public Vector3Wide AxisLocalA Field Value Vector3Wide AxisLocalB public Vector3Wide AxisLocalB Field Value Vector3Wide MinimumDot public Vector<float> MinimumDot Field Value Vector<float> SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.SwingLimitTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.SwingLimitTypeProcessor.html",
    "title": "Class SwingLimitTypeProcessor | Bepu API",
    "keywords": "Class SwingLimitTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class SwingLimitTypeProcessor : TwoBodyTypeProcessor<SwingLimitPrestepData, Vector<float>, SwingLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>> TwoBodyTypeProcessor<SwingLimitPrestepData, Vector<float>, SwingLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> SwingLimitTypeProcessor Inherited Members TwoBodyTypeProcessor<SwingLimitPrestepData, Vector<float>, SwingLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.InternalBodiesPerConstraint TwoBodyTypeProcessor<SwingLimitPrestepData, Vector<float>, SwingLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<SwingLimitPrestepData, Vector<float>, SwingLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<SwingLimitPrestepData, Vector<float>, SwingLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<SwingLimitPrestepData, Vector<float>, SwingLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref SwingLimitPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref SwingLimitPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, SwingLimitPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 25 Field Value int"
  },
  "api/BepuPhysics.Constraints.SwivelHinge.html": {
    "href": "api/BepuPhysics.Constraints.SwivelHinge.html",
    "title": "Struct SwivelHinge | Bepu API",
    "keywords": "Struct SwivelHinge Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains two bodies with a swivel hinge that allows rotation around two axes, like a laptop monitor hinge that allows flipping the screen. Equivalent to a BallSocket constraint and an AngularSwivelHinge constraint solved together. public struct SwivelHinge : ITwoBodyConstraintDescription<SwivelHinge>, IConstraintDescription<SwivelHinge> Implements ITwoBodyConstraintDescription<SwivelHinge> IConstraintDescription<SwivelHinge> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalHingeAxisB Hinge axis in the local space of body B. public Vector3 LocalHingeAxisB Field Value Vector3 LocalOffsetA Local offset from the center of body A to its attachment point. public Vector3 LocalOffsetA Field Value Vector3 LocalOffsetB Local offset from the center of body B to its attachment point. public Vector3 LocalOffsetB Field Value Vector3 LocalSwivelAxisA Swivel axis in the local space of body A. public Vector3 LocalSwivelAxisA Field Value Vector3 SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out SwivelHinge) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out SwivelHinge description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description SwivelHinge Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.SwivelHingeFunctions.html": {
    "href": "api/BepuPhysics.Constraints.SwivelHingeFunctions.html",
    "title": "Struct SwivelHingeFunctions | Bepu API",
    "keywords": "Struct SwivelHingeFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct SwivelHingeFunctions : ITwoBodyConstraintFunctions<SwivelHingePrestepData, Vector4Wide> Implements ITwoBodyConstraintFunctions<SwivelHingePrestepData, Vector4Wide> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref SwivelHingePrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref SwivelHingePrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData SwivelHingePrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref SwivelHingePrestepData, ref Vector4Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref SwivelHingePrestepData prestep, ref Vector4Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep SwivelHingePrestepData accumulatedImpulses Vector4Wide wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref SwivelHingePrestepData, ref Vector4Wide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref SwivelHingePrestepData prestep, ref Vector4Wide accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep SwivelHingePrestepData accumulatedImpulses Vector4Wide wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.SwivelHingePrestepData.html": {
    "href": "api/BepuPhysics.Constraints.SwivelHingePrestepData.html",
    "title": "Struct SwivelHingePrestepData | Bepu API",
    "keywords": "Struct SwivelHingePrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct SwivelHingePrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalHingeAxisB public Vector3Wide LocalHingeAxisB Field Value Vector3Wide LocalOffsetA public Vector3Wide LocalOffsetA Field Value Vector3Wide LocalOffsetB public Vector3Wide LocalOffsetB Field Value Vector3Wide LocalSwivelAxisA public Vector3Wide LocalSwivelAxisA Field Value Vector3Wide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.SwivelHingeTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.SwivelHingeTypeProcessor.html",
    "title": "Class SwivelHingeTypeProcessor | Bepu API",
    "keywords": "Class SwivelHingeTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class SwivelHingeTypeProcessor : TwoBodyTypeProcessor<SwivelHingePrestepData, Vector4Wide, SwivelHingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide> TwoBodyTypeProcessor<SwivelHingePrestepData, Vector4Wide, SwivelHingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll> SwivelHingeTypeProcessor Inherited Members TwoBodyTypeProcessor<SwivelHingePrestepData, Vector4Wide, SwivelHingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<SwivelHingePrestepData, Vector4Wide, SwivelHingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<SwivelHingePrestepData, Vector4Wide, SwivelHingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<SwivelHingePrestepData, Vector4Wide, SwivelHingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<SwivelHingePrestepData, Vector4Wide, SwivelHingeFunctions, AccessNoPosition, AccessNoPosition, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.Move(ref TwoBodyReferences, ref SwivelHingePrestepData, ref Vector4Wide, ConstraintHandle, int, ref TwoBodyReferences, ref SwivelHingePrestepData, ref Vector4Wide, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, SwivelHingePrestepData, Vector4Wide>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 46 Field Value int"
  },
  "api/BepuPhysics.Constraints.ThreeBodyReferences.html": {
    "href": "api/BepuPhysics.Constraints.ThreeBodyReferences.html",
    "title": "Struct ThreeBodyReferences | Bepu API",
    "keywords": "Struct ThreeBodyReferences Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve. public struct ThreeBodyReferences Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields IndexA public Vector<int> IndexA Field Value Vector<int> IndexB public Vector<int> IndexB Field Value Vector<int> IndexC public Vector<int> IndexC Field Value Vector<int>"
  },
  "api/BepuPhysics.Constraints.ThreeBodyTypeProcessor-9.html": {
    "href": "api/BepuPhysics.Constraints.ThreeBodyTypeProcessor-9.html",
    "title": "Class ThreeBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC> | Bepu API",
    "keywords": "Class ThreeBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Shared implementation across all three body constraints. public abstract class ThreeBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC> : TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse> where TPrestepData : unmanaged where TAccumulatedImpulse : unmanaged where TConstraintFunctions : unmanaged, IThreeBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> where TWarmStartAccessFilterA : unmanaged, IBodyAccessFilter where TWarmStartAccessFilterB : unmanaged, IBodyAccessFilter where TWarmStartAccessFilterC : unmanaged, IBodyAccessFilter where TSolveAccessFilterA : unmanaged, IBodyAccessFilter where TSolveAccessFilterB : unmanaged, IBodyAccessFilter where TSolveAccessFilterC : unmanaged, IBodyAccessFilter Type Parameters TPrestepData TAccumulatedImpulse TConstraintFunctions TWarmStartAccessFilterA TWarmStartAccessFilterB TWarmStartAccessFilterC TSolveAccessFilterA TSolveAccessFilterB TSolveAccessFilterC Inheritance object TypeProcessor TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse> ThreeBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC> Derived AreaConstraintTypeProcessor Inherited Members TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.InternalConstrainedDegreesOfFreedom TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.SetBodyReferencesLane(ref ThreeBodyReferences, int, Span<int>) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.AddBodyReferencesLane(ref ThreeBodyReferences, int, Span<int>) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.RemoveBodyReferencesLane(ref ThreeBodyReferences, int) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.Move(ref ThreeBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ConstraintHandle, int, ref ThreeBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<ThreeBodyReferences, TPrestepData, TAccumulatedImpulse>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties InternalBodiesPerConstraint protected override sealed int InternalBodiesPerConstraint { get; } Property Value int RequiresIncrementalSubstepUpdates Gets whether this type requires incremental updates for each substep in a frame beyond the first. public override bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) public override void IncrementallyUpdateForSubstep(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int exclusiveEndBundle) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int exclusiveEndBundle int Solve(ref TypeBatch, Bodies, float, float, int, int) public override void Solve(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int exclusiveEndBundle) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int exclusiveEndBundle int WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) public override void WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch typeBatch, ref Buffer<IndexSet> integrationFlags, Bodies bodies, ref TIntegratorCallbacks integratorCallbacks, float dt, float inverseDt, int startBundle, int exclusiveEndBundle, int workerIndex) where TIntegratorCallbacks : struct, IPoseIntegratorCallbacks where TBatchIntegrationMode : unmanaged, IBatchIntegrationMode where TAllowPoseIntegration : unmanaged, IBatchPoseIntegrationAllowed Parameters typeBatch TypeBatch integrationFlags Buffer<IndexSet> bodies Bodies integratorCallbacks TIntegratorCallbacks dt float inverseDt float startBundle int exclusiveEndBundle int workerIndex int Type Parameters TIntegratorCallbacks TBatchIntegrationMode TAllowPoseIntegration"
  },
  "api/BepuPhysics.Constraints.TwistLimit.html": {
    "href": "api/BepuPhysics.Constraints.TwistLimit.html",
    "title": "Struct TwistLimit | Bepu API",
    "keywords": "Struct TwistLimit Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains two bodies' rotations around attached twist axes to a range of permitted twist angles. public struct TwistLimit : ITwoBodyConstraintDescription<TwistLimit>, IConstraintDescription<TwistLimit> Implements ITwoBodyConstraintDescription<TwistLimit> IConstraintDescription<TwistLimit> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalBasisA Local space basis attached to body A against which to measure body B's transformed axis. Expressed as a 3x3 rotation matrix, the X axis corresponds with 0 degrees, the Y axis corresponds to 90 degrees, and the Z axis is the twist axis. public Quaternion LocalBasisA Field Value Quaternion LocalBasisB Local space basis attached to body B that will be measured against body A's basis. Expressed as a 3x3 rotation matrix, the transformed X axis will be measured against A's X and Y axes. The Z axis is the twist axis. public Quaternion LocalBasisB Field Value Quaternion MaximumAngle Maximum angle between B's axis to measure and A's measurement axis. public float MaximumAngle Field Value float MinimumAngle Minimum angle between B's axis to measure and A's measurement axis. public float MinimumAngle Field Value float SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out TwistLimit) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out TwistLimit description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description TwistLimit Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.TwistLimitFunctions.html": {
    "href": "api/BepuPhysics.Constraints.TwistLimitFunctions.html",
    "title": "Struct TwistLimitFunctions | Bepu API",
    "keywords": "Struct TwistLimitFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct TwistLimitFunctions : ITwoBodyConstraintFunctions<TwistLimitPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<TwistLimitPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref TwistLimitPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref TwistLimitPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData TwistLimitPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref TwistLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref TwistLimitPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep TwistLimitPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref TwistLimitPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref TwistLimitPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep TwistLimitPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.TwistLimitPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.TwistLimitPrestepData.html",
    "title": "Struct TwistLimitPrestepData | Bepu API",
    "keywords": "Struct TwistLimitPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct TwistLimitPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalBasisA public QuaternionWide LocalBasisA Field Value QuaternionWide LocalBasisB public QuaternionWide LocalBasisB Field Value QuaternionWide MaximumAngle public Vector<float> MaximumAngle Field Value Vector<float> MinimumAngle public Vector<float> MinimumAngle Field Value Vector<float> SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.TwistLimitTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.TwistLimitTypeProcessor.html",
    "title": "Class TwistLimitTypeProcessor | Bepu API",
    "keywords": "Class TwistLimitTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class TwistLimitTypeProcessor : TwoBodyTypeProcessor<TwistLimitPrestepData, Vector<float>, TwistLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>> TwoBodyTypeProcessor<TwistLimitPrestepData, Vector<float>, TwistLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> TwistLimitTypeProcessor Inherited Members TwoBodyTypeProcessor<TwistLimitPrestepData, Vector<float>, TwistLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.InternalBodiesPerConstraint TwoBodyTypeProcessor<TwistLimitPrestepData, Vector<float>, TwistLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<TwistLimitPrestepData, Vector<float>, TwistLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<TwistLimitPrestepData, Vector<float>, TwistLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<TwistLimitPrestepData, Vector<float>, TwistLimitFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref TwistLimitPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref TwistLimitPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TwistLimitPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 27 Field Value int"
  },
  "api/BepuPhysics.Constraints.TwistMotor.html": {
    "href": "api/BepuPhysics.Constraints.TwistMotor.html",
    "title": "Struct TwistMotor | Bepu API",
    "keywords": "Struct TwistMotor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains the twist velocity between two bodies to a target. public struct TwistMotor : ITwoBodyConstraintDescription<TwistMotor>, IConstraintDescription<TwistMotor> Implements ITwoBodyConstraintDescription<TwistMotor> IConstraintDescription<TwistMotor> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalAxisA Local twist axis attached to body A. public Vector3 LocalAxisA Field Value Vector3 LocalAxisB Local twist axis attached to body B. public Vector3 LocalAxisB Field Value Vector3 Settings Motor control parameters. public MotorSettings Settings Field Value MotorSettings TargetVelocity Goal relative twist velocity around the body axes. public float TargetVelocity Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out TwistMotor) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out TwistMotor description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description TwistMotor Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.TwistMotorFunctions.html": {
    "href": "api/BepuPhysics.Constraints.TwistMotorFunctions.html",
    "title": "Struct TwistMotorFunctions | Bepu API",
    "keywords": "Struct TwistMotorFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct TwistMotorFunctions : ITwoBodyConstraintFunctions<TwistMotorPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<TwistMotorPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ComputeJacobian(in QuaternionWide, in QuaternionWide, in Vector3Wide, in Vector3Wide, out Vector3Wide) public static void ComputeJacobian(in QuaternionWide orientationA, in QuaternionWide orientationB, in Vector3Wide localAxisA, in Vector3Wide localAxisB, out Vector3Wide jacobianA) Parameters orientationA QuaternionWide orientationB QuaternionWide localAxisA Vector3Wide localAxisB Vector3Wide jacobianA Vector3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref TwistMotorPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref TwistMotorPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData TwistMotorPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref TwistMotorPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref TwistMotorPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep TwistMotorPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref TwistMotorPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref TwistMotorPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep TwistMotorPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.TwistMotorPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.TwistMotorPrestepData.html",
    "title": "Struct TwistMotorPrestepData | Bepu API",
    "keywords": "Struct TwistMotorPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct TwistMotorPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalAxisA public Vector3Wide LocalAxisA Field Value Vector3Wide LocalAxisB public Vector3Wide LocalAxisB Field Value Vector3Wide Settings public MotorSettingsWide Settings Field Value MotorSettingsWide TargetVelocity public Vector<float> TargetVelocity Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.TwistMotorTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.TwistMotorTypeProcessor.html",
    "title": "Class TwistMotorTypeProcessor | Bepu API",
    "keywords": "Class TwistMotorTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class TwistMotorTypeProcessor : TwoBodyTypeProcessor<TwistMotorPrestepData, Vector<float>, TwistMotorFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>> TwoBodyTypeProcessor<TwistMotorPrestepData, Vector<float>, TwistMotorFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> TwistMotorTypeProcessor Inherited Members TwoBodyTypeProcessor<TwistMotorPrestepData, Vector<float>, TwistMotorFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.InternalBodiesPerConstraint TwoBodyTypeProcessor<TwistMotorPrestepData, Vector<float>, TwistMotorFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<TwistMotorPrestepData, Vector<float>, TwistMotorFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<TwistMotorPrestepData, Vector<float>, TwistMotorFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<TwistMotorPrestepData, Vector<float>, TwistMotorFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref TwistMotorPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref TwistMotorPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TwistMotorPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 28 Field Value int"
  },
  "api/BepuPhysics.Constraints.TwistServo.html": {
    "href": "api/BepuPhysics.Constraints.TwistServo.html",
    "title": "Struct TwistServo | Bepu API",
    "keywords": "Struct TwistServo Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains two bodies to maintain a target twist angle around body-attached axes. public struct TwistServo : ITwoBodyConstraintDescription<TwistServo>, IConstraintDescription<TwistServo> Implements ITwoBodyConstraintDescription<TwistServo> IConstraintDescription<TwistServo> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalBasisA Local space basis attached to body A against which to measure body B's transformed axis. Expressed as a 3x3 rotation matrix, the X axis corresponds with 0 degrees, the Y axis corresponds to 90 degrees, and the -Z axis is the twist axis. When viewed along the twist axis, positive change in angle causes counterclockwise rotation in right handed coordinates. public Quaternion LocalBasisA Field Value Quaternion LocalBasisB Local space basis attached to body B that will be measured against body A's basis. Expressed as a 3x3 rotation matrix, the transformed X axis will be measured against A's X and Y axes. The Z axis is the twist axis. public Quaternion LocalBasisB Field Value Quaternion ServoSettings Servo control parameters. public ServoSettings ServoSettings Field Value ServoSettings SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings TargetAngle Target angle between B's axis to measure and A's measurement axis. public float TargetAngle Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out TwistServo) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out TwistServo description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description TwistServo Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.TwistServoFunctions.html": {
    "href": "api/BepuPhysics.Constraints.TwistServoFunctions.html",
    "title": "Struct TwistServoFunctions | Bepu API",
    "keywords": "Struct TwistServoFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct TwistServoFunctions : ITwoBodyConstraintFunctions<TwistServoPrestepData, Vector<float>> Implements ITwoBodyConstraintFunctions<TwistServoPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods ApplyImpulse(ref Vector3Wide, ref Vector3Wide, in Vector3Wide, in Vector3Wide, in Vector<float>) public static void ApplyImpulse(ref Vector3Wide angularVelocityA, ref Vector3Wide angularVelocityB, in Vector3Wide impulseToVelocityA, in Vector3Wide negatedImpulseToVelocityB, in Vector<float> csi) Parameters angularVelocityA Vector3Wide angularVelocityB Vector3Wide impulseToVelocityA Vector3Wide negatedImpulseToVelocityB Vector3Wide csi Vector<float> ComputeCurrentAngle(in Vector3Wide, in Vector3Wide, in Matrix3x3Wide, out Vector<float>) public static void ComputeCurrentAngle(in Vector3Wide basisBX, in Vector3Wide basisBZ, in Matrix3x3Wide basisA, out Vector<float> angle) Parameters basisBX Vector3Wide basisBZ Vector3Wide basisA Matrix3x3Wide angle Vector<float> ComputeEffectiveMass(float, in SpringSettingsWide, in Symmetric3x3Wide, in Symmetric3x3Wide, in Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector<float>, out Vector<float>, out Vector<float>, out Vector3Wide) public static void ComputeEffectiveMass(float dt, in SpringSettingsWide springSettings, in Symmetric3x3Wide inverseInertiaA, in Symmetric3x3Wide inverseInertiaB, in Vector3Wide jacobianA, out Vector3Wide impulseToVelocityA, out Vector3Wide negatedImpulseToVelocityB, out Vector<float> positionErrorToVelocity, out Vector<float> softnessImpulseScale, out Vector<float> effectiveMass, out Vector3Wide velocityToImpulseA) Parameters dt float springSettings SpringSettingsWide inverseInertiaA Symmetric3x3Wide inverseInertiaB Symmetric3x3Wide jacobianA Vector3Wide impulseToVelocityA Vector3Wide negatedImpulseToVelocityB Vector3Wide positionErrorToVelocity Vector<float> softnessImpulseScale Vector<float> effectiveMass Vector<float> velocityToImpulseA Vector3Wide ComputeEffectiveMassContributions(in Symmetric3x3Wide, in Symmetric3x3Wide, in Vector3Wide, out Vector3Wide, out Vector3Wide, out Vector<float>) public static void ComputeEffectiveMassContributions(in Symmetric3x3Wide inverseInertiaA, in Symmetric3x3Wide inverseInertiaB, in Vector3Wide jacobianA, out Vector3Wide impulseToVelocityA, out Vector3Wide negatedImpulseToVelocityB, out Vector<float> unsoftenedInverseEffectiveMass) Parameters inverseInertiaA Symmetric3x3Wide inverseInertiaB Symmetric3x3Wide jacobianA Vector3Wide impulseToVelocityA Vector3Wide negatedImpulseToVelocityB Vector3Wide unsoftenedInverseEffectiveMass Vector<float> ComputeJacobian(in QuaternionWide, in QuaternionWide, in QuaternionWide, in QuaternionWide, out Vector3Wide) public static void ComputeJacobian(in QuaternionWide orientationA, in QuaternionWide orientationB, in QuaternionWide localBasisA, in QuaternionWide localBasisB, out Vector3Wide jacobianA) Parameters orientationA QuaternionWide orientationB QuaternionWide localBasisA QuaternionWide localBasisB QuaternionWide jacobianA Vector3Wide ComputeJacobian(in QuaternionWide, in QuaternionWide, in QuaternionWide, in QuaternionWide, out Vector3Wide, out Vector3Wide, out Matrix3x3Wide, out Vector3Wide) public static void ComputeJacobian(in QuaternionWide orientationA, in QuaternionWide orientationB, in QuaternionWide localBasisA, in QuaternionWide localBasisB, out Vector3Wide basisBX, out Vector3Wide basisBZ, out Matrix3x3Wide basisA, out Vector3Wide jacobianA) Parameters orientationA QuaternionWide orientationB QuaternionWide localBasisA QuaternionWide localBasisB QuaternionWide basisBX Vector3Wide basisBZ Vector3Wide basisA Matrix3x3Wide jacobianA Vector3Wide IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref TwistServoPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref TwistServoPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData TwistServoPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref TwistServoPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref TwistServoPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep TwistServoPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref TwistServoPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref TwistServoPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep TwistServoPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.TwistServoPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.TwistServoPrestepData.html",
    "title": "Struct TwistServoPrestepData | Bepu API",
    "keywords": "Struct TwistServoPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct TwistServoPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalBasisA public QuaternionWide LocalBasisA Field Value QuaternionWide LocalBasisB public QuaternionWide LocalBasisB Field Value QuaternionWide ServoSettings public ServoSettingsWide ServoSettings Field Value ServoSettingsWide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide TargetAngle public Vector<float> TargetAngle Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.TwistServoTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.TwistServoTypeProcessor.html",
    "title": "Class TwistServoTypeProcessor | Bepu API",
    "keywords": "Class TwistServoTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public class TwistServoTypeProcessor : TwoBodyTypeProcessor<TwistServoPrestepData, Vector<float>, TwistServoFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>> TwoBodyTypeProcessor<TwistServoPrestepData, Vector<float>, TwistServoFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular> TwistServoTypeProcessor Inherited Members TwoBodyTypeProcessor<TwistServoPrestepData, Vector<float>, TwistServoFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.InternalBodiesPerConstraint TwoBodyTypeProcessor<TwistServoPrestepData, Vector<float>, TwistServoFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<TwistServoPrestepData, Vector<float>, TwistServoFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<TwistServoPrestepData, Vector<float>, TwistServoFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<TwistServoPrestepData, Vector<float>, TwistServoFunctions, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular, AccessOnlyAngular>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.Move(ref TwoBodyReferences, ref TwistServoPrestepData, ref Vector<float>, ConstraintHandle, int, ref TwoBodyReferences, ref TwistServoPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TwistServoPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 26 Field Value int"
  },
  "api/BepuPhysics.Constraints.TwoBodyContactTypeProcessor-3.html": {
    "href": "api/BepuPhysics.Constraints.TwoBodyContactTypeProcessor-3.html",
    "title": "Class TwoBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> | Bepu API",
    "keywords": "Class TwoBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public abstract class TwoBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> : TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose> where TPrestepData : unmanaged where TAccumulatedImpulse : unmanaged where TConstraintFunctions : unmanaged, ITwoBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Type Parameters TPrestepData TAccumulatedImpulse TConstraintFunctions Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse> TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose> TwoBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> Derived Contact1TypeProcessor Contact2NonconvexTypeProcessor Contact2TypeProcessor Contact3NonconvexTypeProcessor Contact3TypeProcessor Contact4NonconvexTypeProcessor Contact4TypeProcessor Inherited Members TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.InternalBodiesPerConstraint TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, AccessNoPose, AccessNoPose, AccessNoPose, AccessNoPose>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Move(ref TwoBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ConstraintHandle, int, ref TwoBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/BepuPhysics.Constraints.TwoBodyReferences.html": {
    "href": "api/BepuPhysics.Constraints.TwoBodyReferences.html",
    "title": "Struct TwoBodyReferences | Bepu API",
    "keywords": "Struct TwoBodyReferences Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve. Two address streams isn't much of a problem for prefetching. public struct TwoBodyReferences Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields IndexA public Vector<int> IndexA Field Value Vector<int> IndexB public Vector<int> IndexB Field Value Vector<int>"
  },
  "api/BepuPhysics.Constraints.TwoBodyTypeProcessor-7.html": {
    "href": "api/BepuPhysics.Constraints.TwoBodyTypeProcessor-7.html",
    "title": "Class TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TSolveAccessFilterA, TSolveAccessFilterB> | Bepu API",
    "keywords": "Class TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TSolveAccessFilterA, TSolveAccessFilterB> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Shared implementation across all two body constraints. public abstract class TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TSolveAccessFilterA, TSolveAccessFilterB> : TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse> where TPrestepData : unmanaged where TAccumulatedImpulse : unmanaged where TConstraintFunctions : unmanaged, ITwoBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> where TWarmStartAccessFilterA : unmanaged, IBodyAccessFilter where TWarmStartAccessFilterB : unmanaged, IBodyAccessFilter where TSolveAccessFilterA : unmanaged, IBodyAccessFilter where TSolveAccessFilterB : unmanaged, IBodyAccessFilter Type Parameters TPrestepData TAccumulatedImpulse TConstraintFunctions TWarmStartAccessFilterA TWarmStartAccessFilterB TSolveAccessFilterA TSolveAccessFilterB Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse> TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TSolveAccessFilterA, TSolveAccessFilterB> Derived AngularAxisGearMotorTypeProcessor AngularAxisMotorTypeProcessor AngularHingeTypeProcessor AngularMotorTypeProcessor AngularServoTypeProcessor AngularSwivelHingeTypeProcessor BallSocketMotorTypeProcessor BallSocketServoTypeProcessor BallSocketTypeProcessor CenterDistanceLimitTypeProcessor CenterDistanceTypeProcessor DistanceLimitTypeProcessor DistanceServoTypeProcessor HingeTypeProcessor LinearAxisLimitTypeProcessor LinearAxisMotorTypeProcessor LinearAxisServoTypeProcessor PointOnLineServoTypeProcessor SwingLimitTypeProcessor SwivelHingeTypeProcessor TwistLimitTypeProcessor TwistMotorTypeProcessor TwistServoTypeProcessor TwoBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> WeldTypeProcessor Inherited Members TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Move(ref TwoBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ConstraintHandle, int, ref TwoBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, TPrestepData, TAccumulatedImpulse>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties InternalBodiesPerConstraint protected override sealed int InternalBodiesPerConstraint { get; } Property Value int RequiresIncrementalSubstepUpdates Gets whether this type requires incremental updates for each substep in a frame beyond the first. public override bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) public override void IncrementallyUpdateForSubstep(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int exclusiveEndBundle) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int exclusiveEndBundle int Solve(ref TypeBatch, Bodies, float, float, int, int) public override void Solve(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int exclusiveEndBundle) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int exclusiveEndBundle int WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) public override void WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch typeBatch, ref Buffer<IndexSet> integrationFlags, Bodies bodies, ref TIntegratorCallbacks integratorCallbacks, float dt, float inverseDt, int startBundle, int exclusiveEndBundle, int workerIndex) where TIntegratorCallbacks : struct, IPoseIntegratorCallbacks where TBatchIntegrationMode : unmanaged, IBatchIntegrationMode where TAllowPoseIntegration : unmanaged, IBatchPoseIntegrationAllowed Parameters typeBatch TypeBatch integrationFlags Buffer<IndexSet> bodies Bodies integratorCallbacks TIntegratorCallbacks dt float inverseDt float startBundle int exclusiveEndBundle int workerIndex int Type Parameters TIntegratorCallbacks TBatchIntegrationMode TAllowPoseIntegration"
  },
  "api/BepuPhysics.Constraints.TypeBatch.html": {
    "href": "api/BepuPhysics.Constraints.TypeBatch.html",
    "title": "Struct TypeBatch | Bepu API",
    "keywords": "Struct TypeBatch Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Stores the raw AOSOA formatted data associated with constraints in a type batch. public struct TypeBatch Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields AccumulatedImpulses public Buffer<byte> AccumulatedImpulses Field Value Buffer<byte> BodyReferences public Buffer<byte> BodyReferences Field Value Buffer<byte> ConstraintCount public int ConstraintCount Field Value int IndexToHandle public Buffer<ConstraintHandle> IndexToHandle Field Value Buffer<ConstraintHandle> PrestepData public Buffer<byte> PrestepData Field Value Buffer<byte> TypeId public int TypeId Field Value int Properties BundleCount public int BundleCount { get; } Property Value int Methods Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool"
  },
  "api/BepuPhysics.Constraints.TypeProcessor-3.BundleIntegrationMode.html": {
    "href": "api/BepuPhysics.Constraints.TypeProcessor-3.BundleIntegrationMode.html",
    "title": "Enum TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleIntegrationMode | Bepu API",
    "keywords": "Enum TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleIntegrationMode Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public enum TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleIntegrationMode Fields All = 2 None = 0 Partial = 1"
  },
  "api/BepuPhysics.Constraints.TypeProcessor-3.html": {
    "href": "api/BepuPhysics.Constraints.TypeProcessor-3.html",
    "title": "Class TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse> | Bepu API",
    "keywords": "Class TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse> Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public abstract class TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse> : TypeProcessor where TBodyReferences : unmanaged where TPrestepData : unmanaged where TAccumulatedImpulse : unmanaged Type Parameters TBodyReferences TPrestepData TAccumulatedImpulse Inheritance object TypeProcessor TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse> Derived FourBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TWarmStartAccessFilterD, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC, TSolveAccessFilterD> OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TSolveAccessFilterA> ThreeBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC> TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TSolveAccessFilterA, TSolveAccessFilterB> Inherited Members TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.Initialize(int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties InternalConstrainedDegreesOfFreedom protected override int InternalConstrainedDegreesOfFreedom { get; } Property Value int Methods AddBodyReferencesLane(ref TBodyReferences, int, Span<int>) public static void AddBodyReferencesLane(ref TBodyReferences bundle, int innerIndex, Span<int> bodyIndices) Parameters bundle TBodyReferences innerIndex int bodyIndices Span<int> AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) Allocates a slot in the batch, assuming the batch is not a fallback batch. public override sealed int AllocateInTypeBatch(ref TypeBatch typeBatch, ConstraintHandle handle, Span<int> bodyIndices, BufferPool pool) Parameters typeBatch TypeBatch Type batch to allocate in. handle ConstraintHandle Handle of the constraint to allocate. Establishes a link from the allocated constraint to its handle. bodyIndices Span<int> pool BufferPool Allocation provider to use if the type batch has to be resized. Returns int Index of the slot in the batch. AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) Allocates a slot in the batch, assuming the batch is a fallback batch. public override sealed int AllocateInTypeBatchForFallback(ref TypeBatch typeBatch, ConstraintHandle handle, Span<int> encodedBodyIndices, BufferPool pool) Parameters typeBatch TypeBatch Type batch to allocate in. handle ConstraintHandle Handle of the constraint to allocate. Establishes a link from the allocated constraint to its handle. encodedBodyIndices Span<int> List of body indices (not handles!) with count equal to the type batch's expected number of involved bodies. pool BufferPool Allocation provider to use if the type batch has to be resized. Returns int Index of the slot in the batch. BundleShouldIntegrate(int, in IndexSet, out Vector<int>) public static TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleIntegrationMode BundleShouldIntegrate(int bundleIndex, in IndexSet integrationFlags, out Vector<int> integrationMask) Parameters bundleIndex int integrationFlags IndexSet integrationMask Vector<int> Returns TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleIntegrationMode GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) public static void GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies bodies, ref TIntegratorCallbacks integratorCallbacks, ref Buffer<IndexSet> integrationFlags, int bodyIndexInConstraint, float dt, int workerIndex, int bundleIndex, ref Vector<int> encodedBodyIndices, out Vector3Wide position, out QuaternionWide orientation, out BodyVelocityWide velocity, out BodyInertiaWide inertia) where TIntegratorCallbacks : struct, IPoseIntegratorCallbacks where TBatchIntegrationMode : unmanaged, IBatchIntegrationMode where TAccessFilter : unmanaged, IBodyAccessFilter where TShouldIntegratePoses : unmanaged, IBatchPoseIntegrationAllowed Parameters bodies Bodies integratorCallbacks TIntegratorCallbacks integrationFlags Buffer<IndexSet> bodyIndexInConstraint int dt float workerIndex int bundleIndex int encodedBodyIndices Vector<int> position Vector3Wide orientation QuaternionWide velocity BodyVelocityWide inertia BodyInertiaWide Type Parameters TIntegratorCallbacks TBatchIntegrationMode TAccessFilter TShouldIntegratePoses GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) protected void GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch typeBatch, int bundleStart, int localBundleStart, int bundleCount, int constraintStart, int localConstraintStart, int constraintCount, ref int firstSortKey, ref int firstSourceIndex, ref Buffer<byte> bodyReferencesCache) where TSortKeyGenerator : struct, ISortKeyGenerator<TBodyReferences> Parameters typeBatch TypeBatch bundleStart int localBundleStart int bundleCount int constraintStart int localConstraintStart int constraintCount int firstSortKey int firstSourceIndex int bodyReferencesCache Buffer<byte> Type Parameters TSortKeyGenerator Initialize(ref TypeBatch, int, BufferPool) public override void Initialize(ref TypeBatch typeBatch, int initialCapacity, BufferPool pool) Parameters typeBatch TypeBatch initialCapacity int pool BufferPool IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) public static void IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks integratorCallbacks, ref Vector<int> bodyIndices, in BodyInertiaWide localInertia, float dt, in Vector<int> integrationMask, ref Vector3Wide position, ref QuaternionWide orientation, ref BodyVelocityWide velocity, int workerIndex, out BodyInertiaWide inertia) where TIntegratorCallbacks : struct, IPoseIntegratorCallbacks Parameters integratorCallbacks TIntegratorCallbacks bodyIndices Vector<int> localInertia BodyInertiaWide dt float integrationMask Vector<int> position Vector3Wide orientation QuaternionWide velocity BodyVelocityWide workerIndex int inertia BodyInertiaWide Type Parameters TIntegratorCallbacks IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) public static void IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks integratorCallbacks, ref Vector<int> bodyIndices, in BodyInertiaWide localInertia, float dt, in Vector<int> integrationMask, in Vector3Wide position, in QuaternionWide orientation, ref BodyVelocityWide velocity, int workerIndex, out BodyInertiaWide inertia) where TIntegratorCallbacks : struct, IPoseIntegratorCallbacks where TBatchIntegrationMode : unmanaged, IBatchIntegrationMode Parameters integratorCallbacks TIntegratorCallbacks bodyIndices Vector<int> localInertia BodyInertiaWide dt float integrationMask Vector<int> position Vector3Wide orientation QuaternionWide velocity BodyVelocityWide workerIndex int inertia BodyInertiaWide Type Parameters TIntegratorCallbacks TBatchIntegrationMode Move(ref TBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ConstraintHandle, int, ref TBodyReferences, ref TPrestepData, ref TAccumulatedImpulse, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) Overwrites all the data in the target constraint slot with source data. protected static void Move(ref TBodyReferences sourceReferencesBundle, ref TPrestepData sourcePrestepBundle, ref TAccumulatedImpulse sourceAccumulatedBundle, ConstraintHandle sourceHandle, int sourceInner, ref TBodyReferences targetReferencesBundle, ref TPrestepData targetPrestepBundle, ref TAccumulatedImpulse targetAccumulatedBundle, ref ConstraintHandle targetIndexToHandle, int targetInner, int targetIndex, ref Buffer<ConstraintLocation> handlesToConstraints) Parameters sourceReferencesBundle TBodyReferences sourcePrestepBundle TPrestepData sourceAccumulatedBundle TAccumulatedImpulse sourceHandle ConstraintHandle sourceInner int targetReferencesBundle TBodyReferences targetPrestepBundle TPrestepData targetAccumulatedBundle TAccumulatedImpulse targetIndexToHandle ConstraintHandle targetInner int targetIndex int handlesToConstraints Buffer<ConstraintLocation> Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) Removes a constraint from the batch. public override void Remove(ref TypeBatch typeBatch, int index, ref Buffer<ConstraintLocation> handlesToConstraints, bool isFallback) Parameters typeBatch TypeBatch Type batch to remove a constraint from. index int Index of the constraint to remove. handlesToConstraints Buffer<ConstraintLocation> The handle to constraint mapping used by the solver that could be modified by a swap on removal. isFallback bool True if the type batch being removed from belongs to the fallback batch, false otherwise. RemoveBodyReferencesLane(ref TBodyReferences, int) public static void RemoveBodyReferencesLane(ref TBodyReferences bundle, int innerIndex) Parameters bundle TBodyReferences innerIndex int Resize(ref TypeBatch, int, BufferPool) public override void Resize(ref TypeBatch typeBatch, int desiredCapacity, BufferPool pool) Parameters typeBatch TypeBatch desiredCapacity int pool BufferPool ScaleAccumulatedImpulses(ref TypeBatch, float) public override void ScaleAccumulatedImpulses(ref TypeBatch typeBatch, float scale) Parameters typeBatch TypeBatch scale float Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) public override sealed void Scramble(ref TypeBatch typeBatch, Random random, ref Buffer<ConstraintLocation> handlesToConstraints) Parameters typeBatch TypeBatch random Random handlesToConstraints Buffer<ConstraintLocation> SetBodyReferencesLane(ref TBodyReferences, int, Span<int>) public static void SetBodyReferencesLane(ref TBodyReferences bundle, int innerIndex, Span<int> bodyIndices) Parameters bundle TBodyReferences innerIndex int bodyIndices Span<int> TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) Moves a constraint from one ConstraintBatch's TypeBatch to another ConstraintBatch's TypeBatch of the same type. public override sealed void TransferConstraint(ref TypeBatch sourceTypeBatch, int sourceBatchIndex, int indexInTypeBatch, Solver solver, Bodies bodies, int targetBatchIndex, Span<BodyHandle> dynamicBodyHandles, Span<int> encodedBodyIndices) Parameters sourceTypeBatch TypeBatch Source type batch to transfer the constraint out of. sourceBatchIndex int Index of the batch that owns the type batch that is the source of the constraint transfer. indexInTypeBatch int Index of the constraint to move in the current type batch. solver Solver Solver that owns the batches. bodies Bodies Bodies set that owns all the constraint's bodies. targetBatchIndex int Index of the ConstraintBatch in the solver to copy the constraint into. dynamicBodyHandles Span<BodyHandle> Set of body handles in the constraint referring to dynamic bodies. encodedBodyIndices Span<int> Set of encoded body indices to use in the new constraint allocation. UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) Updates a type batch's body index references for the movement of a body in memory. public override sealed bool UpdateForBodyMemoryMove(ref TypeBatch typeBatch, int indexInTypeBatch, int bodyIndexInConstraint, int newBodyLocation) Parameters typeBatch TypeBatch Type batch containing a constraint that references the body. indexInTypeBatch int Index of the constraint in the type batch. bodyIndexInConstraint int Index within the constraint of the body. newBodyLocation int New index of the body in the bodies active set. Returns bool True if the body being moved was kinematic according to the constraint's reference. ValidateAccumulatedImpulsesSizeInBytes(int) protected override void ValidateAccumulatedImpulsesSizeInBytes(int sizeInBytes) Parameters sizeInBytes int VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) protected void VerifySortRegion<TSortKeyGenerator>(ref TypeBatch typeBatch, int bundleStartIndex, int constraintCount, ref Buffer<int> sortedKeys, ref Buffer<int> sortedSourceIndices) where TSortKeyGenerator : struct, ISortKeyGenerator<TBodyReferences> Parameters typeBatch TypeBatch bundleStartIndex int constraintCount int sortedKeys Buffer<int> sortedSourceIndices Buffer<int> Type Parameters TSortKeyGenerator"
  },
  "api/BepuPhysics.Constraints.TypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.TypeProcessor.html",
    "title": "Class TypeProcessor | Bepu API",
    "keywords": "Class TypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Superclass of constraint type batch processors. Responsible for interpreting raw type batches for the purposes of bookkeeping and solving. public abstract class TypeProcessor Inheritance object TypeProcessor Derived TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class holds no actual state of its own. A solver creates a unique type processor for each registered constraint type, and all instances are held in untyped memory. Splitting the functionality from the data allows for far fewer GC-tracked instances and allows the raw data layout to be shared more easily. For example, sleeping simulation islands store type batches, but they are created and used differently- and for convenience, they are stored on a per-island basis. Using the same system but with reference type TypeBatches, tens of thousands of inactive islands would imply tens of thousands of GC-tracked objects. That's not acceptable, so here we are. Conceptually, you can think of the solver's array of TypeProcessors like C function pointers. Fields bodiesPerConstraint protected int bodiesPerConstraint Field Value int typeId protected int typeId Field Value int Properties BodiesPerConstraint Gets the number of bodies associated with each constraint in this type processor. public int BodiesPerConstraint { get; } Property Value int ConstrainedDegreesOfFreedom Gets the number of degrees of freedom that each constraint in this type processor constrains. Equal to the number of entries in the accumulated impulses. public int ConstrainedDegreesOfFreedom { get; } Property Value int InternalBodiesPerConstraint protected abstract int InternalBodiesPerConstraint { get; } Property Value int InternalConstrainedDegreesOfFreedom protected abstract int InternalConstrainedDegreesOfFreedom { get; } Property Value int RequiresIncrementalSubstepUpdates Gets whether this type requires incremental updates for each substep in a frame beyond the first. public abstract bool RequiresIncrementalSubstepUpdates { get; } Property Value bool TypeId public int TypeId { get; } Property Value int Methods AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) Allocates a slot in the batch, assuming the batch is not a fallback batch. public abstract int AllocateInTypeBatch(ref TypeBatch typeBatch, ConstraintHandle handle, Span<int> encodedBodyIndices, BufferPool pool) Parameters typeBatch TypeBatch Type batch to allocate in. handle ConstraintHandle Handle of the constraint to allocate. Establishes a link from the allocated constraint to its handle. encodedBodyIndices Span<int> List of body indices (not handles!) with count equal to the type batch's expected number of involved bodies. pool BufferPool Allocation provider to use if the type batch has to be resized. Returns int Index of the slot in the batch. AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) Allocates a slot in the batch, assuming the batch is a fallback batch. public abstract int AllocateInTypeBatchForFallback(ref TypeBatch typeBatch, ConstraintHandle handle, Span<int> encodedBodyIndices, BufferPool pool) Parameters typeBatch TypeBatch Type batch to allocate in. handle ConstraintHandle Handle of the constraint to allocate. Establishes a link from the allocated constraint to its handle. encodedBodyIndices Span<int> List of body indices (not handles!) with count equal to the type batch's expected number of involved bodies. pool BufferPool Allocation provider to use if the type batch has to be resized. Returns int Index of the slot in the batch. EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) public void EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch typeBatch, int indexInTypeBatch, ref TEnumerator enumerator) where TEnumerator : IForEach<float> Parameters typeBatch TypeBatch indexInTypeBatch int enumerator TEnumerator Type Parameters TEnumerator IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) public virtual void IncrementallyUpdateForSubstep(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int end) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int end int Initialize(ref TypeBatch, int, BufferPool) public abstract void Initialize(ref TypeBatch typeBatch, int initialCapacity, BufferPool pool) Parameters typeBatch TypeBatch initialCapacity int pool BufferPool Initialize(int) public void Initialize(int typeId) Parameters typeId int Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) public abstract void Remove(ref TypeBatch typeBatch, int index, ref Buffer<ConstraintLocation> handlesToConstraints, bool isFallback) Parameters typeBatch TypeBatch index int handlesToConstraints Buffer<ConstraintLocation> isFallback bool Resize(ref TypeBatch, int, BufferPool) public abstract void Resize(ref TypeBatch typeBatch, int newCapacity, BufferPool pool) Parameters typeBatch TypeBatch newCapacity int pool BufferPool ScaleAccumulatedImpulses(ref TypeBatch, float) public abstract void ScaleAccumulatedImpulses(ref TypeBatch typeBatch, float scale) Parameters typeBatch TypeBatch scale float Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) public abstract void Scramble(ref TypeBatch typeBatch, Random random, ref Buffer<ConstraintLocation> handlesToConstraints) Parameters typeBatch TypeBatch random Random handlesToConstraints Buffer<ConstraintLocation> Solve(ref TypeBatch, Bodies, float, float, int, int) public abstract void Solve(ref TypeBatch typeBatch, Bodies bodies, float dt, float inverseDt, int startBundle, int exclusiveEndBundle) Parameters typeBatch TypeBatch bodies Bodies dt float inverseDt float startBundle int exclusiveEndBundle int TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) Moves a constraint from one ConstraintBatch's TypeBatch to another ConstraintBatch's TypeBatch of the same type. public void TransferConstraint(ref TypeBatch sourceTypeBatch, int sourceBatchIndex, int indexInTypeBatch, Solver solver, Bodies bodies, int targetBatchIndex) Parameters sourceTypeBatch TypeBatch Source type batch to transfer the constraint out of. sourceBatchIndex int Index of the batch that owns the type batch that is the source of the constraint transfer. indexInTypeBatch int Index of the constraint to move in the current type batch. solver Solver Solver that owns the batches. bodies Bodies Bodies set that owns all the constraint's bodies. targetBatchIndex int Index of the ConstraintBatch in the solver to copy the constraint into. TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) Moves a constraint from one ConstraintBatch's TypeBatch to another ConstraintBatch's TypeBatch of the same type. public abstract void TransferConstraint(ref TypeBatch sourceTypeBatch, int sourceBatchIndex, int indexInTypeBatch, Solver solver, Bodies bodies, int targetBatchIndex, Span<BodyHandle> dynamicBodyHandles, Span<int> encodedBodyIndices) Parameters sourceTypeBatch TypeBatch Source type batch to transfer the constraint out of. sourceBatchIndex int Index of the batch that owns the type batch that is the source of the constraint transfer. indexInTypeBatch int Index of the constraint to move in the current type batch. solver Solver Solver that owns the batches. bodies Bodies Bodies set that owns all the constraint's bodies. targetBatchIndex int Index of the ConstraintBatch in the solver to copy the constraint into. dynamicBodyHandles Span<BodyHandle> Set of body handles in the constraint referring to dynamic bodies. encodedBodyIndices Span<int> Set of encoded body indices to use in the new constraint allocation. UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) Updates a type batch's body index references for the movement of a body in memory. public abstract bool UpdateForBodyMemoryMove(ref TypeBatch typeBatch, int indexInTypeBatch, int bodyIndexInConstraint, int newBodyLocation) Parameters typeBatch TypeBatch Type batch containing a constraint that references the body. indexInTypeBatch int Index of the constraint in the type batch. bodyIndexInConstraint int Index within the constraint of the body. newBodyLocation int New index of the body in the bodies active set. Returns bool True if the body being moved was kinematic according to the constraint's reference. ValidateAccumulatedImpulsesSizeInBytes(int) [Conditional(\"DEBUG\")] protected abstract void ValidateAccumulatedImpulsesSizeInBytes(int sizeInBytes) Parameters sizeInBytes int WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) public abstract void WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch typeBatch, ref Buffer<IndexSet> integrationFlags, Bodies bodies, ref TIntegratorCallbacks poseIntegratorCallbacks, float dt, float inverseDt, int startBundle, int exclusiveEndBundle, int workerIndex) where TIntegratorCallbacks : struct, IPoseIntegratorCallbacks where TBatchIntegrationMode : unmanaged, IBatchIntegrationMode where TAllowPoseIntegration : unmanaged, IBatchPoseIntegrationAllowed Parameters typeBatch TypeBatch integrationFlags Buffer<IndexSet> bodies Bodies poseIntegratorCallbacks TIntegratorCallbacks dt float inverseDt float startBundle int exclusiveEndBundle int workerIndex int Type Parameters TIntegratorCallbacks TBatchIntegrationMode TAllowPoseIntegration"
  },
  "api/BepuPhysics.Constraints.VolumeConstraint.html": {
    "href": "api/BepuPhysics.Constraints.VolumeConstraint.html",
    "title": "Struct VolumeConstraint | Bepu API",
    "keywords": "Struct VolumeConstraint Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains the volume of a tetrahedron connecting the centers of four bodies to match a goal volume. Scaled volume computed from (ab x ac) * ad; the volume may be negative depending on the winding of the tetrahedron. public struct VolumeConstraint : IFourBodyConstraintDescription<VolumeConstraint>, IConstraintDescription<VolumeConstraint> Implements IFourBodyConstraintDescription<VolumeConstraint> IConstraintDescription<VolumeConstraint> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors VolumeConstraint(Vector3, Vector3, Vector3, Vector3, SpringSettings) Creates a new volume constraint, initializing the target volume using a set of initial positions. public VolumeConstraint(Vector3 a, Vector3 b, Vector3 c, Vector3 d, SpringSettings springSettings) Parameters a Vector3 Initial position of the first body. b Vector3 Initial position of the second body. c Vector3 Initial position of the third body. d Vector3 Initial position of the fourth body. springSettings SpringSettings Spring settings to apply to the volume constraint. Fields SpringSettings Spring frequency and damping parameters. public SpringSettings SpringSettings Field Value SpringSettings TargetScaledVolume 6 times the target volume of the tetrahedra. Computed from (ab x ac) * ad; this may be negative depending on the winding of the tetrahedron. public float TargetScaledVolume Field Value float Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out VolumeConstraint) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out VolumeConstraint description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description VolumeConstraint Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.VolumeConstraintFunctions.html": {
    "href": "api/BepuPhysics.Constraints.VolumeConstraintFunctions.html",
    "title": "Struct VolumeConstraintFunctions | Bepu API",
    "keywords": "Struct VolumeConstraintFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct VolumeConstraintFunctions : IFourBodyConstraintFunctions<VolumeConstraintPrestepData, Vector<float>> Implements IFourBodyConstraintFunctions<VolumeConstraintPrestepData, Vector<float>> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, in BodyVelocityWide, in BodyVelocityWide, ref VolumeConstraintPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, in BodyVelocityWide wsvC, in BodyVelocityWide wsvD, ref VolumeConstraintPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide wsvD BodyVelocityWide prestepData VolumeConstraintPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref VolumeConstraintPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, in Vector3Wide positionC, in QuaternionWide orientationC, in BodyInertiaWide inertiaC, in Vector3Wide positionD, in QuaternionWide orientationD, in BodyInertiaWide inertiaD, float dt, float inverseDt, ref VolumeConstraintPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB, ref BodyVelocityWide wsvC, ref BodyVelocityWide wsvD) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide positionC Vector3Wide orientationC QuaternionWide inertiaC BodyInertiaWide positionD Vector3Wide orientationD QuaternionWide inertiaD BodyInertiaWide dt float inverseDt float prestep VolumeConstraintPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide wsvD BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref VolumeConstraintPrestepData, ref Vector<float>, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, in Vector3Wide positionC, in QuaternionWide orientationC, in BodyInertiaWide inertiaC, in Vector3Wide positionD, in QuaternionWide orientationD, in BodyInertiaWide inertiaD, ref VolumeConstraintPrestepData prestep, ref Vector<float> accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB, ref BodyVelocityWide wsvC, ref BodyVelocityWide wsvD) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide positionC Vector3Wide orientationC QuaternionWide inertiaC BodyInertiaWide positionD Vector3Wide orientationD QuaternionWide inertiaD BodyInertiaWide prestep VolumeConstraintPrestepData accumulatedImpulses Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide wsvC BodyVelocityWide wsvD BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.VolumeConstraintPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.VolumeConstraintPrestepData.html",
    "title": "Struct VolumeConstraintPrestepData | Bepu API",
    "keywords": "Struct VolumeConstraintPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct VolumeConstraintPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide TargetScaledVolume public Vector<float> TargetScaledVolume Field Value Vector<float>"
  },
  "api/BepuPhysics.Constraints.VolumeConstraintTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.VolumeConstraintTypeProcessor.html",
    "title": "Class VolumeConstraintTypeProcessor | Bepu API",
    "keywords": "Class VolumeConstraintTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of volume constraints. public class VolumeConstraintTypeProcessor : FourBodyTypeProcessor<VolumeConstraintPrestepData, Vector<float>, VolumeConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear> Inheritance object TypeProcessor TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>> FourBodyTypeProcessor<VolumeConstraintPrestepData, Vector<float>, VolumeConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear> VolumeConstraintTypeProcessor Inherited Members FourBodyTypeProcessor<VolumeConstraintPrestepData, Vector<float>, VolumeConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.InternalBodiesPerConstraint FourBodyTypeProcessor<VolumeConstraintPrestepData, Vector<float>, VolumeConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) FourBodyTypeProcessor<VolumeConstraintPrestepData, Vector<float>, VolumeConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.Solve(ref TypeBatch, Bodies, float, float, int, int) FourBodyTypeProcessor<VolumeConstraintPrestepData, Vector<float>, VolumeConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.RequiresIncrementalSubstepUpdates FourBodyTypeProcessor<VolumeConstraintPrestepData, Vector<float>, VolumeConstraintFunctions, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear, AccessOnlyLinear>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.InternalConstrainedDegreesOfFreedom TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.SetBodyReferencesLane(ref FourBodyReferences, int, Span<int>) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.AddBodyReferencesLane(ref FourBodyReferences, int, Span<int>) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.RemoveBodyReferencesLane(ref FourBodyReferences, int) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.Move(ref FourBodyReferences, ref VolumeConstraintPrestepData, ref Vector<float>, ConstraintHandle, int, ref FourBodyReferences, ref VolumeConstraintPrestepData, ref Vector<float>, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<FourBodyReferences, VolumeConstraintPrestepData, Vector<float>>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 32 Field Value int"
  },
  "api/BepuPhysics.Constraints.Weld.html": {
    "href": "api/BepuPhysics.Constraints.Weld.html",
    "title": "Struct Weld | Bepu API",
    "keywords": "Struct Weld Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Constrains two bodies to maintain a relative position and orientation. All six degrees of freedom are solved simultaneously. public struct Weld : ITwoBodyConstraintDescription<Weld>, IConstraintDescription<Weld> Implements ITwoBodyConstraintDescription<Weld> IConstraintDescription<Weld> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffset Offset from body A to body B in the local space of A. public Vector3 LocalOffset Field Value Vector3 LocalOrientation Target orientation of body B in body A's local space. public Quaternion LocalOrientation Field Value Quaternion SpringSettings Springiness of the position and orientation constraints. public SpringSettings SpringSettings Field Value SpringSettings Properties ConstraintTypeId Gets the type id of the constraint that this is a description of. public static int ConstraintTypeId { get; } Property Value int TypeProcessorType Gets the type of the type batch which contains described constraints. public static Type TypeProcessorType { get; } Property Value Type Methods ApplyDescription(ref TypeBatch, int, int) Changes the batch-held memory at a given location to match the given description. public readonly void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex) Parameters batch TypeBatch Batch to modify. bundleIndex int Index of the target constraint's bundle. innerIndex int Index of the target constraint within its bundle. BuildDescription(ref TypeBatch, int, int, out Weld) Creates a description from the batch-held memory at a given location. public static void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out Weld description) Parameters batch TypeBatch Batch to read. bundleIndex int Index of the source constraint's bundle. innerIndex int Index of the source constraint within its bundle. description Weld Description of the constraint. CreateTypeProcessor() Creates a type processor for this constraint type. public static TypeProcessor CreateTypeProcessor() Returns TypeProcessor"
  },
  "api/BepuPhysics.Constraints.WeldAccumulatedImpulses.html": {
    "href": "api/BepuPhysics.Constraints.WeldAccumulatedImpulses.html",
    "title": "Struct WeldAccumulatedImpulses | Bepu API",
    "keywords": "Struct WeldAccumulatedImpulses Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct WeldAccumulatedImpulses Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Offset public Vector3Wide Offset Field Value Vector3Wide Orientation public Vector3Wide Orientation Field Value Vector3Wide"
  },
  "api/BepuPhysics.Constraints.WeldFunctions.html": {
    "href": "api/BepuPhysics.Constraints.WeldFunctions.html",
    "title": "Struct WeldFunctions | Bepu API",
    "keywords": "Struct WeldFunctions Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct WeldFunctions : ITwoBodyConstraintFunctions<WeldPrestepData, WeldAccumulatedImpulses> Implements ITwoBodyConstraintFunctions<WeldPrestepData, WeldAccumulatedImpulses> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties RequiresIncrementalSubstepUpdates Gets whether this constraint type requires incremental updates for each substep taken beyond the first. public static bool RequiresIncrementalSubstepUpdates { get; } Property Value bool Methods IncrementallyUpdateForSubstep(in Vector<float>, in BodyVelocityWide, in BodyVelocityWide, ref WeldPrestepData) public static void IncrementallyUpdateForSubstep(in Vector<float> dt, in BodyVelocityWide wsvA, in BodyVelocityWide wsvB, ref WeldPrestepData prestepData) Parameters dt Vector<float> wsvA BodyVelocityWide wsvB BodyVelocityWide prestepData WeldPrestepData Solve(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, float, float, ref WeldPrestepData, ref WeldAccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void Solve(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, float dt, float inverseDt, ref WeldPrestepData prestep, ref WeldAccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide dt float inverseDt float prestep WeldPrestepData accumulatedImpulses WeldAccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide WarmStart(in Vector3Wide, in QuaternionWide, in BodyInertiaWide, in Vector3Wide, in QuaternionWide, in BodyInertiaWide, ref WeldPrestepData, ref WeldAccumulatedImpulses, ref BodyVelocityWide, ref BodyVelocityWide) public static void WarmStart(in Vector3Wide positionA, in QuaternionWide orientationA, in BodyInertiaWide inertiaA, in Vector3Wide positionB, in QuaternionWide orientationB, in BodyInertiaWide inertiaB, ref WeldPrestepData prestep, ref WeldAccumulatedImpulses accumulatedImpulses, ref BodyVelocityWide wsvA, ref BodyVelocityWide wsvB) Parameters positionA Vector3Wide orientationA QuaternionWide inertiaA BodyInertiaWide positionB Vector3Wide orientationB QuaternionWide inertiaB BodyInertiaWide prestep WeldPrestepData accumulatedImpulses WeldAccumulatedImpulses wsvA BodyVelocityWide wsvB BodyVelocityWide"
  },
  "api/BepuPhysics.Constraints.WeldPrestepData.html": {
    "href": "api/BepuPhysics.Constraints.WeldPrestepData.html",
    "title": "Struct WeldPrestepData | Bepu API",
    "keywords": "Struct WeldPrestepData Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll public struct WeldPrestepData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields LocalOffset public Vector3Wide LocalOffset Field Value Vector3Wide LocalOrientation public QuaternionWide LocalOrientation Field Value QuaternionWide SpringSettings public SpringSettingsWide SpringSettings Field Value SpringSettingsWide"
  },
  "api/BepuPhysics.Constraints.WeldTypeProcessor.html": {
    "href": "api/BepuPhysics.Constraints.WeldTypeProcessor.html",
    "title": "Class WeldTypeProcessor | Bepu API",
    "keywords": "Class WeldTypeProcessor Namespace BepuPhysics.Constraints Assembly BepuPhysics.dll Handles the solve iterations of a bunch of ball socket constraints. public class WeldTypeProcessor : TwoBodyTypeProcessor<WeldPrestepData, WeldAccumulatedImpulses, WeldFunctions, AccessNoPosition, AccessNoPose, AccessAll, AccessAll> Inheritance object TypeProcessor TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses> TwoBodyTypeProcessor<WeldPrestepData, WeldAccumulatedImpulses, WeldFunctions, AccessNoPosition, AccessNoPose, AccessAll, AccessAll> WeldTypeProcessor Inherited Members TwoBodyTypeProcessor<WeldPrestepData, WeldAccumulatedImpulses, WeldFunctions, AccessNoPosition, AccessNoPose, AccessAll, AccessAll>.InternalBodiesPerConstraint TwoBodyTypeProcessor<WeldPrestepData, WeldAccumulatedImpulses, WeldFunctions, AccessNoPosition, AccessNoPose, AccessAll, AccessAll>.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TwoBodyTypeProcessor<WeldPrestepData, WeldAccumulatedImpulses, WeldFunctions, AccessNoPosition, AccessNoPose, AccessAll, AccessAll>.Solve(ref TypeBatch, Bodies, float, float, int, int) TwoBodyTypeProcessor<WeldPrestepData, WeldAccumulatedImpulses, WeldFunctions, AccessNoPosition, AccessNoPose, AccessAll, AccessAll>.RequiresIncrementalSubstepUpdates TwoBodyTypeProcessor<WeldPrestepData, WeldAccumulatedImpulses, WeldFunctions, AccessNoPosition, AccessNoPose, AccessAll, AccessAll>.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.InternalConstrainedDegreesOfFreedom TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.SetBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.AddBodyReferencesLane(ref TwoBodyReferences, int, Span<int>) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.RemoveBodyReferencesLane(ref TwoBodyReferences, int) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.Move(ref TwoBodyReferences, ref WeldPrestepData, ref WeldAccumulatedImpulses, ConstraintHandle, int, ref TwoBodyReferences, ref WeldPrestepData, ref WeldAccumulatedImpulses, ref ConstraintHandle, int, int, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.Resize(ref TypeBatch, int, BufferPool) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.GenerateSortKeysAndCopyReferences<TSortKeyGenerator>(ref TypeBatch, int, int, int, int, int, int, ref int, ref int, ref Buffer<byte>) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.VerifySortRegion<TSortKeyGenerator>(ref TypeBatch, int, int, ref Buffer<int>, ref Buffer<int>) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.BundleShouldIntegrate(int, in IndexSet, out Vector<int>) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.IntegratePoseAndVelocity<TIntegratorCallbacks>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, ref Vector3Wide, ref QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.IntegrateVelocity<TIntegratorCallbacks, TBatchIntegrationMode>(ref TIntegratorCallbacks, ref Vector<int>, in BodyInertiaWide, float, in Vector<int>, in Vector3Wide, in QuaternionWide, ref BodyVelocityWide, int, out BodyInertiaWide) TypeProcessor<TwoBodyReferences, WeldPrestepData, WeldAccumulatedImpulses>.GatherAndIntegrate<TIntegratorCallbacks, TBatchIntegrationMode, TAccessFilter, TShouldIntegratePoses>(Bodies, ref TIntegratorCallbacks, ref Buffer<IndexSet>, int, float, int, int, ref Vector<int>, out Vector3Wide, out QuaternionWide, out BodyVelocityWide, out BodyInertiaWide) TypeProcessor.typeId TypeProcessor.bodiesPerConstraint TypeProcessor.TypeId TypeProcessor.BodiesPerConstraint TypeProcessor.ConstrainedDegreesOfFreedom TypeProcessor.InternalBodiesPerConstraint TypeProcessor.InternalConstrainedDegreesOfFreedom TypeProcessor.Initialize(int) TypeProcessor.AllocateInTypeBatch(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.AllocateInTypeBatchForFallback(ref TypeBatch, ConstraintHandle, Span<int>, BufferPool) TypeProcessor.Remove(ref TypeBatch, int, ref Buffer<ConstraintLocation>, bool) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int) TypeProcessor.TransferConstraint(ref TypeBatch, int, int, Solver, Bodies, int, Span<BodyHandle>, Span<int>) TypeProcessor.ValidateAccumulatedImpulsesSizeInBytes(int) TypeProcessor.EnumerateAccumulatedImpulses<TEnumerator>(ref TypeBatch, int, ref TEnumerator) TypeProcessor.ScaleAccumulatedImpulses(ref TypeBatch, float) TypeProcessor.UpdateForBodyMemoryMove(ref TypeBatch, int, int, int) TypeProcessor.Scramble(ref TypeBatch, Random, ref Buffer<ConstraintLocation>) TypeProcessor.Initialize(ref TypeBatch, int, BufferPool) TypeProcessor.Resize(ref TypeBatch, int, BufferPool) TypeProcessor.WarmStart<TIntegratorCallbacks, TBatchIntegrationMode, TAllowPoseIntegration>(ref TypeBatch, ref Buffer<IndexSet>, Bodies, ref TIntegratorCallbacks, float, float, int, int, int) TypeProcessor.Solve(ref TypeBatch, Bodies, float, float, int, int) TypeProcessor.RequiresIncrementalSubstepUpdates TypeProcessor.IncrementallyUpdateForSubstep(ref TypeBatch, Bodies, float, float, int, int) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BatchTypeId public const int BatchTypeId = 31 Field Value int"
  },
  "api/BepuPhysics.Constraints.html": {
    "href": "api/BepuPhysics.Constraints.html",
    "title": "Namespace BepuPhysics.Constraints | Bepu API",
    "keywords": "Namespace BepuPhysics.Constraints Classes AngularAxisGearMotorTypeProcessor AngularAxisMotorTypeProcessor AngularHingeTypeProcessor AngularMotorTypeProcessor AngularServoTypeProcessor AngularSwivelHingeTypeProcessor AreaConstraintTypeProcessor Handles the solve iterations of a bunch of area constraints. BallSocketMotorTypeProcessor Handles the solve iterations of a bunch of ball socket motor constraints. BallSocketServoTypeProcessor Handles the solve iterations of a bunch of ball socket servo constraints. BallSocketShared Provides shared functionality for constraints with jacobians similar to the BallSocket. BallSocketTypeProcessor Handles the solve iterations of a bunch of ball socket constraints. CenterDistanceLimitTypeProcessor Handles the solve iterations of a bunch of distance servos. CenterDistanceTypeProcessor Handles the solve iterations of a bunch of distance servos. ConstraintChecker DistanceLimitTypeProcessor Handles the solve iterations of a bunch of distance servos. DistanceServoTypeProcessor Handles the solve iterations of a bunch of distance servos. FourBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TWarmStartAccessFilterD, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC, TSolveAccessFilterD> Shared implementation across all four body constraints. HingeTypeProcessor InequalityHelpers LinearAxisLimitTypeProcessor LinearAxisMotorTypeProcessor LinearAxisServoTypeProcessor OneBodyAngularMotorTypeProcessor OneBodyAngularServoTypeProcessor OneBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> OneBodyLinearMotorTypeProcessor OneBodyLinearServoTypeProcessor OneBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TSolveAccessFilterA> Shared implementation across all one body constraints. PointOnLineServoTypeProcessor SwingLimitTypeProcessor SwivelHingeTypeProcessor ThreeBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TWarmStartAccessFilterC, TSolveAccessFilterA, TSolveAccessFilterB, TSolveAccessFilterC> Shared implementation across all three body constraints. TwistLimitTypeProcessor TwistMotorTypeProcessor TwistServoTypeProcessor TwoBodyContactTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions> TwoBodyTypeProcessor<TPrestepData, TAccumulatedImpulse, TConstraintFunctions, TWarmStartAccessFilterA, TWarmStartAccessFilterB, TSolveAccessFilterA, TSolveAccessFilterB> Shared implementation across all two body constraints. TypeProcessor Superclass of constraint type batch processors. Responsible for interpreting raw type batches for the purposes of bookkeeping and solving. TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse> VolumeConstraintTypeProcessor Handles the solve iterations of a bunch of volume constraints. WeldTypeProcessor Handles the solve iterations of a bunch of ball socket constraints. Structs AccessAll Marks all body properties as necessary for gather/scatter. AccessNoInertia Used for kinematic integration; the inertias are known ahead of time and there's no reason to gather them. AccessNoOrientation AccessNoPose AccessNoPosition AccessOnlyAngular AccessOnlyAngularWithoutPose AccessOnlyLinear AccessOnlyVelocity AllowPoseIntegration Marks a batch as integrating poses for any bodies with integration responsibility within the constraint batch. Constraints which need to be updated in response to pose integration will also have their UpdateForNewPose function called. AngularAxisGearMotor Constrains body B's angular velocity around an axis anchored to body A to equal body A's velocity around that axis with a scaling factor applied. AngularAxisGearMotorFunctions AngularAxisGearMotorPrestepData AngularAxisMotor Constrains the relative angular velocity of two bodies around a local axis attached to body A to a target velocity. AngularAxisMotorFunctions AngularAxisMotorPrestepData AngularHinge Angular component of a hinge. Constrains the angular degrees of freedom of two bodies such that they can only rotate relative to each other around the hinge's axis. AngularHingeFunctions AngularHingePrestepData AngularMotor Constrains the relative angular velocity between two bodies to a target. AngularMotorFunctions AngularMotorPrestepData AngularServo Constrains two bodies to have a target relative rotation. AngularServoFunctions AngularServoPrestepData AngularSwivelHinge Constrains two bodies with the angular component of a swivel hinge that allows rotation around two axes, like a laptop monitor hinge that allows flipping the screen. AngularSwivelHingeFunctions AngularSwivelHingePrestepData AreaConstraint Constrains the area of a triangle connecting the centers of three bodies to match a goal area. Scaled volume computed from ||ab x ac||. AreaConstraintFunctions AreaConstraintPrestepData BallSocket Constrains a point on one body to a point on another body. BallSocketFunctions BallSocketMotor Controls the relative linear velocity from the center of body A to an attachment point on body B. BallSocketMotorFunctions BallSocketMotorPrestepData BallSocketPrestepData BallSocketServo Constrains a point on one body to a point on another body. Provides speed and force configuration that the BallSocket joint does not. BallSocketServoFunctions BallSocketServoPrestepData BatchShouldAlwaysIntegrate The batch was determined to have only constraints with integration responsibilities, so there's no need to check. BatchShouldConditionallyIntegrate The batch was determined to have some constraints with integration responsibilities. BatchShouldNeverIntegrate The batch was determined to have no constraints with integration responsibilities, so there's no need to check. CenterDistanceConstraint Constrains the center of two bodies to be separated by a goal distance. CenterDistanceConstraintFunctions CenterDistanceLimit Constrains the center of two bodies to be separated by a distance within a range. CenterDistanceLimitFunctions CenterDistanceLimitPrestepData CenterDistancePrestepData DisallowPoseIntegration Marks a batch as not integrating poses for any bodies within the constraint batch. DistanceLimit Constrains points on two bodies to be separated by a distance within a range. DistanceLimitFunctions DistanceLimitPrestepData DistanceServo Constrains points on two bodies to be separated by a goal distance. DistanceServoFunctions DistanceServoPrestepData FourBodyReferences A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve. Hinge Constrains two bodies with a hinge. Equivalent to a BallSocket constraint and an AngularHinge constraint solved together. HingeAccumulatedImpulses HingeFunctions HingePrestepData LinearAxisLimit Constrains points on two bodies to a range of offsets from each other along a direction anchored to body A. LinearAxisLimitFunctions LinearAxisLimitPrestepData LinearAxisMotor Constrains points on two bodies to move relative to each other along a direction. LinearAxisMotorFunctions LinearAxisMotorPrestepData LinearAxisServo Constrains points on two bodies to be on a plane defined in the local space of one of the bodies. LinearAxisServoFunctions LinearAxisServoFunctions.NoChangeModifier LinearAxisServoPrestepData MotorSettings Defines some of the shared behavior across motor constraints. MotorSettingsWide OneBodyAngularMotor Constrains the angular velocity of one body to the target. OneBodyAngularMotorFunctions OneBodyAngularMotorPrestepData OneBodyAngularServo Constrains a single body to a target orientation. OneBodyAngularServoFunctions OneBodyAngularServoPrestepData OneBodyLinearMotor Constrains a point on a body to have a target linear velocity. OneBodyLinearMotorFunctions OneBodyLinearMotorPrestepData OneBodyLinearServo Constrains a point on a body to a target location. OneBodyLinearServoFunctions OneBodyLinearServoPrestepData PointOnLineServo Constrains a point on body B to be on a line attached to body A. PointOnLineServoFunctions PointOnLineServoPrestepData ServoSettings Describes how a quickly and strongly a servo constraint should move towards a position target. ServoSettingsWide SpringSettings SpringSettingsWide SwingLimit Restricts axes attached to two bodies to fall within a maximum swing angle. SwingLimitFunctions SwingLimitPrestepData SwivelHinge Constrains two bodies with a swivel hinge that allows rotation around two axes, like a laptop monitor hinge that allows flipping the screen. Equivalent to a BallSocket constraint and an AngularSwivelHinge constraint solved together. SwivelHingeFunctions SwivelHingePrestepData ThreeBodyReferences A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve. TwistLimit Constrains two bodies' rotations around attached twist axes to a range of permitted twist angles. TwistLimitFunctions TwistLimitPrestepData TwistMotor Constrains the twist velocity between two bodies to a target. TwistMotorFunctions TwistMotorPrestepData TwistServo Constrains two bodies to maintain a target twist angle around body-attached axes. TwistServoFunctions TwistServoPrestepData TwoBodyReferences A constraint's body references. Stored separately from the iteration data since it is accessed by both the prestep and solve. Two address streams isn't much of a problem for prefetching. TypeBatch Stores the raw AOSOA formatted data associated with constraints in a type batch. VolumeConstraint Constrains the volume of a tetrahedron connecting the centers of four bodies to match a goal volume. Scaled volume computed from (ab x ac) * ad; the volume may be negative depending on the winding of the tetrahedron. VolumeConstraintFunctions VolumeConstraintPrestepData Weld Constrains two bodies to maintain a relative position and orientation. All six degrees of freedom are solved simultaneously. WeldAccumulatedImpulses WeldFunctions WeldPrestepData Interfaces IBatchIntegrationMode Marks a type as determining the integration mode for a solver batch. IBatchPoseIntegrationAllowed Marks a type as determining whether pose integration should be performed on bodies within the constraint batch. IBodyAccessFilter Constrains which body properties should be accessed in a body during constraint data gathering/scattering. IConstraintDescription<TDescription> Marks a type as a description of a constraint associated with a particular batch. IFourBodyConstraintDescription<TDescription> Marks a type as a four body constraint description. IFourBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Prestep, warm start and solve iteration functions for a four body constraint type. IOneBodyConstraintDescription<TDescription> Marks a type as a one body constraint description. IOneBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Prestep, warm start and solve iteration functions for a constraint type. ISortKeyGenerator<TBodyReferences> Defines a function that creates a sort key from body references in a type batch. Used by constraint layout optimization. IThreeBodyConstraintDescription<TDescription> Marks a type as a three body constraint description. IThreeBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Prestep, warm start and solve iteration functions for a three body constraint type. ITwoBodyConstraintDescription<TDescription> Marks a type as a two body constraint description. ITwoBodyConstraintFunctions<TPrestepData, TAccumulatedImpulse> Prestep, warm start and solve iteration functions for a two body constraint type. LinearAxisServoFunctions.IJacobianModifier Enums TypeProcessor<TBodyReferences, TPrestepData, TAccumulatedImpulse>.BundleIntegrationMode"
  },
  "api/BepuPhysics.DefaultTimestepper.html": {
    "href": "api/BepuPhysics.DefaultTimestepper.html",
    "title": "Class DefaultTimestepper | Bepu API",
    "keywords": "Class DefaultTimestepper Namespace BepuPhysics Assembly BepuPhysics.dll Updates the simulation in the order of: sleeper -> predict body bounding boxes -> collision detection -> substepping solve -> data structure optimization. Each substep of the solve simulates and integrates a sub-timestep of length dt/substepCount. public class DefaultTimestepper : ITimestepper Inheritance object DefaultTimestepper Implements ITimestepper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Timestep(Simulation, float, IThreadDispatcher) Performs one timestep of the given length. public void Timestep(Simulation simulation, float dt, IThreadDispatcher threadDispatcher = null) Parameters simulation Simulation Simulation to be stepped forward in time. dt float Duration of the time step. threadDispatcher IThreadDispatcher Thread dispatcher to use for execution, if any. Events BeforeCollisionDetection Fires after bodies have their bounding boxes updated for the frame's predicted motion and before collision detection. public event TimestepperStageHandler BeforeCollisionDetection Event Type TimestepperStageHandler CollisionsDetected Fires after all collisions have been identified, but before the substep loop begins. public event TimestepperStageHandler CollisionsDetected Event Type TimestepperStageHandler ConstraintsSolved Fires after the solver executes and before the final integration step. public event TimestepperStageHandler ConstraintsSolved Event Type TimestepperStageHandler Slept Fires after the sleeper completes and before bodies are integrated. public event TimestepperStageHandler Slept Event Type TimestepperStageHandler"
  },
  "api/BepuPhysics.DefaultTypes.html": {
    "href": "api/BepuPhysics.DefaultTypes.html",
    "title": "Class DefaultTypes | Bepu API",
    "keywords": "Class DefaultTypes Namespace BepuPhysics Assembly BepuPhysics.dll Helper class to register the default types within a simulation instance. public static class DefaultTypes Inheritance object DefaultTypes Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CreateDefaultCollisionTaskRegistry() Creates a task registry containing the default collision pair types. public static CollisionTaskRegistry CreateDefaultCollisionTaskRegistry() Returns CollisionTaskRegistry CreateDefaultSweepTaskRegistry() Creates a task registry containing the default sweep task types. public static SweepTaskRegistry CreateDefaultSweepTaskRegistry() Returns SweepTaskRegistry RegisterDefaults(Solver, NarrowPhase) Registers the set of constraints that are packaged in the engine. public static void RegisterDefaults(Solver solver, NarrowPhase narrowPhase) Parameters solver Solver narrowPhase NarrowPhase"
  },
  "api/BepuPhysics.FloatCollector.html": {
    "href": "api/BepuPhysics.FloatCollector.html",
    "title": "Struct FloatCollector | Bepu API",
    "keywords": "Struct FloatCollector Namespace BepuPhysics Assembly BepuPhysics.dll public struct FloatCollector : IForEach<float> Implements IForEach<float> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors FloatCollector(float*) public FloatCollector(float* values) Parameters values float* Fields Index public int Index Field Value int Values public float* Values Field Value float* Methods LoopBody(float) public void LoopBody(float value) Parameters value float"
  },
  "api/BepuPhysics.HashDiagnosticType.html": {
    "href": "api/BepuPhysics.HashDiagnosticType.html",
    "title": "Enum HashDiagnosticType | Bepu API",
    "keywords": "Enum HashDiagnosticType Namespace BepuPhysics Assembly BepuPhysics.dll Hardcoded hash types used by invasive hash diagnostics. public enum HashDiagnosticType Fields AddSleepingToActiveForFallback = 22 AddToSimulationSpeculative = 33 AddToSimulationSpeculativeFallbackSolverReferences = 34 AllocateInBatch = 44 AllocateInTypeBatchForFallback = 42 AllocateInTypeBatchForFallbackProbes = 43 AwakeBodyCollidableStates0 = 11 AwakeBodyCollidableStates1 = 12 AwakeBodyCollidableStates10 = 21 AwakeBodyCollidableStates2 = 13 AwakeBodyCollidableStates3 = 14 AwakeBodyCollidableStates4 = 15 AwakeBodyCollidableStates5 = 16 AwakeBodyCollidableStates6 = 17 AwakeBodyCollidableStates7 = 18 AwakeBodyCollidableStates8 = 19 AwakeBodyCollidableStates9 = 20 AwakeBodyStates0 = 0 AwakeBodyStates1 = 1 AwakeBodyStates10 = 10 AwakeBodyStates2 = 2 AwakeBodyStates3 = 3 AwakeBodyStates4 = 4 AwakeBodyStates5 = 5 AwakeBodyStates6 = 6 AwakeBodyStates7 = 7 AwakeBodyStates8 = 8 AwakeBodyStates9 = 9 DeterministicConstraintAdd = 32 EnqueueStaleRemoval = 35 PreflushJobs = 41 RemoveConstraintsFromBatchReferencedHandles = 37 RemoveConstraintsFromBodyLists = 38 RemoveConstraintsFromFallbackBatchReferencedHandles = 36 RemoveConstraintsFromTypeBatch = 39 ReturnConstraintHandles = 40 SolverBodyReferenceAfterPreflush = 28 SolverBodyReferenceAfterPreflushPhase1 = 25 SolverBodyReferenceAfterPreflushPhase2 = 26 SolverBodyReferenceAfterPreflushPhase3 = 27 SolverBodyReferenceAfterSolver = 30 SolverBodyReferenceAtEnd = 31 SolverBodyReferenceBeforeCollisionDetection = 23 SolverBodyReferenceBeforePreflush = 24 SolverBodyReferenceBeforeSolver = 29 TypeProcessorRemove = 45"
  },
  "api/BepuPhysics.Helpers.html": {
    "href": "api/BepuPhysics.Helpers.html",
    "title": "Class Helpers | Bepu API",
    "keywords": "Class Helpers Namespace BepuPhysics Assembly BepuPhysics.dll Shared miscellaneous helper functions. public static class Helpers Inheritance object Helpers Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods BuildOrthonormalBasis(in Vector3Wide, out Vector3Wide, out Vector3Wide) public static void BuildOrthonormalBasis(in Vector3Wide normal, out Vector3Wide t1, out Vector3Wide t2) Parameters normal Vector3Wide t1 Vector3Wide t2 Vector3Wide BuildOrthonormalBasis(Vector3, out Vector3, out Vector3) public static void BuildOrthonormalBasis(Vector3 normal, out Vector3 t1, out Vector3 t2) Parameters normal Vector3 t1 Vector3 t2 Vector3 FillVectorWithLaneIndices(out Vector<int>) public static void FillVectorWithLaneIndices(out Vector<int> indices) Parameters indices Vector<int> FindPerpendicular(in Vector3Wide, out Vector3Wide) public static void FindPerpendicular(in Vector3Wide normal, out Vector3Wide perpendicular) Parameters normal Vector3Wide perpendicular Vector3Wide Swap<T>(ref T, ref T) public static void Swap<T>(ref T a, ref T b) Parameters a T b T Type Parameters T"
  },
  "api/BepuPhysics.IPoseIntegrator.html": {
    "href": "api/BepuPhysics.IPoseIntegrator.html",
    "title": "Interface IPoseIntegrator | Bepu API",
    "keywords": "Interface IPoseIntegrator Namespace BepuPhysics Assembly BepuPhysics.dll public interface IPoseIntegrator Methods IntegrateAfterSubstepping(IndexSet, float, int, IThreadDispatcher) void IntegrateAfterSubstepping(IndexSet constrainedBodies, float dt, int substepCount, IThreadDispatcher threadDispatcher = null) Parameters constrainedBodies IndexSet dt float substepCount int threadDispatcher IThreadDispatcher PredictBoundingBoxes(float, BufferPool, IThreadDispatcher) void PredictBoundingBoxes(float dt, BufferPool pool, IThreadDispatcher threadDispatcher = null) Parameters dt float pool BufferPool threadDispatcher IThreadDispatcher"
  },
  "api/BepuPhysics.IPoseIntegratorCallbacks.html": {
    "href": "api/BepuPhysics.IPoseIntegratorCallbacks.html",
    "title": "Interface IPoseIntegratorCallbacks | Bepu API",
    "keywords": "Interface IPoseIntegratorCallbacks Namespace BepuPhysics Assembly BepuPhysics.dll Defines a type that handles callbacks for body pose integration. public interface IPoseIntegratorCallbacks Properties AllowSubstepsForUnconstrainedBodies Gets whether the integrator should use only one step for unconstrained bodies when using a substepping solver. If true, unconstrained bodies use a single step of length equal to the dt provided to Timestep(float, IThreadDispatcher). If false, unconstrained bodies will be integrated with the same number of substeps as the constrained bodies in the solver. bool AllowSubstepsForUnconstrainedBodies { get; } Property Value bool AngularIntegrationMode Gets how the pose integrator should handle angular velocity integration. AngularIntegrationMode AngularIntegrationMode { get; } Property Value AngularIntegrationMode IntegrateVelocityForKinematics Gets whether the velocity integration callback should be called for kinematic bodies. If true, IntegrateVelocity(Vector<int>, Vector3Wide, QuaternionWide, BodyInertiaWide, Vector<int>, int, Vector<float>, ref BodyVelocityWide) will be called for bundles including kinematic bodies. If false, kinematic bodies will just continue using whatever velocity they have set. Most use cases should set this to false. bool IntegrateVelocityForKinematics { get; } Property Value bool Methods Initialize(Simulation) Performs any required initialization logic after the Simulation instance has been constructed. void Initialize(Simulation simulation) Parameters simulation Simulation Simulation that owns these callbacks. IntegrateVelocity(Vector<int>, Vector3Wide, QuaternionWide, BodyInertiaWide, Vector<int>, int, Vector<float>, ref BodyVelocityWide) Callback for a bundle of bodies being integrated. void IntegrateVelocity(Vector<int> bodyIndices, Vector3Wide position, QuaternionWide orientation, BodyInertiaWide localInertia, Vector<int> integrationMask, int workerIndex, Vector<float> dt, ref BodyVelocityWide velocity) Parameters bodyIndices Vector<int> Indices of the bodies being integrated in this bundle. position Vector3Wide Current body positions. orientation QuaternionWide Current body orientations. localInertia BodyInertiaWide Body's current local inertia. integrationMask Vector<int> Mask indicating which lanes are active in the bundle. Active lanes will contain 0xFFFFFFFF, inactive lanes will contain 0. workerIndex int Index of the worker thread processing this bundle. dt Vector<float> Durations to integrate the velocity over. Can vary over lanes. velocity BodyVelocityWide Velocity of bodies in the bundle. Any changes to lanes which are not active by the integrationMask will be discarded. PrepareForIntegration(float) Callback invoked ahead of dispatches that may call into IntegrateVelocity(Vector<int>, Vector3Wide, QuaternionWide, BodyInertiaWide, Vector<int>, int, Vector<float>, ref BodyVelocityWide). It may be called more than once with different values over a frame. For example, when performing bounding box prediction, velocity is integrated with a full frame time step duration. During substepped solves, integration is split into substepCount steps, each with fullFrameDuration / substepCount duration. The final integration pass for unconstrained bodies may be either fullFrameDuration or fullFrameDuration / substepCount, depending on the value of AllowSubstepsForUnconstrainedBodies. void PrepareForIntegration(float dt) Parameters dt float Current integration time step duration. Remarks This is typically used for precomputing anything expensive that will be used across velocity integration."
  },
  "api/BepuPhysics.IRayHitHandler.html": {
    "href": "api/BepuPhysics.IRayHitHandler.html",
    "title": "Interface IRayHitHandler | Bepu API",
    "keywords": "Interface IRayHitHandler Namespace BepuPhysics Assembly BepuPhysics.dll Defines a type capable of filtering ray test candidates and handling ray hit results. public interface IRayHitHandler Methods AllowTest(CollidableReference) Checks whether a collidable identified by the acceleration structure should be tested against a ray. bool AllowTest(CollidableReference collidable) Parameters collidable CollidableReference Candidate collidable for ray testing. Returns bool True if the collidable should be tested by the ray, false otherwise. AllowTest(CollidableReference, int) Checks whether the child of a collidable should be tested against a ray. Only called by shape types that can have more than one child. bool AllowTest(CollidableReference collidable, int childIndex) Parameters collidable CollidableReference Parent of the candidate. childIndex int Index of the candidate child in its parent collidable. For compounds, this is the index of the child in the child array. For meshes, this is the triangle index. For convex shapes or other types that don't have multiple children, this is always zero. Returns bool True if the child should be tested by the ray, false otherwise. OnRayHit(in RayData, ref float, float, Vector3, CollidableReference, int) Called when a ray impact has been found. void OnRayHit(in RayData ray, ref float maximumT, float t, Vector3 normal, CollidableReference collidable, int childIndex) Parameters ray RayData Information about the ray associated with this hit. maximumT float Maximum distance along the ray that the traversal is allowed to go in units of ray direction length. Can be set to limit future tests. t float Distance along the ray to the impact in units of ray direction length. In other words, hitLocation = ray.Origin + ray.Direction * t. normal Vector3 Surface normal at the hit location. collidable CollidableReference Collidable hit by the ray. childIndex int Index of the hit child in its parent collidable. For compounds, this is the index of the child in the child array. For meshes, this is the triangle index. For convex shapes or other types that don't have multiple children, this is always zero."
  },
  "api/BepuPhysics.IShapeRayHitHandler.html": {
    "href": "api/BepuPhysics.IShapeRayHitHandler.html",
    "title": "Interface IShapeRayHitHandler | Bepu API",
    "keywords": "Interface IShapeRayHitHandler Namespace BepuPhysics Assembly BepuPhysics.dll public interface IShapeRayHitHandler Methods AllowTest(int) Checks whether the child of a collidable should be tested against a ray. Only called by shape types that can have more than one child. bool AllowTest(int childIndex) Parameters childIndex int Index of the candidate in the parent collidable. For compounds, this is the index of the child in the child array. For meshes, this is the triangle index. For convex shapes or other types that don't have multiple children, this is always zero. Returns bool True if the child should be tested by the ray, false otherwise. OnRayHit(in RayData, ref float, float, Vector3, int) Called when a ray impact has been found. void OnRayHit(in RayData ray, ref float maximumT, float t, Vector3 normal, int childIndex) Parameters ray RayData Information about the ray associated with this hit. maximumT float Maximum distance along the ray that the traversal is allowed to go in units of ray direction length. Can be set to limit future tests. t float Distance along the ray to the impact in units of ray direction length. In other words, hitLocation = ray.Origin + ray.Direction * t. normal Vector3 Surface normal at the hit location. childIndex int Index of the hit child. For compounds, this is the index of the child in the child array. For meshes, this is the triangle index. For convex shapes or other types that don't have multiple children, this is always zero."
  },
  "api/BepuPhysics.IStaticChangeAwakeningFilter.html": {
    "href": "api/BepuPhysics.IStaticChangeAwakeningFilter.html",
    "title": "Interface IStaticChangeAwakeningFilter | Bepu API",
    "keywords": "Interface IStaticChangeAwakeningFilter Namespace BepuPhysics Assembly BepuPhysics.dll Defines a type that determines which bodies should be awoken in the bounding box of a static when the static's state changes. public interface IStaticChangeAwakeningFilter Remarks We cannot find bodies depending on a static through constraints, since statics do not maintain constraint lists. When a static is added, removed, has SetShape or has ApplyDescription called on it, it looks up bodies in its bounding box that could possibly be affected by change and considers waking them up. This filter can be used to ignore some bodies. Properties AllowAwakening Gets whether to allow awakening for any body. If true, candidates will have the ShouldAwaken function called for them. If false, ShouldAwaken will not be called, and no bodies will be awoken. bool AllowAwakening { get; } Property Value bool Methods ShouldAwaken(BodyReference) Determines whether a body should be forced awake by the state change of a static. bool ShouldAwaken(BodyReference body) Parameters body BodyReference Sleeping body under consideration for awakening. Returns bool True if the body should be forced awake, false otherwise."
  },
  "api/BepuPhysics.ISweepHitHandler.html": {
    "href": "api/BepuPhysics.ISweepHitHandler.html",
    "title": "Interface ISweepHitHandler | Bepu API",
    "keywords": "Interface ISweepHitHandler Namespace BepuPhysics Assembly BepuPhysics.dll Defines a type capable of filtering sweep candidates and handling sweep results. public interface ISweepHitHandler Methods AllowTest(CollidableReference) Checks whether to run a detailed sweep test against a target collidable. bool AllowTest(CollidableReference collidable) Parameters collidable CollidableReference Collidable to check. Returns bool True if the sweep test should be attempted, false otherwise. AllowTest(CollidableReference, int) Checks whether to run a detailed sweep test against a target collidable's child. bool AllowTest(CollidableReference collidable, int childIndex) Parameters collidable CollidableReference Collidable to check. childIndex int Index of the child in the collidable to check. For compounds, this is the index of the child in the child array. For meshes, this is the triangle index. For convex shapes or other types that don't have multiple children, this is always zero. Returns bool True if the sweep test should be attempted, false otherwise. OnHit(ref float, float, Vector3, Vector3, CollidableReference) Called when a sweep test detects a hit with nonzero T value. void OnHit(ref float maximumT, float t, Vector3 hitLocation, Vector3 hitNormal, CollidableReference collidable) Parameters maximumT float Reference to maximumT passed to the traversal. t float Time of impact for the sweep test. hitLocation Vector3 Location of the first hit detected by the sweep. hitNormal Vector3 Surface normal at the hit location. collidable CollidableReference Collidable hit by the traversal. OnHitAtZeroT(ref float, CollidableReference) Called when a sweep test detects a hit at T = 0, meaning that no location or normal can be computed. void OnHitAtZeroT(ref float maximumT, CollidableReference collidable) Parameters maximumT float Reference to maximumT passed to the traversal. collidable CollidableReference Collidable hit by the traversal."
  },
  "api/BepuPhysics.ITimestepper.html": {
    "href": "api/BepuPhysics.ITimestepper.html",
    "title": "Interface ITimestepper | Bepu API",
    "keywords": "Interface ITimestepper Namespace BepuPhysics Assembly BepuPhysics.dll Defines a type capable of updating the simulation state for a given elapsed time. public interface ITimestepper Methods Timestep(Simulation, float, IThreadDispatcher) Performs one timestep of the given length. void Timestep(Simulation simulation, float dt, IThreadDispatcher threadDispatcher = null) Parameters simulation Simulation Simulation to be stepped forward in time. dt float Duration of the time step. threadDispatcher IThreadDispatcher Thread dispatcher to use for execution, if any. Events BeforeCollisionDetection Callbacks to execute immediately before collision detection executes. event TimestepperStageHandler BeforeCollisionDetection Event Type TimestepperStageHandler CollisionsDetected Callbacks to execute after collision detection completes. event TimestepperStageHandler CollisionsDetected Event Type TimestepperStageHandler"
  },
  "api/BepuPhysics.InvasiveHashDiagnostics.html": {
    "href": "api/BepuPhysics.InvasiveHashDiagnostics.html",
    "title": "Class InvasiveHashDiagnostics | Bepu API",
    "keywords": "Class InvasiveHashDiagnostics Namespace BepuPhysics Assembly BepuPhysics.dll Helper diagnostics class for monitoring internal state determinism across runs. Typically used by inserting tests into engine internals. public class InvasiveHashDiagnostics Inheritance object InvasiveHashDiagnostics Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields CurrentHashIndex public int CurrentHashIndex Field Value int CurrentRunIndex public int CurrentRunIndex Field Value int Hashes public int[][][] Hashes Field Value int[][][] Instance public static InvasiveHashDiagnostics Instance Field Value InvasiveHashDiagnostics Methods ContributeToHash(HashDiagnosticType, int) public void ContributeToHash(HashDiagnosticType hashType, int value) Parameters hashType HashDiagnosticType value int ContributeToHash(ref int, int) public void ContributeToHash(ref int hash, int value) Parameters hash int value int ContributeToHash<T>(HashDiagnosticType, T) public void ContributeToHash<T>(HashDiagnosticType hashType, T value) where T : unmanaged Parameters hashType HashDiagnosticType value T Type Parameters T ContributeToHash<T>(ref int, T) public void ContributeToHash<T>(ref int hash, T value) where T : unmanaged Parameters hash int value T Type Parameters T GetHashForType(HashDiagnosticType) public ref int GetHashForType(HashDiagnosticType hashType) Parameters hashType HashDiagnosticType Returns int Initialize(int, int) public static void Initialize(int runCount, int hashCapacityPerType) Parameters runCount int hashCapacityPerType int MoveToNextHashFrame() public void MoveToNextHashFrame() MoveToNextRun() public void MoveToNextRun() TypeIsActive(HashDiagnosticType) public bool TypeIsActive(HashDiagnosticType hashType) Parameters hashType HashDiagnosticType Returns bool"
  },
  "api/BepuPhysics.IslandAwakener.html": {
    "href": "api/BepuPhysics.IslandAwakener.html",
    "title": "Class IslandAwakener | Bepu API",
    "keywords": "Class IslandAwakener Namespace BepuPhysics Assembly BepuPhysics.dll Provides functionality for efficiently waking up sleeping bodies. public class IslandAwakener Inheritance object IslandAwakener Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors IslandAwakener(Bodies, Statics, Solver, BroadPhase, IslandSleeper, BufferPool) public IslandAwakener(Bodies bodies, Statics statics, Solver solver, BroadPhase broadPhase, IslandSleeper sleeper, BufferPool pool) Parameters bodies Bodies statics Statics solver Solver broadPhase BroadPhase sleeper IslandSleeper pool BufferPool Methods AwakenBody(BodyHandle) Wakes up a body if it is sleeping. All bodies that can be found by traversing the constraint graph from the body will also be awakened. If the body is already awake, this does nothing. public void AwakenBody(BodyHandle bodyHandle) Parameters bodyHandle BodyHandle Handle of the body to awaken. AwakenConstraint(ConstraintHandle) Wakes up any sleeping bodies associated with a constraint. All bodies that can be found by traversing the constraint graph from the constraint referenced bodies will also be awakened. If all bodies associated with the constraint are already awake, this does nothing. public void AwakenConstraint(ConstraintHandle constraintHandle) Parameters constraintHandle ConstraintHandle Handle of the constraint to awaken. AwakenSet(int) Wakes up all bodies and constraints within a set. Doesn't do anything if the set is awake (index zero). public void AwakenSet(int setIndex) Parameters setIndex int Index of the set to awaken. AwakenSets(ref QuickList<int>, IThreadDispatcher) Awakens a list of set indices. public void AwakenSets(ref QuickList<int> setIndices, IThreadDispatcher threadDispatcher = null) Parameters setIndices QuickList<int> List of set indices to wake up. threadDispatcher IThreadDispatcher Thread dispatcher to use when waking the bodies. Pass null to run on a single thread."
  },
  "api/BepuPhysics.IslandSleeper.html": {
    "href": "api/BepuPhysics.IslandSleeper.html",
    "title": "Class IslandSleeper | Bepu API",
    "keywords": "Class IslandSleeper Namespace BepuPhysics Assembly BepuPhysics.dll public class IslandSleeper Inheritance object IslandSleeper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors IslandSleeper(Bodies, Solver, BroadPhase, ConstraintRemover, BufferPool) public IslandSleeper(Bodies bodies, Solver solver, BroadPhase broadPhase, ConstraintRemover constraintRemover, BufferPool pool) Parameters bodies Bodies solver Solver broadPhase BroadPhase constraintRemover ConstraintRemover pool BufferPool Properties InitialIslandBodyCapacity public int InitialIslandBodyCapacity { get; set; } Property Value int InitialIslandConstraintCapacity public int InitialIslandConstraintCapacity { get; set; } Property Value int TargetSleptFraction Gets or sets the fraction of the active set to target as the number of bodies slept in a given frame. This is only a goal; the actual number of slept bodies may be more or less. public float TargetSleptFraction { get; set; } Property Value float TargetTraversedFraction Gets or sets the fraction of the active set to target as the number of bodies traversed for sleeping in a given frame. This is only a goal; the actual number of traversed bodies may be more or less. public float TargetTraversedFraction { get; set; } Property Value float TestedFractionPerFrame Gets or sets the multiplier applied to the active body count used to calculate the number of sleep traversals in a given timestep. public float TestedFractionPerFrame { get; set; } Property Value float Methods Clear() public void Clear() CollectIsland<TTraversalPredicate>(BufferPool, int, ref TTraversalPredicate, ref QuickList<int>, ref QuickList<ConstraintHandle>) Traverses the active constraint graph collecting bodies that match a predicate. If any body visited during the traversal fails to match the predicate, the traversal terminates. public bool CollectIsland<TTraversalPredicate>(BufferPool pool, int startingActiveBodyIndex, ref TTraversalPredicate predicate, ref QuickList<int> bodyIndices, ref QuickList<ConstraintHandle> constraintHandles) where TTraversalPredicate : IPredicate<int> Parameters pool BufferPool Pool to allocate temporary collections from. startingActiveBodyIndex int Index of the active body to start the traversal at. predicate TTraversalPredicate Predicate to test each traversed body with. If any body results in the predicate returning false, the traversal stops and the function returns false. bodyIndices QuickList<int> List to fill with body indices traversed during island collection. Bodies failing the predicate will not be included. constraintHandles QuickList<ConstraintHandle> List to fill with constraint handles traversed during island collection. Returns bool True if the simulation graph was traversed without ever finding a body that made the predicate return false. False if any body failed the predicate. The bodyIndices and constraintHandles lists will contain all traversed predicate-passing bodies and constraints. Type Parameters TTraversalPredicate Type of the predicate to test each body index with. Dispose() public void Dispose() EnsureSetsCapacity(int) Ensures that the Bodies, Solver, and NarrowPhase can hold at least the given number of sets (BodySets for the Bodies collection, ConstraintSets for the Solver, PairSubcaches for the NarrowPhase.PairCache). public void EnsureSetsCapacity(int setsCapacity) Parameters setsCapacity int Number of sets to guarantee space for. ResizeSetsCapacity(int) Ensures that the Bodies and Solver can hold the given number of sets. If the existing allocation is smaller than the requested sets capacity, the allocation will be enlarged. If the existing allocation is larger than both the existing potentially allocated set range and the requested sets capacity, the allocation will be shrunk. Shrinks will never cause an existing set to be lost. public void ResizeSetsCapacity(int setsCapacity) Parameters setsCapacity int Target number of sets to allocate space for. Sleep(ref QuickList<int>, IThreadDispatcher, bool) Forcefully sleeps a list of bodies and all bodies that can be reached by traversing the constraint graph from those bodies. public void Sleep(ref QuickList<int> bodyIndices, IThreadDispatcher threadDispatcher = null, bool deterministic = false) Parameters bodyIndices QuickList<int> List of body indices to sleep. threadDispatcher IThreadDispatcher Thread dispatcher to use for the sleep attempt, if any. If null, sleep is performed on the calling thread. deterministic bool True if the sleep should produce deterministic results at higher cost, false otherwise. Sleep(int) Forces a body and all bodies that can be found by traversing the constraint graph from that body to go to sleep. public void Sleep(int bodyIndex) Parameters bodyIndex int Index of the body to sleep in the active set."
  },
  "api/BepuPhysics.MotionState.html": {
    "href": "api/BepuPhysics.MotionState.html",
    "title": "Struct MotionState | Bepu API",
    "keywords": "Struct MotionState Namespace BepuPhysics Assembly BepuPhysics.dll Describes the pose and velocity of a body. public struct MotionState Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Pose Pose of the body. public RigidPose Pose Field Value RigidPose Velocity Linear and angular velocity of the body. public BodyVelocity Velocity Field Value BodyVelocity Methods ToString() Returns a string representing the MotionState. public override string ToString() Returns string String representing the MotionState."
  },
  "api/BepuPhysics.PassthroughReferenceCollector.html": {
    "href": "api/BepuPhysics.PassthroughReferenceCollector.html",
    "title": "Struct PassthroughReferenceCollector | Bepu API",
    "keywords": "Struct PassthroughReferenceCollector Namespace BepuPhysics Assembly BepuPhysics.dll Directly reports references as provided by whatever is being enumerated. For example, when used directly with the TypeProcessor's EnumerateConnectedRawBodyReferences, if the constraint is active, this will report encoded body indices. If the constraint is sleeping, this will report body handles. If used with an enumerator that does filtering, the filtered results will be reported unmodified. public struct PassthroughReferenceCollector : IForEach<int> Implements IForEach<int> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors PassthroughReferenceCollector(int*) public PassthroughReferenceCollector(int* references) Parameters references int* Fields Index public int Index Field Value int References public int* References Field Value int* Methods LoopBody(int) public void LoopBody(int reference) Parameters reference int"
  },
  "api/BepuPhysics.PoseIntegration.html": {
    "href": "api/BepuPhysics.PoseIntegration.html",
    "title": "Class PoseIntegration | Bepu API",
    "keywords": "Class PoseIntegration Namespace BepuPhysics Assembly BepuPhysics.dll Provides helper functions for integrating body poses. public static class PoseIntegration Inheritance object PoseIntegration Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Integrate(in RigidPose, in BodyVelocity, float, out RigidPose) public static void Integrate(in RigidPose pose, in BodyVelocity velocity, float dt, out RigidPose integratedPose) Parameters pose RigidPose velocity BodyVelocity dt float integratedPose RigidPose Integrate(in QuaternionWide, in Vector3Wide, in Vector<float>, out QuaternionWide) public static void Integrate(in QuaternionWide start, in Vector3Wide angularVelocity, in Vector<float> halfDt, out QuaternionWide integrated) Parameters start QuaternionWide angularVelocity Vector3Wide halfDt Vector<float> integrated QuaternionWide Integrate(Quaternion, Vector3, float, out Quaternion) public static void Integrate(Quaternion orientation, Vector3 angularVelocity, float dt, out Quaternion integratedOrientation) Parameters orientation Quaternion angularVelocity Vector3 dt float integratedOrientation Quaternion Integrate(Vector3, Vector3, float, out Vector3) public static void Integrate(Vector3 position, Vector3 linearVelocity, float dt, out Vector3 integratedPosition) Parameters position Vector3 linearVelocity Vector3 dt float integratedPosition Vector3 IntegrateAngularVelocityConserveMomentum(in QuaternionWide, in Symmetric3x3Wide, in Symmetric3x3Wide, ref Vector3Wide) public static void IntegrateAngularVelocityConserveMomentum(in QuaternionWide previousOrientation, in Symmetric3x3Wide localInverseInertia, in Symmetric3x3Wide worldInverseInertia, ref Vector3Wide angularVelocity) Parameters previousOrientation QuaternionWide localInverseInertia Symmetric3x3Wide worldInverseInertia Symmetric3x3Wide angularVelocity Vector3Wide IntegrateAngularVelocityConserveMomentumWithGyroscopicTorque(in QuaternionWide, in Symmetric3x3Wide, ref Vector3Wide, in Vector<float>) public static void IntegrateAngularVelocityConserveMomentumWithGyroscopicTorque(in QuaternionWide orientation, in Symmetric3x3Wide localInverseInertia, ref Vector3Wide angularVelocity, in Vector<float> dt) Parameters orientation QuaternionWide localInverseInertia Symmetric3x3Wide angularVelocity Vector3Wide dt Vector<float> RotateInverseInertia(in Symmetric3x3, Quaternion, out Symmetric3x3) public static void RotateInverseInertia(in Symmetric3x3 localInverseInertiaTensor, Quaternion orientation, out Symmetric3x3 rotatedInverseInertiaTensor) Parameters localInverseInertiaTensor Symmetric3x3 orientation Quaternion rotatedInverseInertiaTensor Symmetric3x3 RotateInverseInertia(in Symmetric3x3Wide, in QuaternionWide, out Symmetric3x3Wide) public static void RotateInverseInertia(in Symmetric3x3Wide localInverseInertiaTensor, in QuaternionWide orientation, out Symmetric3x3Wide rotatedInverseInertiaTensor) Parameters localInverseInertiaTensor Symmetric3x3Wide orientation QuaternionWide rotatedInverseInertiaTensor Symmetric3x3Wide"
  },
  "api/BepuPhysics.PoseIntegrator-1.html": {
    "href": "api/BepuPhysics.PoseIntegrator-1.html",
    "title": "Class PoseIntegrator<TCallbacks> | Bepu API",
    "keywords": "Class PoseIntegrator<TCallbacks> Namespace BepuPhysics Assembly BepuPhysics.dll Handles body integration work that isn't bundled into the solver's execution. Predicts bounding boxes, integrates velocity and poses for unconstrained bodies, and does final post-substepping pose integration for constrained bodies. public class PoseIntegrator<TCallbacks> : IPoseIntegrator where TCallbacks : IPoseIntegratorCallbacks Type Parameters TCallbacks Inheritance object PoseIntegrator<TCallbacks> Implements IPoseIntegrator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PoseIntegrator(Bodies, Shapes, BroadPhase, TCallbacks) public PoseIntegrator(Bodies bodies, Shapes shapes, BroadPhase broadPhase, TCallbacks callbacks) Parameters bodies Bodies shapes Shapes broadPhase BroadPhase callbacks TCallbacks Fields Callbacks public TCallbacks Callbacks Field Value TCallbacks Methods IntegrateAfterSubstepping(IndexSet, float, int, IThreadDispatcher) public void IntegrateAfterSubstepping(IndexSet constrainedBodies, float dt, int substepCount, IThreadDispatcher threadDispatcher) Parameters constrainedBodies IndexSet dt float substepCount int threadDispatcher IThreadDispatcher PredictBoundingBoxes(float, BufferPool, IThreadDispatcher) public void PredictBoundingBoxes(float dt, BufferPool pool, IThreadDispatcher threadDispatcher = null) Parameters dt float pool BufferPool threadDispatcher IThreadDispatcher"
  },
  "api/BepuPhysics.RigidPose.html": {
    "href": "api/BepuPhysics.RigidPose.html",
    "title": "Struct RigidPose | Bepu API",
    "keywords": "Struct RigidPose Namespace BepuPhysics Assembly BepuPhysics.dll Represents a rigid transformation. public struct RigidPose Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors RigidPose(Vector3) Creates a rigid pose with the given position and identity orientation. public RigidPose(Vector3 position) Parameters position Vector3 Position of the pose. RigidPose(Vector3, Quaternion) Creates a rigid pose with the given position and orientation. public RigidPose(Vector3 position, Quaternion orientation) Parameters position Vector3 Position of the pose. orientation Quaternion Orientation of the pose. Fields Orientation Orientation of the pose. public Quaternion Orientation Field Value Quaternion Position Position of the pose. public Vector3 Position Field Value Vector3 Properties Identity Returns a pose with a position at (0,0,0) and identity orientation. public static RigidPose Identity { get; } Property Value RigidPose Methods Invert(in RigidPose, out RigidPose) Inverts the rigid transformation of the pose. public static void Invert(in RigidPose pose, out RigidPose inverse) Parameters pose RigidPose Pose to invert. inverse RigidPose Inverse of the pose. MultiplyWithoutOverlap(in RigidPose, in RigidPose, out RigidPose) Concatenates one rigid transform with another. The resulting transform is equivalent to performing transform a followed by transform b. public static void MultiplyWithoutOverlap(in RigidPose a, in RigidPose b, out RigidPose result) Parameters a RigidPose First transform to concatenate. b RigidPose Second transform to concatenate. result RigidPose Result of the concatenation. ToString() Returns a string representing the RigidPose as \"Position, Orientation\". public override string ToString() Returns string String representing the RigidPose. Transform(Vector3, in RigidPose, out Vector3) Transforms a vector by the rigid pose: v * pose.Orientation + pose.Position. public static void Transform(Vector3 v, in RigidPose pose, out Vector3 result) Parameters v Vector3 Vector to transform. pose RigidPose Pose to transform the vector with. result Vector3 Transformed vector. TransformByInverse(Vector3, in RigidPose, out Vector3) Transforms a vector by the inverse of a rigid pose: (v - pose.Position) * pose.Orientation^-1. public static void TransformByInverse(Vector3 v, in RigidPose pose, out Vector3 result) Parameters v Vector3 Vector to transform. pose RigidPose Pose to invert and transform the vector with. result Vector3 Transformed vector. Operators implicit operator RigidPose(Quaternion) Creates a pose by treating a Quaternion as an orientation in the pose. Position is set to zero. public static implicit operator RigidPose(Quaternion orientation) Parameters orientation Quaternion Orientation to use in the pose. Returns RigidPose implicit operator RigidPose(Vector3) Creates a pose by treating a Vector3 as a position. Orientation is set to identity. public static implicit operator RigidPose(Vector3 position) Parameters position Vector3 Position to use in the pose. Returns RigidPose implicit operator RigidPose((Vector3 position, Quaternion orientation)) Creates a pose from a tuple of a position and orientation. public static implicit operator RigidPose((Vector3 position, Quaternion orientation) poseComponents) Parameters poseComponents (Vector3 position, Quaternion orientation) Position and orientation to use in the pose. Returns RigidPose"
  },
  "api/BepuPhysics.RigidPoseWide.html": {
    "href": "api/BepuPhysics.RigidPoseWide.html",
    "title": "Struct RigidPoseWide | Bepu API",
    "keywords": "Struct RigidPoseWide Namespace BepuPhysics Assembly BepuPhysics.dll public struct RigidPoseWide Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Orientation public QuaternionWide Orientation Field Value QuaternionWide Position public Vector3Wide Position Field Value Vector3Wide Methods Broadcast(in RigidPose, out RigidPoseWide) public static void Broadcast(in RigidPose pose, out RigidPoseWide poses) Parameters pose RigidPose poses RigidPoseWide ReadFirst(in RigidPoseWide, out RigidPose) public static void ReadFirst(in RigidPoseWide poses, out RigidPose pose) Parameters poses RigidPoseWide pose RigidPose WriteFirst(in RigidPose, ref RigidPoseWide) public static void WriteFirst(in RigidPose pose, ref RigidPoseWide poses) Parameters pose RigidPose poses RigidPoseWide"
  },
  "api/BepuPhysics.SequentialFallbackBatch.html": {
    "href": "api/BepuPhysics.SequentialFallbackBatch.html",
    "title": "Struct SequentialFallbackBatch | Bepu API",
    "keywords": "Struct SequentialFallbackBatch Namespace BepuPhysics Assembly BepuPhysics.dll Contains constraints that could not belong to any lower constraint batch due to their involved bodies. All of the contained constraints will be solved using a fallback solver that trades rigidity for parallelism. public struct SequentialFallbackBatch Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties BodyCount Gets the number of bodies in the fallback batch. public int BodyCount { get; } Property Value int Methods Compact(BufferPool) public void Compact(BufferPool pool) Parameters pool BufferPool Dispose(BufferPool) public void Dispose(BufferPool pool) Parameters pool BufferPool ValidateReferences(Solver) [Conditional(\"DEBUG\")] public static void ValidateReferences(Solver solver) Parameters solver Solver ValidateSetReferences(Solver, int) [Conditional(\"DEBUG\")] public static void ValidateSetReferences(Solver solver, int setIndex) Parameters solver Solver setIndex int"
  },
  "api/BepuPhysics.Simulation.html": {
    "href": "api/BepuPhysics.Simulation.html",
    "title": "Class Simulation | Bepu API",
    "keywords": "Class Simulation Namespace BepuPhysics Assembly BepuPhysics.dll Orchestrates the bookkeeping and execution of a full dynamic simulation. public class Simulation : IDisposable Inheritance object Simulation Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Awakener Gets the system responsible for awakening bodies within the simulation. public IslandAwakener Awakener { get; } Property Value IslandAwakener Bodies Gets the collection of bodies in the simulation. public Bodies Bodies { get; } Property Value Bodies BroadPhase Gets the broad phase used by the simulation. Supports accelerated ray and volume queries. public BroadPhase BroadPhase { get; } Property Value BroadPhase BroadPhaseOverlapFinder Gets the system used to find overlapping pairs within the simulation. public CollidableOverlapFinder BroadPhaseOverlapFinder { get; } Property Value CollidableOverlapFinder BufferPool Gets the main memory pool used to fill persistent structures and main thread ephemeral resources across the engine. public BufferPool BufferPool { get; } Property Value BufferPool Deterministic Gets or sets whether to use a deterministic time step when using multithreading. When set to true, additional time is spent sorting constraint additions and transfers. Note that this can only affect determinism locally- different processor architectures may implement instructions differently. public bool Deterministic { get; set; } Property Value bool NarrowPhase Gets the system used to identify contacts in colliding pairs of shapes and to update contact constraint data. public NarrowPhase NarrowPhase { get; } Property Value NarrowPhase PoseIntegrator Gets the integrator used to update velocities and poses within the simulation. public IPoseIntegrator PoseIntegrator { get; } Property Value IPoseIntegrator Profiler Gets the simulation profiler. Note that the SimulationProfiler implementation only exists when the library is compiled with the PROFILE compilation symbol; if not defined, returned times are undefined. public SimulationProfiler Profiler { get; } Property Value SimulationProfiler Shapes Gets or sets the collection of shapes used by the simulation. public Shapes Shapes { get; set; } Property Value Shapes Remarks While Shapes instances can be shared between multiple Simulation instances, there are no guarantees of thread safety. Further, setting the Shapes property to another collection while there are any outstanding references in the simulation to shapes within the old collection will result in fatal errors if the simulation continues to be used. Sleeper Gets the system responsible for putting bodies to sleep within the simulation. public IslandSleeper Sleeper { get; } Property Value IslandSleeper Solver Gets the solver used to solved constraints within the simulation. public Solver Solver { get; } Property Value Solver SolverBatchCompressor Gets the batch compressor used to compact constraints into fewer solver batches. public BatchCompressor SolverBatchCompressor { get; } Property Value BatchCompressor Statics Gets the collection of statics within the simulation. public Statics Statics { get; } Property Value Statics Timestepper Gets the timestepper used to update the simulation state. public ITimestepper Timestepper { get; } Property Value ITimestepper Methods Clear() Clears the simulation of every object, only returning memory to the pool that would be returned by sequential removes. Other persistent allocations, like those in the Bodies set, will remain. public void Clear() CollisionDetection(float, IThreadDispatcher) Updates the broad phase structure for the current body bounding boxes, finds potentially colliding pairs, and then executes the narrow phase for all such pairs. Generates contact constraints for the solver. public void CollisionDetection(float dt, IThreadDispatcher threadDispatcher = null) Parameters dt float Duration of the time step. threadDispatcher IThreadDispatcher Thread dispatcher to use for execution, if any. Create<TNarrowPhaseCallbacks, TPoseIntegratorCallbacks>(BufferPool, TNarrowPhaseCallbacks, TPoseIntegratorCallbacks, SolveDescription, ITimestepper, SimulationAllocationSizes?, Shapes) Constructs a simulation supporting dynamic movement and constraints with the specified narrow phase callbacks. public static Simulation Create<TNarrowPhaseCallbacks, TPoseIntegratorCallbacks>(BufferPool bufferPool, TNarrowPhaseCallbacks narrowPhaseCallbacks, TPoseIntegratorCallbacks poseIntegratorCallbacks, SolveDescription solveDescription, ITimestepper timestepper = null, SimulationAllocationSizes? initialAllocationSizes = null, Shapes shapes = null) where TNarrowPhaseCallbacks : struct, INarrowPhaseCallbacks where TPoseIntegratorCallbacks : struct, IPoseIntegratorCallbacks Parameters bufferPool BufferPool Buffer pool used to fill persistent structures and main thread ephemeral resources across the engine. narrowPhaseCallbacks TNarrowPhaseCallbacks Callbacks to use in the narrow phase. poseIntegratorCallbacks TPoseIntegratorCallbacks Callbacks to use in the pose integrator. solveDescription SolveDescription Describes how the solver should execute, including the number of substeps and the number of velocity iterations per substep. timestepper ITimestepper Timestepper that defines how the simulation state should be updated. If null, DefaultTimestepper is used. initialAllocationSizes SimulationAllocationSizes? Allocation sizes to initialize the simulation with. If left null, default values are chosen. shapes Shapes Collection of shapes to use in the simulation, if any. If null, a new Shapes collection will be created for this simulation. Returns Simulation New simulation. Type Parameters TNarrowPhaseCallbacks TPoseIntegratorCallbacks Dispose() Clears the simulation of every object and returns all pooled memory to the buffer pool. Leaves the simulation in an unusable state. public void Dispose() EnsureCapacity(SimulationAllocationSizes) Increases the allocation size of any buffers too small to hold the allocation target. public void EnsureCapacity(SimulationAllocationSizes allocationTarget) Parameters allocationTarget SimulationAllocationSizes Allocation sizes to guarantee sufficient size for. Remarks The final size of the allocated buffers are constrained by the allocator. It is not guaranteed to be exactly equal to the target, but it is guaranteed to be at least as large. This is primarily a convenience function. Everything it does internally can be done externally. For example, if only type batches need to be resized, the solver's own functions can be used directly. IncrementallyOptimizeDataStructures(IThreadDispatcher) Incrementally improves body and constraint storage for better performance. public void IncrementallyOptimizeDataStructures(IThreadDispatcher threadDispatcher = null) Parameters threadDispatcher IThreadDispatcher Thread dispatcher to use for execution, if any. PredictBoundingBoxes(float, IThreadDispatcher) Predicts the bounding boxes of active bodies by speculatively integrating velocity. Does not actually modify body velocities. Updates deactivation candidacy. public void PredictBoundingBoxes(float dt, IThreadDispatcher threadDispatcher = null) Parameters dt float Duration of the time step. threadDispatcher IThreadDispatcher Thread dispatcher to use for execution, if any. RayCast<THitHandler>(Vector3, Vector3, float, ref THitHandler, int) Intersects a ray against the simulation. public void RayCast<THitHandler>(Vector3 origin, Vector3 direction, float maximumT, ref THitHandler hitHandler, int id = 0) where THitHandler : IRayHitHandler Parameters origin Vector3 Origin of the ray to cast. direction Vector3 Direction of the ray to cast. maximumT float Maximum length of the ray traversal in units of the direction's length. hitHandler THitHandler callbacks to execute on ray-object intersections. id int User specified id of the ray. Type Parameters THitHandler Type of the callbacks to execute on ray-object intersections. Resize(SimulationAllocationSizes) Increases the allocation size of any buffers too small to hold the allocation target, and decreases the allocation size of any buffers that are unnecessarily large. public void Resize(SimulationAllocationSizes allocationTarget) Parameters allocationTarget SimulationAllocationSizes Allocation sizes to guarantee sufficient size for. Remarks The final size of the allocated buffers are constrained by the allocator. It is not guaranteed to be exactly equal to the target, but it is guaranteed to be at least as large. This is primarily a convenience function. Everything it does internally can be done externally. For example, if only type batches need to be resized, the solver's own functions can be used directly. Sleep(IThreadDispatcher) Executes the sleep stage, moving candidate public void Sleep(IThreadDispatcher threadDispatcher = null) Parameters threadDispatcher IThreadDispatcher Thread dispatcher to use for the sleeper execution, if any. Solve(float, IThreadDispatcher) Updates the broad phase structure for the current body bounding boxes, finds potentially colliding pairs, and then executes the narrow phase for all such pairs. Generates contact constraints for the solver. public void Solve(float dt, IThreadDispatcher threadDispatcher = null) Parameters dt float Duration of the time step. threadDispatcher IThreadDispatcher Thread dispatcher to use for execution, if any. Sweep<TShape, TSweepHitHandler>(TShape, in RigidPose, in BodyVelocity, float, BufferPool, ref TSweepHitHandler, float, float, int) Sweeps a shape against the simulation. public void Sweep<TShape, TSweepHitHandler>(TShape shape, in RigidPose pose, in BodyVelocity velocity, float maximumT, BufferPool pool, ref TSweepHitHandler hitHandler, float minimumProgression, float convergenceThreshold, int maximumIterationCount) where TShape : unmanaged, IConvexShape where TSweepHitHandler : ISweepHitHandler Parameters shape TShape Shape to sweep. pose RigidPose Starting pose of the sweep. velocity BodyVelocity Velocity of the swept shape. maximumT float Maximum length of the sweep in units of time used to integrate the velocity. pool BufferPool Pool to allocate any temporary resources in during execution. hitHandler TSweepHitHandler Callbacks executed when a sweep impacts an object in the scene. minimumProgression float Minimum amount of progress in terms of t parameter that any iterative sweep tests should make for each sample. convergenceThreshold float Threshold in terms of t parameter under which iterative sweep tests are permitted to exit in collision. maximumIterationCount int Maximum number of iterations to use in iterative sweep tests. Type Parameters TShape Type of the shape to sweep. TSweepHitHandler Type of the callbacks executed when a sweep impacts an object in the scene. Remarks Simulation objects are treated as stationary during the sweep. Sweep<TShape, TSweepHitHandler>(in TShape, in RigidPose, in BodyVelocity, float, BufferPool, ref TSweepHitHandler) Sweeps a shape against the simulation. public void Sweep<TShape, TSweepHitHandler>(in TShape shape, in RigidPose pose, in BodyVelocity velocity, float maximumT, BufferPool pool, ref TSweepHitHandler hitHandler) where TShape : unmanaged, IConvexShape where TSweepHitHandler : ISweepHitHandler Parameters shape TShape Shape to sweep. pose RigidPose Starting pose of the sweep. velocity BodyVelocity Velocity of the swept shape. maximumT float Maximum length of the sweep in units of time used to integrate the velocity. pool BufferPool Pool to allocate any temporary resources in during execution. hitHandler TSweepHitHandler Callbacks executed when a sweep impacts an object in the scene. Type Parameters TShape Type of the shape to sweep. TSweepHitHandler Type of the callbacks executed when a sweep impacts an object in the scene. Remarks Simulation objects are treated as stationary during the sweep. Timestep(float, IThreadDispatcher) Performs one timestep of the given length. public void Timestep(float dt, IThreadDispatcher threadDispatcher = null) Parameters dt float Duration of the time step. threadDispatcher IThreadDispatcher Thread dispatcher to use for execution, if any. Remarks Be wary of variable timesteps. They can harm stability. Whenever possible, keep the timestep the same across multiple frames unless you have a specific reason not to."
  },
  "api/BepuPhysics.SimulationAllocationSizes.html": {
    "href": "api/BepuPhysics.SimulationAllocationSizes.html",
    "title": "Struct SimulationAllocationSizes | Bepu API",
    "keywords": "Struct SimulationAllocationSizes Namespace BepuPhysics Assembly BepuPhysics.dll The common set of allocation sizes for a simulation. public struct SimulationAllocationSizes Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors SimulationAllocationSizes(int, int, int, int, int, int, int) Constructs a description of simulation allocations. public SimulationAllocationSizes(int bodies, int statics, int islands, int shapesPerType, int constraints, int constraintsPerTypeBatch, int constraintCountPerBodyEstimate) Parameters bodies int The number of bodies to allocate space for. statics int The number of statics to allocate space for. islands int The number of inactive islands to allocate space for. shapesPerType int Minimum number of shapes to allocate space for in each shape type batch. Unused if a Shapes instance was directly provided to the Simulation constructor. constraints int The number of constraints to allocate bookkeeping space for. This does not affect actual type batch allocation sizes, only the solver-level constraint handle storage. constraintsPerTypeBatch int The minimum number of constraints to allocate space for in each individual type batch. New type batches will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it. The number of constraints can vary greatly across types- there are usually far more contacts than ragdoll constraints. Per type estimates can be assigned within the Solver.TypeBatchAllocation if necessary. This value acts as a lower bound for all types. constraintCountPerBodyEstimate int The minimum number of constraints to allocate space for in each body's constraint list. New bodies will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it. Fields Bodies The number of bodies to allocate space for. public int Bodies Field Value int ConstraintCountPerBodyEstimate The minimum number of constraints to allocate space for in each body's constraint list. New bodies will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it. public int ConstraintCountPerBodyEstimate Field Value int Constraints The number of constraints to allocate bookkeeping space for. This does not affect actual type batch allocation sizes, only the solver-level constraint handle storage. public int Constraints Field Value int ConstraintsPerTypeBatch The minimum number of constraints to allocate space for in each individual type batch. New type batches will be given enough memory for this number of constraints, and any compaction will not reduce the allocations below it. The number of constraints can vary greatly across types- there are usually far more contacts than ragdoll constraints. Per type estimates can be assigned within the Solver.TypeBatchAllocation if necessary. This value acts as a lower bound for all types. public int ConstraintsPerTypeBatch Field Value int Islands The number of inactive islands to allocate space for. public int Islands Field Value int ShapesPerType Minimum number of shapes to allocate space for in each shape type batch. public int ShapesPerType Field Value int Remarks Unused if a Shapes instance was directly provided to the Simulation constructor. Statics The number of statics to allocate space for. public int Statics Field Value int"
  },
  "api/BepuPhysics.SimulationProfiler.html": {
    "href": "api/BepuPhysics.SimulationProfiler.html",
    "title": "Struct SimulationProfiler | Bepu API",
    "keywords": "Struct SimulationProfiler Namespace BepuPhysics Assembly BepuPhysics.dll Stores profiling information for the previous simulation execution. public struct SimulationProfiler Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors SimulationProfiler(int) public SimulationProfiler(int initialStageCount) Parameters initialStageCount int Properties this[object] Gets the time it took to complete the last execution of the given stage. If no stage matching the given object ran, returns -1. public double this[object stage] { get; } Parameters stage object Stage to look up the time for. Property Value double Time it took to complete the last execution of the given stage. Methods Clear() public void Clear() End(object) public void End(object o) Parameters o object Start(object) public void Start(object o) Parameters o object"
  },
  "api/BepuPhysics.SolveDescription.html": {
    "href": "api/BepuPhysics.SolveDescription.html",
    "title": "Struct SolveDescription | Bepu API",
    "keywords": "Struct SolveDescription Namespace BepuPhysics Assembly BepuPhysics.dll Describes how the solver should schedule substeps and velocity iterations. public struct SolveDescription Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors SolveDescription(int, SubstepVelocityIterationScheduler, int, int) Creates a solve description. public SolveDescription(int substepCount, SubstepVelocityIterationScheduler velocityIterationScheduler, int fallbackVelocityIterationCount = 1, int fallbackBatchThreshold = 64) Parameters substepCount int Number of substeps in the solve. velocityIterationScheduler SubstepVelocityIterationScheduler fallbackVelocityIterationCount int Number of velocity iterations per substep for any substep that is not given a positive number of velocity iterations by the scheduler. fallbackBatchThreshold int Number of synchronzed constraint batches to use before using a fallback approach. SolveDescription(int, int, int) Creates a solve description. public SolveDescription(int velocityIterationCount, int substepCount, int fallbackBatchThreshold = 64) Parameters velocityIterationCount int Number of velocity iterations per substep. substepCount int Number of substeps in the solve. fallbackBatchThreshold int Number of synchronzed constraint batches to use before using a fallback approach. SolveDescription(ReadOnlySpan<int>, int, int) Creates a solve description. public SolveDescription(ReadOnlySpan<int> substepVelocityIterations, int fallbackVelocityIterationCount = 1, int fallbackBatchThreshold = 64) Parameters substepVelocityIterations ReadOnlySpan<int> Number of velocity iterations to use in each substep. Number of substeps will be determined by the length of the span. fallbackVelocityIterationCount int Number of velocity iterations per substep for any substep that is not given a positive number of velocity iterations by the scheduler. fallbackBatchThreshold int Number of synchronzed constraint batches to use before using a fallback approach. Fields DefaultFallbackBatchThreshold Default number of synchronized constraint batches to use before falling back to an alternative solving method. public const int DefaultFallbackBatchThreshold = 64 Field Value int FallbackBatchThreshold Number of synchronzed constraint batches to use before using a fallback approach. public int FallbackBatchThreshold Field Value int SubstepCount Number of substeps to execute each time the solver runs. public int SubstepCount Field Value int VelocityIterationCount Number of velocity iterations to use in the solver if there is no VelocityIterationScheduler or if it returns a non-positive value for a substep. public int VelocityIterationCount Field Value int VelocityIterationScheduler Callback executed to determine how many velocity iterations should be used for a given substep. If null, or if it returns a non-positive value, the VelocityIterationCount will be used instead. public SubstepVelocityIterationScheduler VelocityIterationScheduler Field Value SubstepVelocityIterationScheduler Operators implicit operator SolveDescription(Buffer<int>) Creates a solve description with the given number of substeps and velocity iterations per substep and a fallback threshold of DefaultFallbackBatchThreshold. public static implicit operator SolveDescription(Buffer<int> substepVelocityIterations) Parameters substepVelocityIterations Buffer<int> Number of velocity iterations to use in each substep. Number of substeps will be determined by the length of the span. Returns SolveDescription implicit operator SolveDescription(int) Creates a solve description with the given number of velocity iterations and a single substep, with a fallback threshold of DefaultFallbackBatchThreshold. public static implicit operator SolveDescription(int velocityIterationCount) Parameters velocityIterationCount int Number of velocity iterations per substep. Returns SolveDescription implicit operator SolveDescription(int[]) Creates a solve description with the given number of substeps and velocity iterations per substep and a fallback threshold of DefaultFallbackBatchThreshold. public static implicit operator SolveDescription(int[] substepVelocityIterations) Parameters substepVelocityIterations int[] Number of velocity iterations to use in each substep. Number of substeps will be determined by the length of the span. Returns SolveDescription implicit operator SolveDescription(ReadOnlySpan<int>) Creates a solve description with the given number of substeps and velocity iterations per substep and a fallback threshold of DefaultFallbackBatchThreshold. public static implicit operator SolveDescription(ReadOnlySpan<int> substepVelocityIterations) Parameters substepVelocityIterations ReadOnlySpan<int> Number of velocity iterations to use in each substep. Number of substeps will be determined by the length of the span. Returns SolveDescription implicit operator SolveDescription((int iterationsPerSubstep, int substepCount)) Creates a solve description with the given number of substeps and velocity iterations per substep and a fallback threshold of DefaultFallbackBatchThreshold. public static implicit operator SolveDescription((int iterationsPerSubstep, int substepCount) schedule) Parameters schedule (int iterationsPerSubstep, int substepCount) Number of substeps and iterations per solve. Returns SolveDescription"
  },
  "api/BepuPhysics.Solver-1.IStageFunction.html": {
    "href": "api/BepuPhysics.Solver-1.IStageFunction.html",
    "title": "Interface Solver<TIntegrationCallbacks>.IStageFunction | Bepu API",
    "keywords": "Interface Solver<TIntegrationCallbacks>.IStageFunction Namespace BepuPhysics Assembly BepuPhysics.dll protected interface Solver<TIntegrationCallbacks>.IStageFunction Methods Execute(Solver, int, int) void Execute(Solver solver, int blockIndex, int workerIndex) Parameters solver Solver blockIndex int workerIndex int"
  },
  "api/BepuPhysics.Solver-1.ITypeBatchSolveFilter.html": {
    "href": "api/BepuPhysics.Solver-1.ITypeBatchSolveFilter.html",
    "title": "Interface Solver<TIntegrationCallbacks>.ITypeBatchSolveFilter | Bepu API",
    "keywords": "Interface Solver<TIntegrationCallbacks>.ITypeBatchSolveFilter Namespace BepuPhysics Assembly BepuPhysics.dll protected interface Solver<TIntegrationCallbacks>.ITypeBatchSolveFilter Properties IncludeFallbackBatchForWorkBlocks bool IncludeFallbackBatchForWorkBlocks { get; } Property Value bool Methods AllowType(int) bool AllowType(int typeId) Parameters typeId int Returns bool"
  },
  "api/BepuPhysics.Solver-1.IncrementalUpdateForSubstepFilter.html": {
    "href": "api/BepuPhysics.Solver-1.IncrementalUpdateForSubstepFilter.html",
    "title": "Struct Solver<TIntegrationCallbacks>.IncrementalUpdateForSubstepFilter | Bepu API",
    "keywords": "Struct Solver<TIntegrationCallbacks>.IncrementalUpdateForSubstepFilter Namespace BepuPhysics Assembly BepuPhysics.dll protected struct Solver<TIntegrationCallbacks>.IncrementalUpdateForSubstepFilter : Solver<TIntegrationCallbacks>.ITypeBatchSolveFilter Implements Solver<TIntegrationCallbacks>.ITypeBatchSolveFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields TypeProcessors public TypeProcessor[] TypeProcessors Field Value TypeProcessor[] Properties IncludeFallbackBatchForWorkBlocks public bool IncludeFallbackBatchForWorkBlocks { get; } Property Value bool Methods AllowType(int) public bool AllowType(int typeId) Parameters typeId int Returns bool"
  },
  "api/BepuPhysics.Solver-1.MainSolveFilter.html": {
    "href": "api/BepuPhysics.Solver-1.MainSolveFilter.html",
    "title": "Struct Solver<TIntegrationCallbacks>.MainSolveFilter | Bepu API",
    "keywords": "Struct Solver<TIntegrationCallbacks>.MainSolveFilter Namespace BepuPhysics Assembly BepuPhysics.dll protected struct Solver<TIntegrationCallbacks>.MainSolveFilter : Solver<TIntegrationCallbacks>.ITypeBatchSolveFilter Implements Solver<TIntegrationCallbacks>.ITypeBatchSolveFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties IncludeFallbackBatchForWorkBlocks public bool IncludeFallbackBatchForWorkBlocks { get; } Property Value bool Methods AllowType(int) public bool AllowType(int typeId) Parameters typeId int Returns bool"
  },
  "api/BepuPhysics.Solver-1.html": {
    "href": "api/BepuPhysics.Solver-1.html",
    "title": "Class Solver<TIntegrationCallbacks> | Bepu API",
    "keywords": "Class Solver<TIntegrationCallbacks> Namespace BepuPhysics Assembly BepuPhysics.dll Handles integration-aware substepped solving. public class Solver<TIntegrationCallbacks> : Solver where TIntegrationCallbacks : struct, IPoseIntegratorCallbacks Type Parameters TIntegrationCallbacks Type of integration callbacks being used during the substepped solve. Inheritance object Solver Solver<TIntegrationCallbacks> Inherited Members Solver.Sets Solver.ActiveSet Solver.TypeProcessors Solver.HandlePool Solver.HandleToConstraint Solver.FallbackBatchThreshold Solver.ConstrainedKinematicHandles Solver.substepCount Solver.SubstepCount Solver.VelocityIterationCount Solver.VelocityIterationScheduler Solver.MinimumCapacityPerTypeBatch Solver.SubstepStarted Solver.SubstepEnded Solver.OnSubstepStarted(int) Solver.OnSubstepEnded(int) Solver.SetMinimumCapacityForType(int, int) Solver.GetMinimumCapacityForType(int) Solver.ResetPerTypeInitialCapacities() Solver.CountConstraintsInTypeBatch(int, int, int) Solver.CountConstraints() Solver.Register<TDescription>() Solver.ConstraintExists(ConstraintHandle) Solver.GetConstraintReference(ConstraintHandle) Solver.ApplyDescriptionWithoutWaking<TDescription>(in ConstraintReference, in TDescription) Solver.ApplyDescriptionWithoutWaking<TDescription>(ConstraintHandle, in TDescription) Solver.ApplyDescription<TDescription>(ConstraintHandle, in TDescription) Solver.Add<TDescription>(Span<BodyHandle>, in TDescription) Solver.Add<TDescription>(BodyHandle, in TDescription) Solver.Add<TDescription>(BodyHandle, BodyHandle, in TDescription) Solver.Add<TDescription>(BodyHandle, BodyHandle, BodyHandle, in TDescription) Solver.Add<TDescription>(BodyHandle, BodyHandle, BodyHandle, BodyHandle, in TDescription) Solver.Remove(ConstraintHandle) Solver.GetDescription<TConstraintDescription>(ConstraintReference, out TConstraintDescription) Solver.GetDescription<TConstraintDescription>(ConstraintHandle, out TConstraintDescription) Solver.ScaleAccumulatedImpulses(ref ConstraintSet, float) Solver.ScaleActiveAccumulatedImpulses(float) Solver.ScaleAccumulatedImpulses(float) Solver.EnumerateAccumulatedImpulses<TEnumerator>(ConstraintHandle, ref TEnumerator) Solver.GetAccumulatedImpulseMagnitudeSquared(ConstraintHandle) Solver.GetAccumulatedImpulseMagnitude(ConstraintHandle) Solver.EnumerateConnectedRawBodyReferences<TEnumerator>(ref TypeBatch, int, ref TEnumerator) Solver.EnumerateConnectedRawBodyReferences<TEnumerator>(ConstraintHandle, ref TEnumerator) Solver.EnumerateConnectedBodyReferences<TEnumerator>(ref TypeBatch, int, ref TEnumerator) Solver.EnumerateConnectedBodyReferences<TEnumerator>(ConstraintHandle, ref TEnumerator) Solver.EnumerateConnectedDynamicBodies<TEnumerator>(ref TypeBatch, int, ref TEnumerator) Solver.EnumerateConnectedDynamicBodies<TEnumerator>(ConstraintHandle, ref TEnumerator) Solver.Clear() Solver.EnsureSolverCapacities(int, int) Solver.ResizeSolverCapacities(int, int) Solver.EnsureTypeBatchCapacities() Solver.ResizeTypeBatchCapacities() Solver.Dispose() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Solver(Bodies, BufferPool, SolveDescription, int, int, int, PoseIntegrator<TIntegrationCallbacks>) public Solver(Bodies bodies, BufferPool pool, SolveDescription solveDescription, int initialCapacity, int initialIslandCapacity, int minimumCapacityPerTypeBatch, PoseIntegrator<TIntegrationCallbacks> poseIntegrator) Parameters bodies Bodies pool BufferPool solveDescription SolveDescription initialCapacity int initialIslandCapacity int minimumCapacityPerTypeBatch int poseIntegrator PoseIntegrator<TIntegrationCallbacks> Fields substepContext protected Solver.SubstepMultithreadingContext substepContext Field Value Solver.SubstepMultithreadingContext Properties PoseIntegrator Pose integrator used by the simulation. public PoseIntegrator<TIntegrationCallbacks> PoseIntegrator { get; } Property Value PoseIntegrator<TIntegrationCallbacks> Methods BuildWorkBlocks<TTypeBatchFilter>(BufferPool, int, int, int, ref TTypeBatchFilter, out QuickList<WorkBlock>, out Buffer<int>) protected void BuildWorkBlocks<TTypeBatchFilter>(BufferPool pool, int minimumBlockSizeInBundles, int maximumBlockSizeInBundles, int targetBlocksPerBatch, ref TTypeBatchFilter typeBatchFilter, out QuickList<Solver.WorkBlock> workBlocks, out Buffer<int> batchBoundaries) where TTypeBatchFilter : Solver<TIntegrationCallbacks>.ITypeBatchSolveFilter Parameters pool BufferPool minimumBlockSizeInBundles int maximumBlockSizeInBundles int targetBlocksPerBatch int typeBatchFilter TTypeBatchFilter workBlocks QuickList<Solver.WorkBlock> batchBoundaries Buffer<int> Type Parameters TTypeBatchFilter DisposeConstraintIntegrationResponsibilities() public override void DisposeConstraintIntegrationResponsibilities() ExecuteMultithreaded(float, IThreadDispatcher, Action<int>) protected void ExecuteMultithreaded(float dt, IThreadDispatcher threadDispatcher, Action<int> workDelegate) Parameters dt float threadDispatcher IThreadDispatcher workDelegate Action<int> GetUniformlyDistributedStart(int, int, int, int) protected static int GetUniformlyDistributedStart(int workerIndex, int blockCount, int workerCount, int offset) Parameters workerIndex int blockCount int workerCount int offset int Returns int PrepareConstraintIntegrationResponsibilities(IThreadDispatcher) public override IndexSet PrepareConstraintIntegrationResponsibilities(IThreadDispatcher threadDispatcher = null) Parameters threadDispatcher IThreadDispatcher Returns IndexSet Solve(float, IThreadDispatcher) public override void Solve(float totalDt, IThreadDispatcher threadDispatcher = null) Parameters totalDt float threadDispatcher IThreadDispatcher"
  },
  "api/BepuPhysics.Solver.IntegrationWorkBlock.html": {
    "href": "api/BepuPhysics.Solver.IntegrationWorkBlock.html",
    "title": "Struct Solver.IntegrationWorkBlock | Bepu API",
    "keywords": "Struct Solver.IntegrationWorkBlock Namespace BepuPhysics Assembly BepuPhysics.dll protected struct Solver.IntegrationWorkBlock Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields EndBundleIndex public int EndBundleIndex Field Value int StartBundleIndex public int StartBundleIndex Field Value int"
  },
  "api/BepuPhysics.Solver.SolverStageType.html": {
    "href": "api/BepuPhysics.Solver.SolverStageType.html",
    "title": "Enum Solver.SolverStageType | Bepu API",
    "keywords": "Enum Solver.SolverStageType Namespace BepuPhysics Assembly BepuPhysics.dll protected enum Solver.SolverStageType Fields IncrementalUpdate = 0 IntegrateConstrainedKinematics = 1 Solve = 3 WarmStart = 2"
  },
  "api/BepuPhysics.Solver.SolverSyncStage.html": {
    "href": "api/BepuPhysics.Solver.SolverSyncStage.html",
    "title": "Struct Solver.SolverSyncStage | Bepu API",
    "keywords": "Struct Solver.SolverSyncStage Namespace BepuPhysics Assembly BepuPhysics.dll protected struct Solver.SolverSyncStage Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors SolverSyncStage(Buffer<int>, int, SolverStageType, int) public SolverSyncStage(Buffer<int> claims, int workBlockStartIndex, Solver.SolverStageType type, int batchIndex = -1) Parameters claims Buffer<int> workBlockStartIndex int type Solver.SolverStageType batchIndex int Fields BatchIndex public int BatchIndex Field Value int Claims public Buffer<int> Claims Field Value Buffer<int> StageType public Solver.SolverStageType StageType Field Value Solver.SolverStageType WorkBlockStartIndex public int WorkBlockStartIndex Field Value int"
  },
  "api/BepuPhysics.Solver.SubstepEvent.html": {
    "href": "api/BepuPhysics.Solver.SubstepEvent.html",
    "title": "Delegate Solver.SubstepEvent | Bepu API",
    "keywords": "Delegate Solver.SubstepEvent Namespace BepuPhysics Assembly BepuPhysics.dll Delegate type of solver substep begin/end events. public delegate void Solver.SubstepEvent(int substepIndex) Parameters substepIndex int Index of the substep that the event is about."
  },
  "api/BepuPhysics.Solver.SubstepMultithreadingContext.html": {
    "href": "api/BepuPhysics.Solver.SubstepMultithreadingContext.html",
    "title": "Struct Solver.SubstepMultithreadingContext | Bepu API",
    "keywords": "Struct Solver.SubstepMultithreadingContext Namespace BepuPhysics Assembly BepuPhysics.dll protected struct Solver.SubstepMultithreadingContext Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields CompletedWorkBlockCount Counter of work completed for the current stage. public int CompletedWorkBlockCount Field Value int ConstraintBatchBoundaries public Buffer<int> ConstraintBatchBoundaries Field Value Buffer<int> ConstraintBlocks public Buffer<Solver.WorkBlock> ConstraintBlocks Field Value Buffer<Solver.WorkBlock> Dt public float Dt Field Value float HighestVelocityIterationCount public int HighestVelocityIterationCount Field Value int IncrementalUpdateBlocks public Buffer<Solver.WorkBlock> IncrementalUpdateBlocks Field Value Buffer<Solver.WorkBlock> InverseDt public float InverseDt Field Value float KinematicIntegrationBlocks public Buffer<Solver.IntegrationWorkBlock> KinematicIntegrationBlocks Field Value Buffer<Solver.IntegrationWorkBlock> Stages public Buffer<Solver.SolverSyncStage> Stages Field Value Buffer<Solver.SolverSyncStage> SyncIndex Monotonically increasing index of executed stages during a frame. public int SyncIndex Field Value int VelocityIterationCounts public Buffer<int> VelocityIterationCounts Field Value Buffer<int> WorkerCount public int WorkerCount Field Value int"
  },
  "api/BepuPhysics.Solver.WorkBlock.html": {
    "href": "api/BepuPhysics.Solver.WorkBlock.html",
    "title": "Struct Solver.WorkBlock | Bepu API",
    "keywords": "Struct Solver.WorkBlock Namespace BepuPhysics Assembly BepuPhysics.dll protected struct Solver.WorkBlock Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields BatchIndex public int BatchIndex Field Value int End Exlusive end index of the bundle. Index of the last bundle in the block is End - 1. public int End Field Value int StartBundle Index of the first bundle in the block. public int StartBundle Field Value int TypeBatchIndex public int TypeBatchIndex Field Value int"
  },
  "api/BepuPhysics.Solver.html": {
    "href": "api/BepuPhysics.Solver.html",
    "title": "Class Solver | Bepu API",
    "keywords": "Class Solver Namespace BepuPhysics Assembly BepuPhysics.dll Holds and solves constraints between bodies in a simulation. public abstract class Solver Inheritance object Solver Derived Solver<TIntegrationCallbacks> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Solver(Bodies, BufferPool, SolveDescription, int, int, int) protected Solver(Bodies bodies, BufferPool pool, SolveDescription solveDescription, int initialCapacity, int initialIslandCapacity, int minimumCapacityPerTypeBatch) Parameters bodies Bodies pool BufferPool solveDescription SolveDescription initialCapacity int initialIslandCapacity int minimumCapacityPerTypeBatch int Fields ConstrainedKinematicHandles Set of body handles associated with constrained kinematic bodies. These will be integrated during substepping. public QuickSet<int, PrimitiveComparer<int>> ConstrainedKinematicHandles Field Value QuickSet<int, PrimitiveComparer<int>> HandlePool Pool to retrieve constraint handles from when creating new constraints. public IdPool HandlePool Field Value IdPool HandleToConstraint Mapping from constraint handle (via its internal integer value) to the location of a constraint in memory. public Buffer<ConstraintLocation> HandleToConstraint Field Value Buffer<ConstraintLocation> Sets Buffer containing all constraint sets. The first slot is dedicated to the active set; subsequent slots may be occupied by the constraints associated with inactive islands. public Buffer<ConstraintSet> Sets Field Value Buffer<ConstraintSet> TypeProcessors Set of processors applied to batches of constraints of particular types, indexed by the constraint type id. public TypeProcessor[] TypeProcessors Field Value TypeProcessor[] substepCount protected int substepCount Field Value int Properties ActiveSet Gets a reference to the active set of constraints, stored in the first set slot. public ref ConstraintSet ActiveSet { get; } Property Value ConstraintSet FallbackBatchThreshold Gets the maximum number of solver batches to allow before resorting to a fallback solver. If a single body is constrained by more than FallbackBatchThreshold constraints, all constraints beyond FallbackBatchThreshold are placed into a fallback batch. The fallback batch uses a different solver that can handle multiple constraints affecting a single body in a single batch, allowing greater parallelism at the cost of convergence speed. public int FallbackBatchThreshold { get; } Property Value int MinimumCapacityPerTypeBatch Gets or sets the minimum amount of space, in constraints, initially allocated in any new type batch. public int MinimumCapacityPerTypeBatch { get; set; } Property Value int SubstepCount Gets or sets the number of substeps the solver will simulate per call to Solve. public int SubstepCount { get; set; } Property Value int VelocityIterationCount Gets or sets the number of solver velocity iterations to compute per substep. public int VelocityIterationCount { get; set; } Property Value int VelocityIterationScheduler Callback executed to determine how many velocity iterations should be used for a given substep. If null, or if it returns a non-positive value, the VelocityIterationCount will be used instead. public SubstepVelocityIterationScheduler VelocityIterationScheduler { get; set; } Property Value SubstepVelocityIterationScheduler Methods Add<TDescription>(BodyHandle, BodyHandle, BodyHandle, BodyHandle, in TDescription) Allocates a four-body constraint slot and sets up a constraint with the specified description. public ConstraintHandle Add<TDescription>(BodyHandle bodyHandleA, BodyHandle bodyHandleB, BodyHandle bodyHandleC, BodyHandle bodyHandleD, in TDescription description) where TDescription : unmanaged, IFourBodyConstraintDescription<TDescription> Parameters bodyHandleA BodyHandle First body of the constraint. bodyHandleB BodyHandle Second body of the constraint. bodyHandleC BodyHandle Third body of the constraint. bodyHandleD BodyHandle Fourth body of the constraint. description TDescription Description of the constraint to add. Returns ConstraintHandle Allocated constraint handle. Type Parameters TDescription Type of the constraint description to add. Add<TDescription>(BodyHandle, BodyHandle, BodyHandle, in TDescription) Allocates a three-body constraint slot and sets up a constraint with the specified description. public ConstraintHandle Add<TDescription>(BodyHandle bodyHandleA, BodyHandle bodyHandleB, BodyHandle bodyHandleC, in TDescription description) where TDescription : unmanaged, IThreeBodyConstraintDescription<TDescription> Parameters bodyHandleA BodyHandle First body of the constraint. bodyHandleB BodyHandle Second body of the constraint. bodyHandleC BodyHandle Third body of the constraint. description TDescription Description of the constraint to add. Returns ConstraintHandle Allocated constraint handle. Type Parameters TDescription Type of the constraint description to add. Add<TDescription>(BodyHandle, BodyHandle, in TDescription) Allocates a two-body constraint slot and sets up a constraint with the specified description. public ConstraintHandle Add<TDescription>(BodyHandle bodyHandleA, BodyHandle bodyHandleB, in TDescription description) where TDescription : unmanaged, ITwoBodyConstraintDescription<TDescription> Parameters bodyHandleA BodyHandle First body of the constraint. bodyHandleB BodyHandle Second body of the constraint. description TDescription Description of the constraint to add. Returns ConstraintHandle Allocated constraint handle. Type Parameters TDescription Type of the constraint description to add. Add<TDescription>(BodyHandle, in TDescription) Allocates a one-body constraint slot and sets up a constraint with the specified description. public ConstraintHandle Add<TDescription>(BodyHandle bodyHandle, in TDescription description) where TDescription : unmanaged, IOneBodyConstraintDescription<TDescription> Parameters bodyHandle BodyHandle Body connected to the constraint. description TDescription Description of the constraint to add. Returns ConstraintHandle Allocated constraint handle. Type Parameters TDescription Type of the constraint description to add. Add<TDescription>(Span<BodyHandle>, in TDescription) Allocates a constraint slot and sets up a constraint with the specified description. public ConstraintHandle Add<TDescription>(Span<BodyHandle> bodyHandles, in TDescription description) where TDescription : unmanaged, IConstraintDescription<TDescription> Parameters bodyHandles Span<BodyHandle> Body handles used by the constraint. description TDescription Description of the constraint to add. Returns ConstraintHandle Allocated constraint handle. Type Parameters TDescription Type of the constraint description to add. ApplyDescriptionWithoutWaking<TDescription>(ConstraintHandle, in TDescription) Applies a description to a constraint slot without waking up the associated island. public void ApplyDescriptionWithoutWaking<TDescription>(ConstraintHandle constraintHandle, in TDescription description) where TDescription : unmanaged, IConstraintDescription<TDescription> Parameters constraintHandle ConstraintHandle Handle of the constraint being updated. description TDescription Description to apply to the slot. Type Parameters TDescription Type of the description to apply. ApplyDescriptionWithoutWaking<TDescription>(in ConstraintReference, in TDescription) Applies a description to a constraint slot without waking up the associated island. public void ApplyDescriptionWithoutWaking<TDescription>(in ConstraintReference constraintReference, in TDescription description) where TDescription : unmanaged, IConstraintDescription<TDescription> Parameters constraintReference ConstraintReference Reference of the constraint being updated. description TDescription Description to apply to the slot. Type Parameters TDescription Type of the description to apply. ApplyDescription<TDescription>(ConstraintHandle, in TDescription) Applies a description to a constraint slot, waking up the connected bodies if necessary. public void ApplyDescription<TDescription>(ConstraintHandle constraintHandle, in TDescription description) where TDescription : unmanaged, IConstraintDescription<TDescription> Parameters constraintHandle ConstraintHandle Handle of the constraint being updated. description TDescription Description to apply to the slot. Type Parameters TDescription Type of the description to apply. Clear() Removes all objects from the solver. This is meant as a fast path to empty a simulation's constraints. It makes no attempt to retain synchronization with other systems which may depend on the existence of constraints, like the per-body constraint lists. public void Clear() ConstraintExists(ConstraintHandle) Gets whether the given constraint handle refers to a constraint in the solver. public bool ConstraintExists(ConstraintHandle constraintHandle) Parameters constraintHandle ConstraintHandle Constraint handle to check for existence in the solver. Returns bool True if the constraint handle exists in the solver, false otherwise. CountConstraints() Gets the total number of constraints across all sets, batches, and types. Requires enumerating all type batches; this can be expensive. public int CountConstraints() Returns int CountConstraintsInTypeBatch(int, int, int) Counts the number of constraints in a particular type batch. public int CountConstraintsInTypeBatch(int setIndex, int batchIndex, int typeBatchIndex) Parameters setIndex int Index of the set containing the type batch. batchIndex int Index of the batch containing the type batch. typeBatchIndex int Index of the type batch within the batch. Returns int Number of constraints in the type batch. Remarks This handles whether the type batch is in the fallback batch or not. Active fallback batches are not guaranteed to have contiguous constraints, so the ConstraintCount value is an upper bound and there may be gaps. Dispose() Returns all pool-retrieved resources to the pool. public void Dispose() Remarks The solver cannot be 'rehydrated' for reuse after a disposal. If you want to return bulk data to the pool while leaving the solver in a usable state, consider using Clear instead. DisposeConstraintIntegrationResponsibilities() public abstract void DisposeConstraintIntegrationResponsibilities() EnsureSolverCapacities(int, int) Adjusts the size of the the solvers non-typebatch data structures. An allocation will grow if the given capacity exceeds the currently allocated capacity. public void EnsureSolverCapacities(int bodyHandleCapacity, int constraintHandleCapacity) Parameters bodyHandleCapacity int Size of the span of body handles to allocate space for. Applies to batch referenced handle sets. constraintHandleCapacity int Number of constraint handles to allocate space for. Applies to the handle->constraint mapping table. EnsureTypeBatchCapacities() Ensures all existing active type batches meet or exceed the current solver-defined minimum capacities. Type batches with capacities smaller than the minimums will be enlarged. public void EnsureTypeBatchCapacities() EnumerateAccumulatedImpulses<TEnumerator>(ConstraintHandle, ref TEnumerator) Enumerates the accumulated impulses associated with a constraint. public void EnumerateAccumulatedImpulses<TEnumerator>(ConstraintHandle constraintHandle, ref TEnumerator enumerator) where TEnumerator : IForEach<float> Parameters constraintHandle ConstraintHandle Constraint to enumerate. enumerator TEnumerator Enumerator to use. Type Parameters TEnumerator EnumerateConnectedBodyReferences<TEnumerator>(ConstraintHandle, ref TEnumerator) Enumerates the set of body references associated with an active constraint in order of their references within the constraint. This will report the body reference (body index if awake, handle if asleep) without any encoded kinematicity metadata. public void EnumerateConnectedBodyReferences<TEnumerator>(ConstraintHandle constraintHandle, ref TEnumerator enumerator) where TEnumerator : IForEach<int> Parameters constraintHandle ConstraintHandle Constraint to enumerate. enumerator TEnumerator Enumerator to call for each connected body reference. Type Parameters TEnumerator Type of the enumerator to call on each connected body reference. EnumerateConnectedBodyReferences<TEnumerator>(ref TypeBatch, int, ref TEnumerator) Enumerates the set of body references associated with an active constraint in order of their references within the constraint. This will report the body reference (body index if awake, handle if asleep) without any encoded kinematicity metadata. public void EnumerateConnectedBodyReferences<TEnumerator>(ref TypeBatch typeBatch, int indexInTypeBatch, ref TEnumerator enumerator) where TEnumerator : IForEach<int> Parameters typeBatch TypeBatch Type batch containing the constraint to enumerate. indexInTypeBatch int Index of the constraint to enumerate in the type batch. enumerator TEnumerator Enumerator to call for each connected body reference. Type Parameters TEnumerator Type of the enumerator to call on each connected body reference. EnumerateConnectedDynamicBodies<TEnumerator>(ConstraintHandle, ref TEnumerator) Enumerates the set of dynamic body references associated with a constraint in order of their references within the constraint. This will report the body reference (body index if awake, handle if asleep) without any encoded kinematicity metadata. Kinematic references are skipped. public void EnumerateConnectedDynamicBodies<TEnumerator>(ConstraintHandle constraintHandle, ref TEnumerator enumerator) where TEnumerator : IForEach<int> Parameters constraintHandle ConstraintHandle Constraint to enumerate. enumerator TEnumerator Enumerator to call for each connected dynamic body reference. Type Parameters TEnumerator Type of the enumerator to call on each connected dynamic body reference. EnumerateConnectedDynamicBodies<TEnumerator>(ref TypeBatch, int, ref TEnumerator) Enumerates the set of dynamic body references associated with a constraint in order of their references within the constraint. This will report the body reference (body index if awake, handle if asleep) without any encoded kinematicity metadata. Kinematic references are skipped. public void EnumerateConnectedDynamicBodies<TEnumerator>(ref TypeBatch typeBatch, int indexInTypeBatch, ref TEnumerator enumerator) where TEnumerator : IForEach<int> Parameters typeBatch TypeBatch Type batch containing the constraint to enumerate. indexInTypeBatch int Index of the constraint to enumerate in the type batch. enumerator TEnumerator Enumerator to call for each connected dynamic body reference. Type Parameters TEnumerator Type of the enumerator to call on each connected dynamic body reference. EnumerateConnectedRawBodyReferences<TEnumerator>(ConstraintHandle, ref TEnumerator) Enumerates the set of body references associated with a constraint in order of their references within the constraint. This will report the raw body reference (body index if awake, handle if asleep) and any encoded metadata, like whether the body is kinematic. public void EnumerateConnectedRawBodyReferences<TEnumerator>(ConstraintHandle constraintHandle, ref TEnumerator enumerator) where TEnumerator : IForEach<int> Parameters constraintHandle ConstraintHandle Constraint to enumerate. enumerator TEnumerator Enumerator to call for each connected body reference. Type Parameters TEnumerator Type of the enumerator to call on each connected body reference. EnumerateConnectedRawBodyReferences<TEnumerator>(ref TypeBatch, int, ref TEnumerator) Enumerates the set of body references associated with a constraint in order of their references within the constraint. This will report the raw body reference (body index if awake, handle if asleep) and any encoded metadata, like whether the body is kinematic. public void EnumerateConnectedRawBodyReferences<TEnumerator>(ref TypeBatch typeBatch, int indexInTypeBatch, ref TEnumerator enumerator) where TEnumerator : IForEach<int> Parameters typeBatch TypeBatch Type batch containing the constraint to enumerate. indexInTypeBatch int Index of the constraint to enumerate in the type batch. enumerator TEnumerator Enumerator to call for each connected body reference. Type Parameters TEnumerator Type of the enumerator to call on each connected body reference. GetAccumulatedImpulseMagnitude(ConstraintHandle) Gathers the magnitude of the accumulated impulse for a given constraint. public float GetAccumulatedImpulseMagnitude(ConstraintHandle constraintHandle) Parameters constraintHandle ConstraintHandle Constraint to look up the accumulated impulses of. Returns float Magnitude of the accumulated impulses associated with the given constraint. GetAccumulatedImpulseMagnitudeSquared(ConstraintHandle) Gathers the squared magnitude of the accumulated impulse for a given constraint. public float GetAccumulatedImpulseMagnitudeSquared(ConstraintHandle constraintHandle) Parameters constraintHandle ConstraintHandle Constraint to look up the accumulated impulses of. Returns float Squared magnitude of the accumulated impulses associated with the given constraint. GetConstraintReference(ConstraintHandle) Gets a direct reference to the constraint associated with a handle. The reference is temporary; any constraint removals that affect the referenced type batch may invalidate the index. public ConstraintReference GetConstraintReference(ConstraintHandle handle) Parameters handle ConstraintHandle Handle index of the constraint. Returns ConstraintReference Temporary direct reference to the type batch and index in the type batch associated with the constraint handle. May be invalidated by constraint removals. GetDescription<TConstraintDescription>(ConstraintHandle, out TConstraintDescription) Gets the constraint description associated with a constraint handle. public void GetDescription<TConstraintDescription>(ConstraintHandle handle, out TConstraintDescription description) where TConstraintDescription : unmanaged, IConstraintDescription<TConstraintDescription> Parameters handle ConstraintHandle Handle of the constraint to retrieve. description TConstraintDescription Retrieved description of the constraint. Type Parameters TConstraintDescription Type of the constraint description to retrieve. GetDescription<TConstraintDescription>(ConstraintReference, out TConstraintDescription) Gets the constraint description associated with a constraint reference. public void GetDescription<TConstraintDescription>(ConstraintReference constraintReference, out TConstraintDescription description) where TConstraintDescription : unmanaged, IConstraintDescription<TConstraintDescription> Parameters constraintReference ConstraintReference Reference to the constraint to retrieve. description TConstraintDescription Retrieved description of the constraint. Type Parameters TConstraintDescription Type of the constraint description to retrieve. GetMinimumCapacityForType(int) Gets the minimum initial capacity for a given type. The returned value is the larger of MinimumCapacityPerTypeBatch and the value set by SetMinimumCapacityForType for the given type id. public int GetMinimumCapacityForType(int typeId) Parameters typeId int Type id to retrieve the minm Returns int Larger of MinimumCapacityPerTypeBatch and the given type's minimum set by SetMinimumCapacityForType. OnSubstepEnded(int) protected void OnSubstepEnded(int substepIndex) Parameters substepIndex int OnSubstepStarted(int) protected void OnSubstepStarted(int substepIndex) Parameters substepIndex int PrepareConstraintIntegrationResponsibilities(IThreadDispatcher) public abstract IndexSet PrepareConstraintIntegrationResponsibilities(IThreadDispatcher threadDispatcher = null) Parameters threadDispatcher IThreadDispatcher Returns IndexSet Register<TDescription>() Registers a constraint type with the solver, creating a type processor for the type internally and allowing constraints of that type to be added to the solver. public void Register<TDescription>() where TDescription : unmanaged, IConstraintDescription<TDescription> Type Parameters TDescription Type of the constraint to register with the solver. Remarks RegisterDefaults(Solver, NarrowPhase) is called during simuation creation and registers all the built in types. Calling Register<TDescription>() manually is only necessary if custom types are used. Exceptions ArgumentException Fired when another constraint type of the same id has already been registered. Remove(ConstraintHandle) Removes the constraint associated with the given handle. Note that this may invalidate any outstanding direct constraint references by reordering the constraints within the TypeBatch subject to removal. public void Remove(ConstraintHandle handle) Parameters handle ConstraintHandle Handle of the constraint to remove from the solver. ResetPerTypeInitialCapacities() Resets all per-type initial capacities to zero. Leaves the minimum capacity across all constraints unchanged. public void ResetPerTypeInitialCapacities() ResizeSolverCapacities(int, int) Adjusts the size of the the solvers non-typebatch data structures. An allocation is allowed to shrink if it fits both all existing entries and the given capacity. An allocation will grow if the given capacity exceeds the currently allocated capacity. public void ResizeSolverCapacities(int bodyHandleCapacity, int constraintHandleCapacity) Parameters bodyHandleCapacity int Size of the span of body handles to allocate space for. Applies to batch referenced handle sets. constraintHandleCapacity int Number of constraint handles to allocate space for. Applies to the handle->constraint mapping table. ResizeTypeBatchCapacities() Applies the current solver-defined minimum capacities to existing type batches. Type batches with capacities larger than the minimums and counts less than the minimums may be shrunk. Type batches with capacities smaller than the minimums will be enlarged. public void ResizeTypeBatchCapacities() ScaleAccumulatedImpulses(ref ConstraintSet, float) Scales the accumulated impulses associated with a constraint set by a given scale. public void ScaleAccumulatedImpulses(ref ConstraintSet set, float scale) Parameters set ConstraintSet Set to scale. scale float Scale to apply to accumulated impulses. ScaleAccumulatedImpulses(float) Scales all accumulated impulses in all constraint sets. public void ScaleAccumulatedImpulses(float scale) Parameters scale float Scale to apply to accumulated impulses. ScaleActiveAccumulatedImpulses(float) Scales all accumulated impulses in the active set. public void ScaleActiveAccumulatedImpulses(float scale) Parameters scale float Scale to apply to accumulated impulses. SetMinimumCapacityForType(int, int) Sets the minimum capacity initially allocated to a new type batch of the given type. public void SetMinimumCapacityForType(int typeId, int minimumInitialCapacityForType) Parameters typeId int Id of the constraint type to check the initial capacity of. minimumInitialCapacityForType int Minimum capacity to use for the type. Solve(float, IThreadDispatcher) public abstract void Solve(float dt, IThreadDispatcher threadDispatcher = null) Parameters dt float threadDispatcher IThreadDispatcher Events SubstepEnded Event invoked when the solver completes a substep. If the solver is executing on multiple threads, this will be invoked within the multithreaded dispatch on worker thread 0. public event Solver.SubstepEvent SubstepEnded Event Type Solver.SubstepEvent Remarks Take care when attempting to dispatch multithreaded operations from within this event. If using the same BepuUtilities.IThreadDispatcher instance as the solver, the dispatcher implementation must be reentrant. The demos implementation is not. SubstepStarted Event invoked when the solver begins a substep. If the solver is executing on multiple threads, this will be invoked within the multithreaded dispatch on worker thread 0. public event Solver.SubstepEvent SubstepStarted Event Type Solver.SubstepEvent Remarks Take care when attempting to dispatch multithreaded operations from within this event. If using the same BepuUtilities.IThreadDispatcher instance as the solver, the dispatcher implementation must be reentrant. The demos implementation is not."
  },
  "api/BepuPhysics.Static.html": {
    "href": "api/BepuPhysics.Static.html",
    "title": "Struct Static | Bepu API",
    "keywords": "Struct Static Namespace BepuPhysics Assembly BepuPhysics.dll Stores data for a static collidable in the simulation. Statics can be posed and collide, but have no velocity and no dynamic behavior. public struct Static Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Unlike bodies, statics have a very simple access pattern. Most data is referenced together and there are no extreme high frequency data accesses like there are in the solver. Everything can be conveniently stored within a single location contiguously. Fields BroadPhaseIndex Index of the collidable in the broad phase. Used to look up the target location for bounding box scatters. Under normal circumstances, this should not be set externally. public int BroadPhaseIndex Field Value int Continuity Continuous collision detection settings for this collidable. Includes the collision detection mode to use and tuning variables associated with those modes. public ContinuousDetection Continuity Field Value ContinuousDetection Remarks Note that statics cannot move, so there is no difference between Discrete and Passive for them. Enabling Continuous will still require that pairs associated with the static use swept continuous collision detection. Pose Pose of the static collidable. public RigidPose Pose Field Value RigidPose Shape Index of the shape used by the static. While this can be changed, any transition from shapeless->shapeful or shapeful->shapeless must be reported to the broad phase. If you need to perform such a transition, consider using SetShape(StaticHandle, TypedIndex) or Statics.ApplyDescription; those functions update the relevant state. public TypedIndex Shape Field Value TypedIndex"
  },
  "api/BepuPhysics.StaticDescription.html": {
    "href": "api/BepuPhysics.StaticDescription.html",
    "title": "Struct StaticDescription | Bepu API",
    "keywords": "Struct StaticDescription Namespace BepuPhysics Assembly BepuPhysics.dll Describes the properties of a static object. When added to a simulation, static objects can collide but have no velocity and will not move in response to forces. public struct StaticDescription Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors StaticDescription(RigidPose, TypedIndex) Builds a new static description with Discrete continuity. public StaticDescription(RigidPose pose, TypedIndex shape) Parameters pose RigidPose Pose of the static collidable. shape TypedIndex Shape of the static. StaticDescription(RigidPose, TypedIndex, ContinuousDetection) Builds a new static description. public StaticDescription(RigidPose pose, TypedIndex shape, ContinuousDetection continuity) Parameters pose RigidPose Pose of the static collidable. shape TypedIndex Shape of the static. continuity ContinuousDetection Continuous collision detection settings for the static. StaticDescription(Vector3, Quaternion, TypedIndex) Builds a new static description with Discrete continuity. public StaticDescription(Vector3 position, Quaternion orientation, TypedIndex shape) Parameters position Vector3 Position of the static. orientation Quaternion Orientation of the static. shape TypedIndex Shape of the static. StaticDescription(Vector3, Quaternion, TypedIndex, ContinuousDetection) Builds a new static description. public StaticDescription(Vector3 position, Quaternion orientation, TypedIndex shape, ContinuousDetection continuity) Parameters position Vector3 Position of the static. orientation Quaternion Orientation of the static. shape TypedIndex Shape of the static. continuity ContinuousDetection Continuous collision detection settings for the static. Fields Continuity Continuous collision detection settings for the static. public ContinuousDetection Continuity Field Value ContinuousDetection Pose Position and orientation of the static. public RigidPose Pose Field Value RigidPose Shape Shape of the static. public TypedIndex Shape Field Value TypedIndex"
  },
  "api/BepuPhysics.StaticHandle.html": {
    "href": "api/BepuPhysics.StaticHandle.html",
    "title": "Struct StaticHandle | Bepu API",
    "keywords": "Struct StaticHandle Namespace BepuPhysics Assembly BepuPhysics.dll Unique identifier of a static belonging to a simulation's Statics collection. public struct StaticHandle : IEquatable<StaticHandle>, IEqualityComparerRef<StaticHandle> Implements IEquatable<StaticHandle> IEqualityComparerRef<StaticHandle> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors StaticHandle(int) public StaticHandle(int value) Parameters value int Fields Value Index in the handle-to-memory mapping table used to look up the current memory location of the body. This value will not (and must not) change during the body's lifespan, but the memory that the table points to could change. public int Value Field Value int Methods Equals(StaticHandle) Indicates whether the current object is equal to another object of the same type. public bool Equals(StaticHandle other) Parameters other StaticHandle An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(ref StaticHandle, ref StaticHandle) public bool Equals(ref StaticHandle a, ref StaticHandle b) Parameters a StaticHandle b StaticHandle Returns bool Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. Hash(ref StaticHandle) public int Hash(ref StaticHandle item) Parameters item StaticHandle Returns int ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(StaticHandle, StaticHandle) public static bool operator ==(StaticHandle a, StaticHandle b) Parameters a StaticHandle b StaticHandle Returns bool operator !=(StaticHandle, StaticHandle) public static bool operator !=(StaticHandle a, StaticHandle b) Parameters a StaticHandle b StaticHandle Returns bool"
  },
  "api/BepuPhysics.StaticReference.html": {
    "href": "api/BepuPhysics.StaticReference.html",
    "title": "Struct StaticReference | Bepu API",
    "keywords": "Struct StaticReference Namespace BepuPhysics Assembly BepuPhysics.dll Convenience structure for directly referring to a static's properties. public struct StaticReference Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Note that this type makes no attempt to protect against unsafe modification of static properties. Constructors StaticReference(StaticHandle, Statics) Constructs a new static reference. public StaticReference(StaticHandle handle, Statics statics) Parameters handle StaticHandle Handle of the static to refer to. statics Statics Collection containing the static. Fields Handle Handle of the static that this reference refers to. public StaticHandle Handle Field Value StaticHandle Statics The collection containing the static. public Statics Statics Field Value Statics Properties BoundingBox Gets a copy of the static's bounding box. public BoundingBox BoundingBox { get; } Property Value BoundingBox CollidableReference Gets a CollidableReference for this static. CollidableReferences uniquely identify a collidable object in a simulation by including both the dynamic/kinematic/static state of the object and its handle. Despite an unfortunate naming collision, CollidableReferences are distinct from a direct reference to a static's collidable data, which you can get from the Collidable property. public CollidableReference CollidableReference { get; } Property Value CollidableReference Continuity Gets a reference to the static's collision continuity settings. public ref ContinuousDetection Continuity { get; } Property Value ContinuousDetection Exists Gets whether the static reference exists within the static set. True if the handle maps to a valid memory location that agrees that the handle points to it, false otherwise. public bool Exists { get; } Property Value bool Index Gets a the static's index in the statics collection. public int Index { get; } Property Value int Pose Gets a reference to the static's pose. public ref RigidPose Pose { get; } Property Value RigidPose Shape Gets the shape used by the static. To set the shape, use SetShape(TypedIndex) or ApplyDescription(in StaticDescription). public TypedIndex Shape { get; } Property Value TypedIndex Static Gets a reference to the entirety of the static's memory. public ref Static Static { get; } Property Value Static Methods ApplyDescription(in StaticDescription) Sets a static's properties according to a description. public void ApplyDescription(in StaticDescription description) Parameters description StaticDescription Description of the static. GetBoundsReferencesFromBroadPhase(out Vector3*, out Vector3*) Gets direct pointers to the static's bounding box minimum and maximum in the broad phase. Outputs null if the static has no shape. public void GetBoundsReferencesFromBroadPhase(out Vector3* min, out Vector3* max) Parameters min Vector3* Pointer to the bounding box minimum in the broad phase. max Vector3* Pointer to the bounding box maximum in the broad phase. GetDescription() Gets a description of the static. public StaticDescription GetDescription() Returns StaticDescription Description of the static. GetDescription(out StaticDescription) Gets a description of the static. public void GetDescription(out StaticDescription description) Parameters description StaticDescription Description of the static. SetShape(TypedIndex) Changes the shape of a static. public void SetShape(TypedIndex newShape) Parameters newShape TypedIndex Index of the new shape to use for the static. UpdateBounds() Updates the static's bounds in the broad phase for its current state. Does not include velocity expansion. Does nothing if the static has no shape. public void UpdateBounds() Remarks Can be useful if you made modifications to the static's state that you want reflected in the broad phase before the next timestep. For example, if you want to perform ray casts against the broad phase after moving objects around directly, their bounds must be updated or else the broad phase bounds will be out of date and the ray will likely miss."
  },
  "api/BepuPhysics.Statics.html": {
    "href": "api/BepuPhysics.Statics.html",
    "title": "Class Statics | Bepu API",
    "keywords": "Class Statics Namespace BepuPhysics Assembly BepuPhysics.dll Collection of allocated statics. public class Statics Inheritance object Statics Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Statics(BufferPool, Shapes, Bodies, BroadPhase, int) public Statics(BufferPool pool, Shapes shapes, Bodies bodies, BroadPhase broadPhase, int initialCapacity = 4096) Parameters pool BufferPool shapes Shapes bodies Bodies broadPhase BroadPhase initialCapacity int Fields Count public int Count Field Value int HandlePool public IdPool HandlePool Field Value IdPool HandleToIndex Remaps a static handle integer value to the actual array index of the static. public Buffer<int> HandleToIndex Field Value Buffer<int> IndexToHandle Remaps a static index to its handle. public Buffer<StaticHandle> IndexToHandle Field Value Buffer<StaticHandle> StaticsBuffer The set of collidables owned by each static. Speculative margins, continuity settings, and shape indices can be changed directly. Shape indices cannot transition between pointing at a shape and pointing at nothing or vice versa without notifying the broad phase of the collidable addition or removal. Consider using SetShape(StaticHandle, TypedIndex) or ApplyDescription(StaticHandle, in StaticDescription) to handle the bookkeeping changes automatically if changing the shape. public Buffer<Static> StaticsBuffer Field Value Buffer<Static> pool protected BufferPool pool Field Value BufferPool Properties this[StaticHandle] Gets a reference to the memory backing a static collidable. The StaticReference type is a helper that exposes common operations for statics. public StaticReference this[StaticHandle handle] { get; } Parameters handle StaticHandle Handle of the static to retrieve a reference for. Property Value StaticReference Reference to the memory backing a static collidable. Remarks Equivalent to GetStaticReference(StaticHandle). this[int] Gets a reference to the raw memory backing a static collidable. public ref Static this[int index] { get; } Parameters index int Index of the static to retrieve a memory reference for. Property Value Static Direct reference to the memory backing a static collidable. Methods Add(in StaticDescription) Adds a new static body to the simulation. All sleeping dynamic bodies whose bounding boxes overlap the new static are forced active. public StaticHandle Add(in StaticDescription description) Parameters description StaticDescription Description of the static to add. Returns StaticHandle Handle of the new static. AddWithoutAwakeningBodies(in StaticDescription) Adds a new static body to the simulation. No attempt is made to awaken sleeping bodies near the static. public StaticHandle AddWithoutAwakeningBodies(in StaticDescription description) Parameters description StaticDescription Description of the static to add. Returns StaticHandle Handle of the new static. Remarks For most use cases, defaulting to the Add(in StaticDescription) function is recommended; it can help avoid surprising behavior by waking up sleeping bodies near the new static. The query does, however, carry a nonzero cost. If many statics are being added at once, particularly if the new statics overlap with a lot of existing statics, and there's no need to awaken sleeping bodies, this function can be used to avoid the cost of the query. Other custom filters can be used to control which bodies are awoken; see Add<TAwakeningFilter>(in StaticDescription, ref TAwakeningFilter) and the IStaticChangeAwakeningFilter interface. Add<TAwakeningFilter>(in StaticDescription, ref TAwakeningFilter) Adds a new static body to the simulation. All sleeping bodies whose bounding boxes overlap the new static and pass the given filter are forced active. public StaticHandle Add<TAwakeningFilter>(in StaticDescription description, ref TAwakeningFilter filter) where TAwakeningFilter : struct, IStaticChangeAwakeningFilter Parameters description StaticDescription Description of the static to add. filter TAwakeningFilter Filter to apply to sleeping bodies near the new static to see if they should be awoken. Returns StaticHandle Handle of the new static. Type Parameters TAwakeningFilter Type of the filter to apply to sleeping bodies. ApplyDescription(StaticHandle, in StaticDescription) Applies a new description to an existing static object. All sleeping bodies with bounding boxes overlapping the old or new static collidable and pass the given filter are forced active. Updates the bounds of the static in the broad phase. public void ApplyDescription(StaticHandle handle, in StaticDescription description) Parameters handle StaticHandle Handle of the static to apply the description to. description StaticDescription Description to apply to the static. ApplyDescription<TAwakeningFilter>(StaticHandle, in StaticDescription, ref TAwakeningFilter) Applies a new description to an existing static object. All sleeping bodies with bounding boxes overlapping the old or new static collidable and pass the given filter are forced active. Updates the bounds of the static in the broad phase. public void ApplyDescription<TAwakeningFilter>(StaticHandle handle, in StaticDescription description, ref TAwakeningFilter filter) where TAwakeningFilter : struct, IStaticChangeAwakeningFilter Parameters handle StaticHandle Handle of the static to apply the description to. description StaticDescription Description to apply to the static. filter TAwakeningFilter Filter to apply to sleeping bodies near the static to see if they should be awoken. Type Parameters TAwakeningFilter Type of the filter to apply to sleeping bodies. Clear() Clears all bodies from the set without returning any memory to the pool. public void Clear() Dispose() Returns all static resources to the pool used to create them. public void Dispose() Remarks The object can be reused if it is reinitialized by using EnsureCapacity or Resize. EnsureCapacity(int) Increases the size of buffers if needed to hold the target capacity. public void EnsureCapacity(int capacity) Parameters capacity int Target data capacity. GetDescription(StaticHandle) Gets the current description of the static referred to by a given handle. public StaticDescription GetDescription(StaticHandle handle) Parameters handle StaticHandle Handle of the static to look up the description of. Returns StaticDescription Gathered description of the handle-referenced static. GetDescription(StaticHandle, out StaticDescription) Gets the current description of the static referred to by a given handle. public void GetDescription(StaticHandle handle, out StaticDescription description) Parameters handle StaticHandle Handle of the static to look up the description of. description StaticDescription Gathered description of the handle-referenced static. GetDirectReference(StaticHandle) Gets a direct reference to the memory backing a static. public ref Static GetDirectReference(StaticHandle handle) Parameters handle StaticHandle Handle of the static to get a reference of. Returns Static Direct reference to the memory backing a static. Remarks This is distinct from the this[StaticHandle] indexer in that this returns the direct memory reference. StaticReference includes a layer of indirection that can expose more features. GetStaticReference(StaticHandle) Gets a reference to a static by its handle. public StaticReference GetStaticReference(StaticHandle handle) Parameters handle StaticHandle Handle of the static to grab a reference of. Returns StaticReference Reference to the desired static. Remove(StaticHandle) Removes a static from the set. Any sleeping dynamic bodies with bounding boxes overlapping the removed static's bounding box will be forced active. public void Remove(StaticHandle handle) Parameters handle StaticHandle Handle of the static to remove. RemoveAt(int) Removes a static from the set by index. Any sleeping dynamic bodies with bounding boxes overlapping the removed static's bounding box will be forced active. public void RemoveAt(int index) Parameters index int Index of the static to remove. RemoveAt<TAwakeningFilter>(int, ref TAwakeningFilter) Removes a static from the set by index. Any sleeping bodies with bounding boxes overlapping the removed static's bounding box and passing the given filter will be forced awake. public void RemoveAt<TAwakeningFilter>(int index, ref TAwakeningFilter filter) where TAwakeningFilter : struct, IStaticChangeAwakeningFilter Parameters index int Index of the static to remove. filter TAwakeningFilter Filter to apply to sleeping bodies near the removed static to see if they should be awoken. Type Parameters TAwakeningFilter Type of the filter to apply to sleeping bodies. Remove<TAwakeningFilter>(StaticHandle, ref TAwakeningFilter) Removes a static from the set. Any sleeping bodies with bounding boxes overlapping the removed static's bounding box and passing the given filter will be forced active. public void Remove<TAwakeningFilter>(StaticHandle handle, ref TAwakeningFilter filter) where TAwakeningFilter : struct, IStaticChangeAwakeningFilter Parameters handle StaticHandle Handle of the static to remove. filter TAwakeningFilter Filter to apply to sleeping bodies near the removed static to see if they should be awoken. Type Parameters TAwakeningFilter Type of the filter to apply to sleeping bodies. Resize(int) Resizes the allocated spans for static data. Note that this is conservative; it will never orphan existing objects. public void Resize(int capacity) Parameters capacity int Target static data capacity. SetShape(StaticHandle, TypedIndex) Changes the shape of a static and updates its bounds in the broad phase. All sleeping dyanmic bodies with bounding boxes overlapping the old or new static collidable are forced active. public void SetShape(StaticHandle handle, TypedIndex newShape) Parameters handle StaticHandle Handle of the static to change the shape of. newShape TypedIndex Index of the new shape to use for the static. SetShape<TAwakeningFilter>(StaticHandle, TypedIndex, ref TAwakeningFilter) Changes the shape of a static and updates its bounds in the broad phase. All sleeping bodies with bounding boxes overlapping the old or new static collidable and pass the given filter are forced active. public void SetShape<TAwakeningFilter>(StaticHandle handle, TypedIndex newShape, ref TAwakeningFilter filter) where TAwakeningFilter : struct, IStaticChangeAwakeningFilter Parameters handle StaticHandle Handle of the static to change the shape of. newShape TypedIndex Index of the new shape to use for the static. filter TAwakeningFilter Filter to apply to sleeping bodies near the static to see if they should be awoken. Type Parameters TAwakeningFilter Type of the filter to apply to sleeping bodies. StaticExists(StaticHandle) Checks whether a static handle is currently registered with the statics set. public bool StaticExists(StaticHandle handle) Parameters handle StaticHandle Handle to check for. Returns bool True if the handle exists in the collection, false otherwise. UpdateBounds(StaticHandle) Updates the bounds held within the broad phase for the static's current state. public void UpdateBounds(StaticHandle handle) Parameters handle StaticHandle"
  },
  "api/BepuPhysics.StaticsShouldntAwakenBodies.html": {
    "href": "api/BepuPhysics.StaticsShouldntAwakenBodies.html",
    "title": "Struct StaticsShouldntAwakenBodies | Bepu API",
    "keywords": "Struct StaticsShouldntAwakenBodies Namespace BepuPhysics Assembly BepuPhysics.dll Awakening filter that prevents any bodies from being awoken by the static's state change. public struct StaticsShouldntAwakenBodies : IStaticChangeAwakeningFilter Implements IStaticChangeAwakeningFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AllowAwakening Gets whether to allow awakening for any body. If true, candidates will have the ShouldAwaken function called for them. If false, ShouldAwaken will not be called, and no bodies will be awoken. public bool AllowAwakening { get; } Property Value bool Methods ShouldAwaken(BodyReference) Determines whether a body should be forced awake by the state change of a static. public bool ShouldAwaken(BodyReference body) Parameters body BodyReference Sleeping body under consideration for awakening. Returns bool True if the body should be forced awake, false otherwise."
  },
  "api/BepuPhysics.StaticsShouldntAwakenKinematics.html": {
    "href": "api/BepuPhysics.StaticsShouldntAwakenKinematics.html",
    "title": "Struct StaticsShouldntAwakenKinematics | Bepu API",
    "keywords": "Struct StaticsShouldntAwakenKinematics Namespace BepuPhysics Assembly BepuPhysics.dll Default awakening filter that only wakes up dynamic bodies. Kinematic bodies do not respond to any kind of dynamic simulation, so they won't respond to the change in statics. public struct StaticsShouldntAwakenKinematics : IStaticChangeAwakeningFilter Implements IStaticChangeAwakeningFilter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties AllowAwakening Gets whether to allow awakening for any body. If true, candidates will have the ShouldAwaken function called for them. If false, ShouldAwaken will not be called, and no bodies will be awoken. public bool AllowAwakening { get; } Property Value bool Methods ShouldAwaken(BodyReference) Determines whether a body should be forced awake by the state change of a static. public bool ShouldAwaken(BodyReference body) Parameters body BodyReference Sleeping body under consideration for awakening. Returns bool True if the body should be forced awake, false otherwise."
  },
  "api/BepuPhysics.SubstepVelocityIterationScheduler.html": {
    "href": "api/BepuPhysics.SubstepVelocityIterationScheduler.html",
    "title": "Delegate SubstepVelocityIterationScheduler | Bepu API",
    "keywords": "Delegate SubstepVelocityIterationScheduler Namespace BepuPhysics Assembly BepuPhysics.dll Callback executed to determine how many velocity iterations should be used for a given substep. public delegate int SubstepVelocityIterationScheduler(int substepIndex) Parameters substepIndex int Index of the substep to schedule velocity iterations for. Returns int Number of velocity iterations to use for the substep. If nonpositive, VelocityIterationCount will be used for the substep instead."
  },
  "api/BepuPhysics.TimestepperStageHandler.html": {
    "href": "api/BepuPhysics.TimestepperStageHandler.html",
    "title": "Delegate TimestepperStageHandler | Bepu API",
    "keywords": "Delegate TimestepperStageHandler Namespace BepuPhysics Assembly BepuPhysics.dll Delegate used by ITimesteppers for their stage callbacks. public delegate void TimestepperStageHandler(float dt, IThreadDispatcher threadDispatcher) Parameters dt float Time step duration. threadDispatcher IThreadDispatcher Thread dispatcher used for this timestep."
  },
  "api/BepuPhysics.Trees.BinnedResources.html": {
    "href": "api/BepuPhysics.Trees.BinnedResources.html",
    "title": "Struct BinnedResources | Bepu API",
    "keywords": "Struct BinnedResources Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public struct BinnedResources Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields ALeafCountsX public int* ALeafCountsX Field Value int* ALeafCountsY public int* ALeafCountsY Field Value int* ALeafCountsZ public int* ALeafCountsZ Field Value int* AMergedX public BoundingBox* AMergedX Field Value BoundingBox* AMergedY public BoundingBox* AMergedY Field Value BoundingBox* AMergedZ public BoundingBox* AMergedZ Field Value BoundingBox* BinBoundingBoxesX public BoundingBox* BinBoundingBoxesX Field Value BoundingBox* BinBoundingBoxesY public BoundingBox* BinBoundingBoxesY Field Value BoundingBox* BinBoundingBoxesZ public BoundingBox* BinBoundingBoxesZ Field Value BoundingBox* BinLeafCountsX public int* BinLeafCountsX Field Value int* BinLeafCountsY public int* BinLeafCountsY Field Value int* BinLeafCountsZ public int* BinLeafCountsZ Field Value int* BinStartIndices public int* BinStartIndices Field Value int* BinSubtreeCountsSecondPass public int* BinSubtreeCountsSecondPass Field Value int* BinSubtreeCountsX public int* BinSubtreeCountsX Field Value int* BinSubtreeCountsY public int* BinSubtreeCountsY Field Value int* BinSubtreeCountsZ public int* BinSubtreeCountsZ Field Value int* BoundingBoxes public BoundingBox* BoundingBoxes Field Value BoundingBox* Centroids public Vector3* Centroids Field Value Vector3* IndexMap public int* IndexMap Field Value int* LeafCounts public int* LeafCounts Field Value int* RefineFlags public int* RefineFlags Field Value int* StagingNodes public Node* StagingNodes Field Value Node* SubtreeBinIndicesX public int* SubtreeBinIndicesX Field Value int* SubtreeBinIndicesY public int* SubtreeBinIndicesY Field Value int* SubtreeBinIndicesZ public int* SubtreeBinIndicesZ Field Value int* SubtreeHeapEntries public SubtreeHeapEntry* SubtreeHeapEntries Field Value SubtreeHeapEntry* TempIndexMap public int* TempIndexMap Field Value int*"
  },
  "api/BepuPhysics.Trees.IBatchedRayLeafTester.html": {
    "href": "api/BepuPhysics.Trees.IBatchedRayLeafTester.html",
    "title": "Interface IBatchedRayLeafTester | Bepu API",
    "keywords": "Interface IBatchedRayLeafTester Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public interface IBatchedRayLeafTester : IRayLeafTester Inherited Members IRayLeafTester.TestLeaf(int, RayData*, float*) Methods RayTest(int, ref RaySource) void RayTest(int leafIndex, ref RaySource rays) Parameters leafIndex int rays RaySource"
  },
  "api/BepuPhysics.Trees.IOverlapHandler.html": {
    "href": "api/BepuPhysics.Trees.IOverlapHandler.html",
    "title": "Interface IOverlapHandler | Bepu API",
    "keywords": "Interface IOverlapHandler Namespace BepuPhysics.Trees Assembly BepuPhysics.dll Overlap callback for tree overlap queries. public interface IOverlapHandler Methods Handle(int, int) Handles an overlap between leaves. void Handle(int indexA, int indexB) Parameters indexA int Index of the first leaf in the overlap. indexB int Index of the second leaf in the overlap."
  },
  "api/BepuPhysics.Trees.IRayLeafTester.html": {
    "href": "api/BepuPhysics.Trees.IRayLeafTester.html",
    "title": "Interface IRayLeafTester | Bepu API",
    "keywords": "Interface IRayLeafTester Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public interface IRayLeafTester Methods TestLeaf(int, RayData*, float*) void TestLeaf(int leafIndex, RayData* rayData, float* maximumT) Parameters leafIndex int rayData RayData* maximumT float*"
  },
  "api/BepuPhysics.Trees.IRaySource.html": {
    "href": "api/BepuPhysics.Trees.IRaySource.html",
    "title": "Interface IRaySource | Bepu API",
    "keywords": "Interface IRaySource Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public interface IRaySource Properties RayCount int RayCount { get; } Property Value int Methods GetRay(int) ref readonly RayData GetRay(int rayIndex) Parameters rayIndex int Returns RayData GetRay(int, out RayData*, out float*) void GetRay(int rayIndex, out RayData* ray, out float* maximumT) Parameters rayIndex int ray RayData* maximumT float*"
  },
  "api/BepuPhysics.Trees.ISweepLeafTester.html": {
    "href": "api/BepuPhysics.Trees.ISweepLeafTester.html",
    "title": "Interface ISweepLeafTester | Bepu API",
    "keywords": "Interface ISweepLeafTester Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public interface ISweepLeafTester Methods TestLeaf(int, ref float) void TestLeaf(int leafIndex, ref float maximumT) Parameters leafIndex int maximumT float"
  },
  "api/BepuPhysics.Trees.IThreadedOverlapHandler.html": {
    "href": "api/BepuPhysics.Trees.IThreadedOverlapHandler.html",
    "title": "Interface IThreadedOverlapHandler | Bepu API",
    "keywords": "Interface IThreadedOverlapHandler Namespace BepuPhysics.Trees Assembly BepuPhysics.dll Overlap callback for tree overlap queries. Used in multithreaded contexts. public interface IThreadedOverlapHandler Methods Handle(int, int, int, object) Handles an overlap between leaves. void Handle(int indexA, int indexB, int workerIndex, object managedContext) Parameters indexA int Index of the first leaf in the overlap. indexB int Index of the second leaf in the overlap. workerIndex int Index of the worker reporting the overlap. managedContext object Managed context provided by the multithreaded dispatch."
  },
  "api/BepuPhysics.Trees.Leaf.html": {
    "href": "api/BepuPhysics.Trees.Leaf.html",
    "title": "Struct Leaf | Bepu API",
    "keywords": "Struct Leaf Namespace BepuPhysics.Trees Assembly BepuPhysics.dll Pointer to a leaf's tree location. public struct Leaf Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The identity of a leaf is implicit in its position within the leaf array. Constructors Leaf(int, int) public Leaf(int nodeIndex, int childIndex) Parameters nodeIndex int childIndex int Properties ChildIndex Gets which child within the owning node the leaf is in. public int ChildIndex { get; } Property Value int NodeIndex Gets the index of the node that the leaf is directly held by. public int NodeIndex { get; } Property Value int"
  },
  "api/BepuPhysics.Trees.Metanode.html": {
    "href": "api/BepuPhysics.Trees.Metanode.html",
    "title": "Struct Metanode | Bepu API",
    "keywords": "Struct Metanode Namespace BepuPhysics.Trees Assembly BepuPhysics.dll Metadata associated with a 2-child tree node. public struct Metanode Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields IndexInParent public int IndexInParent Field Value int LocalCostChange Cached change in cost of the tree starting at this node since the previous frame. The local cost change is unioned with the refine flags. They're never used simultaneously. This will be overwritten right after use, so don't expect anything meaningful here outside of refinement scheduling's scope. public float LocalCostChange Field Value float Parent public int Parent Field Value int RefineFlag public int RefineFlag Field Value int"
  },
  "api/BepuPhysics.Trees.Node.html": {
    "href": "api/BepuPhysics.Trees.Node.html",
    "title": "Struct Node | Bepu API",
    "keywords": "Struct Node Namespace BepuPhysics.Trees Assembly BepuPhysics.dll 2-wide tree node. public struct Node Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields A public NodeChild A Field Value NodeChild B public NodeChild B Field Value NodeChild"
  },
  "api/BepuPhysics.Trees.NodeChild.html": {
    "href": "api/BepuPhysics.Trees.NodeChild.html",
    "title": "Struct NodeChild | Bepu API",
    "keywords": "Struct NodeChild Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public struct NodeChild Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Index public int Index Field Value int LeafCount public int LeafCount Field Value int Max public Vector3 Max Field Value Vector3 Min public Vector3 Min Field Value Vector3"
  },
  "api/BepuPhysics.Trees.RayBatcher.html": {
    "href": "api/BepuPhysics.Trees.RayBatcher.html",
    "title": "Struct RayBatcher | Bepu API",
    "keywords": "Struct RayBatcher Namespace BepuPhysics.Trees Assembly BepuPhysics.dll Reusable structure for testing large numbers of rays against trees. public struct RayBatcher : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors RayBatcher(BufferPool, int, int) Constructs a ray batcher and initializes its backing resources. public RayBatcher(BufferPool pool, int rayCapacity = 2048, int treeDepthForPreallocation = 24) Parameters pool BufferPool Pool to pull resources from. rayCapacity int Maximum number of rays to execute in each traversal. This should typically be chosen as the highest value which avoids spilling data out of L2 cache. treeDepthForPreallocation int Tree depth to preallocate ray stack space for. If a traversal finds nodes deeper than this, a dynamic resize will be triggered. Properties RayCapacity public readonly int RayCapacity { get; } Property Value int RayCount public readonly int RayCount { get; } Property Value int Methods Add(ref Vector3, ref Vector3, float, int) Adds a ray to the batcher. Returns true if the batcher has reached maximum ray capacity and needs to be reset in order to continue adding rays. public bool Add(ref Vector3 origin, ref Vector3 direction, float maximumT, int id = 0) Parameters origin Vector3 Origin of the ray to test against the tree. direction Vector3 Direction of the ray to test against the tree. maximumT float Maximum distance that the ray will travel in units of the ray's length. id int Identifier value for the ray. Leaf tests will have access to the id. Returns bool True if the batcher is full and requires a call to ResetRays before adding any more rays, false otherwise. Dispose() Disposes all the resources backing the ray batcher. public void Dispose() ResetRays() Resets the accumulated ray count to zero. public void ResetRays() TestRays<TLeafTester>(ref Tree, ref TLeafTester) Tests any batched rays against the given tree. public void TestRays<TLeafTester>(ref Tree tree, ref TLeafTester leafTester) where TLeafTester : IBatchedRayLeafTester Parameters tree Tree Tree to test the accumulated rays against. leafTester TLeafTester Type Parameters TLeafTester"
  },
  "api/BepuPhysics.Trees.RayData.html": {
    "href": "api/BepuPhysics.Trees.RayData.html",
    "title": "Struct RayData | Bepu API",
    "keywords": "Struct RayData Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public struct RayData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Direction public Vector3 Direction Field Value Vector3 Id public int Id Field Value int Origin public Vector3 Origin Field Value Vector3"
  },
  "api/BepuPhysics.Trees.RaySource.html": {
    "href": "api/BepuPhysics.Trees.RaySource.html",
    "title": "Struct RaySource | Bepu API",
    "keywords": "Struct RaySource Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public struct RaySource : IRaySource Implements IRaySource Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors RaySource(TreeRay*, RayData*, ushort*, int) public RaySource(TreeRay* treeRays, RayData* rays, ushort* rayPointerStack, int rayCount) Parameters treeRays TreeRay* rays RayData* rayPointerStack ushort* rayCount int Properties RayCount Gets the number of rays in the batch. public int RayCount { get; } Property Value int Methods GetRay(int) Gets a reference to the data for a ray. public ref readonly RayData GetRay(int rayIndex) Parameters rayIndex int Index of the ray to grab. Returns RayData Returns a reference to the ray in the ray source. GetRay(int, out RayData*, out float*) Gets pointers to the data for a ray. public void GetRay(int rayIndex, out RayData* ray, out float* maximumT) Parameters rayIndex int Index of the ray to grab. ray RayData* Pointer to the ray's origin and direction. Note that changing the ray's origin and direction mid-traversal will not change the path of the traversal, but it will be visible by any future leafs impacted by this ray. maximumT float* Pointer to the maximum length of the ray in units of the ray's length. Decreasing this value will prevent the traversal from visiting more distant nodes later in the traversal."
  },
  "api/BepuPhysics.Trees.SubtreeHeapEntry.html": {
    "href": "api/BepuPhysics.Trees.SubtreeHeapEntry.html",
    "title": "Struct SubtreeHeapEntry | Bepu API",
    "keywords": "Struct SubtreeHeapEntry Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public struct SubtreeHeapEntry Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Cost public float Cost Field Value float Index public int Index Field Value int"
  },
  "api/BepuPhysics.Trees.Tree.MultithreadedIntertreeTest-1.html": {
    "href": "api/BepuPhysics.Trees.Tree.MultithreadedIntertreeTest-1.html",
    "title": "Class Tree.MultithreadedIntertreeTest<TOverlapHandler> | Bepu API",
    "keywords": "Class Tree.MultithreadedIntertreeTest<TOverlapHandler> Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public class Tree.MultithreadedIntertreeTest<TOverlapHandler> where TOverlapHandler : struct, IOverlapHandler Type Parameters TOverlapHandler Inheritance object Tree.MultithreadedIntertreeTest<TOverlapHandler> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MultithreadedIntertreeTest(BufferPool) public MultithreadedIntertreeTest(BufferPool pool) Parameters pool BufferPool Fields OverlapHandlers public TOverlapHandler[] OverlapHandlers Field Value TOverlapHandler[] Pool public BufferPool Pool Field Value BufferPool TreeA public Tree TreeA Field Value Tree TreeB public Tree TreeB Field Value Tree Properties JobCount public int JobCount { get; } Property Value int Methods CompleteTest() Cleans up after a multithreaded self test. public void CompleteTest() ExecuteJob(int, int) public void ExecuteJob(int jobIndex, int workerIndex) Parameters jobIndex int workerIndex int PairTest(int) Executes a single worker of the multithreaded self test. public void PairTest(int workerIndex) Parameters workerIndex int Index of the worker executing this set of tests. PrepareJobs(ref Tree, ref Tree, TOverlapHandler[], int) Prepares the jobs associated with a self test. Must be called before a dispatch over PairTest. public void PrepareJobs(ref Tree treeA, ref Tree treeB, TOverlapHandler[] overlapHandlers, int threadCount) Parameters treeA Tree treeB Tree overlapHandlers TOverlapHandler[] Callbacks used to handle individual overlaps detected by the self test. threadCount int Number of threads to prepare jobs for."
  },
  "api/BepuPhysics.Trees.Tree.MultithreadedSelfTest-1.html": {
    "href": "api/BepuPhysics.Trees.Tree.MultithreadedSelfTest-1.html",
    "title": "Class Tree.MultithreadedSelfTest<TOverlapHandler> | Bepu API",
    "keywords": "Class Tree.MultithreadedSelfTest<TOverlapHandler> Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public class Tree.MultithreadedSelfTest<TOverlapHandler> where TOverlapHandler : struct, IOverlapHandler Type Parameters TOverlapHandler Inheritance object Tree.MultithreadedSelfTest<TOverlapHandler> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MultithreadedSelfTest(BufferPool) public MultithreadedSelfTest(BufferPool pool) Parameters pool BufferPool Fields OverlapHandlers public TOverlapHandler[] OverlapHandlers Field Value TOverlapHandler[] Pool public BufferPool Pool Field Value BufferPool Tree public Tree Tree Field Value Tree Properties JobCount public int JobCount { get; } Property Value int Methods CompleteSelfTest() Cleans up after a multithreaded self test. public void CompleteSelfTest() ExecuteJob(int, int) public void ExecuteJob(int jobIndex, int workerIndex) Parameters jobIndex int workerIndex int PairTest(int) Executes a single worker of the multithreaded self test. public void PairTest(int workerIndex) Parameters workerIndex int Index of the worker executing this set of tests. PrepareJobs(ref Tree, TOverlapHandler[], int) Prepares the jobs associated with a self test. Must be called before a dispatch over PairTest. public void PrepareJobs(ref Tree tree, TOverlapHandler[] overlapHandlers, int threadCount) Parameters tree Tree Tree to test against itself. overlapHandlers TOverlapHandler[] Callbacks used to handle individual overlaps detected by the self test. threadCount int Number of threads to prepare jobs for."
  },
  "api/BepuPhysics.Trees.Tree.NodeTimes.html": {
    "href": "api/BepuPhysics.Trees.Tree.NodeTimes.html",
    "title": "Struct Tree.NodeTimes | Bepu API",
    "keywords": "Struct Tree.NodeTimes Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public struct Tree.NodeTimes Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Binning public double Binning Field Value double CentroidPrepass public double CentroidPrepass Field Value double MTBinning public bool MTBinning Field Value bool MTPartition public bool MTPartition Field Value bool MTPrepass public bool MTPrepass Field Value bool Partition public double Partition Field Value double SubtreeCount public int SubtreeCount Field Value int TargetTaskCount public int TargetTaskCount Field Value int Total public double Total Field Value double"
  },
  "api/BepuPhysics.Trees.Tree.RefitAndRefineMultithreadedContext.html": {
    "href": "api/BepuPhysics.Trees.Tree.RefitAndRefineMultithreadedContext.html",
    "title": "Class Tree.RefitAndRefineMultithreadedContext | Bepu API",
    "keywords": "Class Tree.RefitAndRefineMultithreadedContext Namespace BepuPhysics.Trees Assembly BepuPhysics.dll Caches input and output for the multithreaded execution of a tree's refit and refinement operations. public class Tree.RefitAndRefineMultithreadedContext Inheritance object Tree.RefitAndRefineMultithreadedContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RefitAndRefineMultithreadedContext() public RefitAndRefineMultithreadedContext() Fields MaximumSubtrees public int MaximumSubtrees Field Value int RefinementTargets public QuickList<int> RefinementTargets Field Value QuickList<int> RefitNodes public QuickList<int> RefitNodes Field Value QuickList<int> Methods CleanUpForRefitAndRefine(BufferPool) public void CleanUpForRefitAndRefine(BufferPool pool) Parameters pool BufferPool CreateRefinementJobs(BufferPool, int, float) public void CreateRefinementJobs(BufferPool pool, int frameIndex, float refineAggressivenessScale = 1) Parameters pool BufferPool frameIndex int refineAggressivenessScale float CreateRefitAndMarkJobs(ref Tree, BufferPool, IThreadDispatcher) public void CreateRefitAndMarkJobs(ref Tree tree, BufferPool pool, IThreadDispatcher threadDispatcher) Parameters tree Tree pool BufferPool threadDispatcher IThreadDispatcher ExecuteRefineJob(ref QuickList<int>, ref QuickList<int>, ref BinnedResources, BufferPool, int) public void ExecuteRefineJob(ref QuickList<int> subtreeReferences, ref QuickList<int> treeletInternalNodes, ref BinnedResources resources, BufferPool threadPool, int refineIndex) Parameters subtreeReferences QuickList<int> treeletInternalNodes QuickList<int> resources BinnedResources threadPool BufferPool refineIndex int ExecuteRefitAndMarkJob(BufferPool, int, int) public void ExecuteRefitAndMarkJob(BufferPool threadPool, int workerIndex, int refitIndex) Parameters threadPool BufferPool workerIndex int refitIndex int RefineForWorker(int) public void RefineForWorker(int workerIndex) Parameters workerIndex int RefitAndMarkForWorker(int) public void RefitAndMarkForWorker(int workerIndex) Parameters workerIndex int RefitAndRefine(ref Tree, BufferPool, IThreadDispatcher, int, float) public void RefitAndRefine(ref Tree tree, BufferPool pool, IThreadDispatcher threadDispatcher, int frameIndex, float refineAggressivenessScale = 1) Parameters tree Tree pool BufferPool threadDispatcher IThreadDispatcher frameIndex int refineAggressivenessScale float"
  },
  "api/BepuPhysics.Trees.Tree.html": {
    "href": "api/BepuPhysics.Trees.Tree.html",
    "title": "Struct Tree | Bepu API",
    "keywords": "Struct Tree Namespace BepuPhysics.Trees Assembly BepuPhysics.dll public struct Tree Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Tree(BufferPool, int) Constructs an empty tree. public Tree(BufferPool pool, int initialLeafCapacity = 4096) Parameters pool BufferPool Buffer pool to use to allocate resources in the tree. initialLeafCapacity int Initial number of leaves to allocate room for. Tree(Span<byte>, BufferPool) Loads a tree from a byte buffer created by the Serialize function. public Tree(Span<byte> data, BufferPool pool) Parameters data Span<byte> Data to load into the tree. pool BufferPool Pool to use to create the tree. Fields LeafCount Number of leaves in the tree. public int LeafCount Field Value int Leaves Buffer of leaves in the tree. public Buffer<Leaf> Leaves Field Value Buffer<Leaf> Metanodes Buffer of metanodes in the tree. Metanodes contain metadata that aren't read during most query operations but are useful for bookkeeping. public Buffer<Metanode> Metanodes Field Value Buffer<Metanode> NodeCount Number of nodes in the tree. public int NodeCount Field Value int Nodes Buffer of nodes in the tree. public Buffer<Node> Nodes Field Value Buffer<Node> Times public static Tree.NodeTimes[] Times Field Value NodeTimes[] Methods Add(BoundingBox, BufferPool) Adds a leaf to the tree with the given bounding box and returns the index of the added leaf. public int Add(BoundingBox bounds, BufferPool pool) Parameters bounds BoundingBox Extents of the leaf bounds. pool BufferPool Resource pool to use if resizing is required. Returns int Index of the leaf allocated in the tree's leaf array. Remarks Performs incrementally refining tree rotations down along the insertion path, unlike AddWithoutRefinement(BoundingBox, BufferPool). For a given tree, this is slightly slower than AddWithoutRefinement(BoundingBox, BufferPool) and slightly faster than AddWithBottomUpRefinement(BoundingBox, BufferPool). Trees built with repeated insertions of this kind tend to have decent quality, but slightly worse than AddWithBottomUpRefinement(BoundingBox, BufferPool). AddWithBottomUpRefinement(BoundingBox, BufferPool) Adds a leaf to the tree with the given bounding box and returns the index of the added leaf. public int AddWithBottomUpRefinement(BoundingBox bounds, BufferPool pool) Parameters bounds BoundingBox Extents of the leaf bounds. pool BufferPool Resource pool to use if resizing is required. Returns int Index of the leaf allocated in the tree's leaf array. Remarks Performs incrementally refining tree rotations up along the insertion path, unlike AddWithoutRefinement(BoundingBox, BufferPool). Trees built with repeated insertions of this kind tend to have slightly better quality than Add(BoundingBox, BufferPool), but it is also slightly more expensive. AddWithoutRefinement(BoundingBox, BufferPool) Adds a leaf to the tree with the given bounding box and returns the index of the added leaf. public int AddWithoutRefinement(BoundingBox bounds, BufferPool pool) Parameters bounds BoundingBox Extents of the leaf bounds. pool BufferPool Resource pool to use if resizing is required. Returns int Index of the leaf allocated in the tree's leaf array. Remarks This performs no incremental refinement. When acting on the same tree, it's slightly cheaper than Add(BoundingBox, BufferPool), but the quality of the tree depends on insertion order. Pathological insertion orders can result in a maximally imbalanced tree, quadratic insertion times across the full tree build, and query performance linear in the number of leaves. This is typically best reserved for cases where the insertion order is known to be randomized or otherwise conducive to building decent trees. BinnedBuild(Buffer<NodeChild>, BufferPool, IThreadDispatcher, TaskStack*, int, int, int, int, int, int, float, int, bool) Runs a binned build across the subtrees buffer. public void BinnedBuild(Buffer<NodeChild> subtrees, BufferPool pool = null, IThreadDispatcher dispatcher = null, TaskStack* taskStackPointer = null, int workerIndex = 0, int workerCount = -1, int targetTaskCount = -1, int maximumSubtreeStackAllocationCount = 4096, int minimumBinCount = 16, int maximumBinCount = 64, float leafToBinMultiplier = 0.0625, int microsweepThreshold = 64, bool deterministic = false) Parameters subtrees Buffer<NodeChild> Subtrees (either leaves or nodes) to run the builder over. The builder may make in-place modifications to the input buffer; the input buffer should not be assumed to be in a valid state after the builder runs. pool BufferPool Buffer pool used to preallocate a pingpong buffer if the number of subtrees exceeds maximumSubtreeStackAllocationCount. If null, stack allocation or a slower in-place partitioning will be used. A pool must be provided if a thread dispatcher is given. dispatcher IThreadDispatcher Dispatcher used to multithread the execution of the build. If the dispatcher is not null, pool must also not be null. taskStackPointer TaskStack* Task stack being used to run the build process, if any. If provided, the builder assumes the refinement is running within an existing multithreaded dispatch and will not call IThreadDispatcher.DispatchWorkers. If null, the builder will create its own task stack and call IThreadDispatcher.DispatchWorkers internally. workerIndex int Index of the currently executing worker. If not running within a dispatch, 0 is valid. workerCount int Number of workers that may be used in the builder. This should span all worker indices that may contribute to the build process even only a subset are expected to be used at any one time. If negative, the dispatcher's thread count will be used. targetTaskCount int Number of tasks to try to use in the builder. If negative, the dispatcher's thread count will be used. maximumSubtreeStackAllocationCount int Maximum number of subtrees to try putting on the stack for the binned builder's pong buffers. Subtree counts larger than this threshold will either resort to a buffer pool allocation (if available) or slower in-place partition operations. minimumBinCount int Minimum number of bins the builder should use per node. maximumBinCount int Maximum number of bins the builder should use per node. leafToBinMultiplier float Multiplier to apply to the subtree count within a node to decide the bin count. Resulting value will then be clamped by the minimum/maximum bin counts. microsweepThreshold int Threshold at or under which the binned builder resorts to local counting sort sweeps. deterministic bool Whether to force determinism at a slightly higher cost when using internally multithreaded execution. If the build is single threaded, it is already deterministic and this flag has no effect. BinnedBuild(Buffer<NodeChild>, Buffer<Node>, Buffer<Metanode>, Buffer<Leaf>, BufferPool, IThreadDispatcher, TaskStack*, int, int, int, int, int, int, float, int, bool) Runs a multithreaded binned build across the subtrees buffer. public static void BinnedBuild(Buffer<NodeChild> subtrees, Buffer<Node> nodes, Buffer<Metanode> metanodes, Buffer<Leaf> leaves, BufferPool pool = null, IThreadDispatcher dispatcher = null, TaskStack* taskStackPointer = null, int workerIndex = 0, int workerCount = -1, int targetTaskCount = -1, int maximumSubtreeStackAllocationCount = 4096, int minimumBinCount = 16, int maximumBinCount = 64, float leafToBinMultiplier = 0.0625, int microsweepThreshold = 64, bool deterministic = false) Parameters subtrees Buffer<NodeChild> Subtrees (either leaves or nodes) to run the builder over. The builder may make in-place modifications to the input buffer; the input buffer should not be assumed to be in a valid state after the builder runs. nodes Buffer<Node> Buffer holding the nodes created by the build process. Nodes are created in a depth first ordering with respect to the input buffer. metanodes Buffer<Metanode> Buffer holding the metanodes created by the build process. Metanodes, like nodes, are created in a depth first ordering with respect to the input buffer. Metanodes are in the same order and in the same slots; they simply contain data about nodes that most traversals don't need to know about. leaves Buffer<Leaf> Buffer holding the leaf references created by the build process. The indices written by the build process are those defined in the inputs; any Index that is negative is encoded according to Encode(int) and points into the leaf buffer. If a default-valued (unallocated) buffer is passed in, the binned builder will ignore leaves. pool BufferPool Buffer pool used to preallocate a pingpong buffer if the number of subtrees exceeds maximumSubtreeStackAllocationCount. If null, stack allocation or a slower in-place partitioning will be used. Dispatcher used to multithread the execution of the build. If the dispatcher is not null, pool must also not be null. Task stack being used to run the build process, if any. If provided, the builder assumes the refinement is running within an existing multithreaded dispatch and will not call IThreadDispatcher.DispatchWorkers. If null, the builder will create its own task stack and call IThreadDispatcher.DispatchWorkers internally. A pool must be provided if a thread dispatcher is given. dispatcher IThreadDispatcher taskStackPointer TaskStack* workerIndex int Index of the currently executing worker. If not running within a dispatch, 0 is valid. workerCount int Number of workers that may be used in the builder. This should span all worker indices that may contribute to the build process even only a subset are expected to be used at any one time. If negative, the dispatcher's thread count will be used. targetTaskCount int Number of tasks to try to use in the builder. If negative, the dispatcher's thread count will be used. maximumSubtreeStackAllocationCount int Maximum number of subtrees to try putting on the stack for the binned builder's pong buffers. Subtree counts larger than this threshold will either resort to a buffer pool allocation (if available) or slower in-place partition operations. minimumBinCount int Minimum number of bins the builder should use per node. maximumBinCount int Maximum number of bins the builder should use per node. leafToBinMultiplier float Multiplier to apply to the subtree count within a node to decide the bin count. Resulting value will then be clamped by the minimum/maximum bin counts. microsweepThreshold int Threshold at or under which the binned builder resorts to local counting sort sweeps. deterministic bool Whether to force determinism at a slightly higher cost when using internally multithreaded execution. If the build is single threaded, it is already deterministic and this flag has no effect. BinnedRefine(int, ref QuickList<int>, int, ref QuickList<int>, ref BinnedResources, BufferPool) public void BinnedRefine(int nodeIndex, ref QuickList<int> subtreeReferences, int maximumSubtrees, ref QuickList<int> treeletInternalNodes, ref BinnedResources resources, BufferPool pool) Parameters nodeIndex int subtreeReferences QuickList<int> maximumSubtrees int treeletInternalNodes QuickList<int> resources BinnedResources pool BufferPool CacheOptimize(int) Begins a cache optimization at the given node and proceeds all the way to the bottom of the tree. Requires that the targeted node is already at the global optimum position. public void CacheOptimize(int nodeIndex) Parameters nodeIndex int Node to begin the optimization process at. CacheOptimizeLimitedSubtree(int, int) Starts a cache optimization process at the target node index and the nodeOptimizationCount closest nodes in the tree. public void CacheOptimizeLimitedSubtree(int nodeIndex, int nodeOptimizationCount) Parameters nodeIndex int Node index to start the optimization process at. nodeOptimizationCount int Number of nodes to move. Remarks This optimizer will move the targeted node index to the globally optimal location if necessary. CacheOptimizeRegion(int, int) Puts all nodes starting from the given node index into depth first traversal order. If the count is larger than the number of nodes beneath the starting node, the optimization will stop early. public int CacheOptimizeRegion(int startingNodeIndex, int targetCount) Parameters startingNodeIndex int Node index to start the optimization at. targetCount int Number of nodes to try to optimize. Returns int Number of nodes optimized. Clear() Resets the tree to a fresh post-construction state, clearing out leaves and nodes but leaving the backing resources intact. public void Clear() CollectSubtrees(int, int, SubtreeHeapEntry*, ref QuickList<int>, ref QuickList<int>, out float) public void CollectSubtrees(int nodeIndex, int maximumSubtrees, SubtreeHeapEntry* entries, ref QuickList<int> subtrees, ref QuickList<int> internalNodes, out float treeletCost) Parameters nodeIndex int maximumSubtrees int entries SubtreeHeapEntry* subtrees QuickList<int> internalNodes QuickList<int> treeletCost float ComputeCacheOptimalLocation(int) Computes the index where the given node would be located if the tree were in depth first traversal order. public int ComputeCacheOptimalLocation(int nodeIndex) Parameters nodeIndex int Node index to find the location for in a depth first traversal order. Returns int Target index of the node if the tree were in depth first traversal order. ComputeMaximumDepth() public readonly int ComputeMaximumDepth() Returns int ConvertBoxToCentroidWithExtent(Vector3, Vector3, out Vector3, out Vector3) public static void ConvertBoxToCentroidWithExtent(Vector3 min, Vector3 max, out Vector3 origin, out Vector3 expansion) Parameters min Vector3 max Vector3 origin Vector3 expansion Vector3 CreateBinnedResources(BufferPool, int, out Buffer<byte>, out BinnedResources) public static void CreateBinnedResources(BufferPool bufferPool, int maximumSubtreeCount, out Buffer<byte> buffer, out BinnedResources resources) Parameters bufferPool BufferPool maximumSubtreeCount int buffer Buffer<byte> resources BinnedResources Dispose(BufferPool) Disposes the tree's backing resources, returning them to the Pool currently associated with the tree. public void Dispose(BufferPool pool) Parameters pool BufferPool Pool to return resources to. Remarks Disposed trees can be reused if EnsureCapacity or Resize is used to rehydrate them. Encode(int) public static int Encode(int index) Parameters index int Returns int Equals(in Tree, in Tree) Tests if two tree references point to the same data. public static bool Equals(in Tree a, in Tree b) Parameters a Tree First tree to compare. b Tree Second tree to compare. Returns bool True if the two trees have the same nodes and node count, false otherwise. GetBoundsPointers(int, out Vector3*, out Vector3*) Gets bounds pointerse for a leaf in the tree. public readonly void GetBoundsPointers(int leafIndex, out Vector3* minPointer, out Vector3* maxPointer) Parameters leafIndex int Index of the leaf in the tree. minPointer Vector3* Pointer to the minimum bounds vector in the tree. maxPointer Vector3* Pointer to the maximum bounds vector in the tree. GetLeftPackMask(Vector128<int>, out int) public static Vector128<int> GetLeftPackMask(Vector128<int> mask, out int count) Parameters mask Vector128<int> count int Returns Vector128<int> GetNodeChildForLeaf(Leaf) Gets a reference to the node child representing the leaf within the tree. public readonly ref NodeChild GetNodeChildForLeaf(Leaf leaf) Parameters leaf Leaf Leaf to look up in the tree. Returns NodeChild A reference to the node child within the tree. GetNodeChildForLeaf(int) Gets a reference to the node child representing the leaf within the tree. public readonly ref NodeChild GetNodeChildForLeaf(int leafIndex) Parameters leafIndex int Index of the leaf to look up in the tree. Returns NodeChild A reference to the node child within the tree. GetOverlaps<TOverlapHandler>(ref Tree, ref TOverlapHandler) Gets pairs of leaf indices with bounding boxes which overlap. public void GetOverlaps<TOverlapHandler>(ref Tree treeB, ref TOverlapHandler overlapHandler) where TOverlapHandler : struct, IOverlapHandler Parameters treeB Tree Tree to test this tree against. overlapHandler TOverlapHandler Handler to report pairs to. Type Parameters TOverlapHandler Type of the IOverlapHandler implementation to report pairs to. GetOverlaps<TEnumerator>(BoundingBox, ref TEnumerator) public readonly void GetOverlaps<TEnumerator>(BoundingBox boundingBox, ref TEnumerator leafEnumerator) where TEnumerator : IBreakableForEach<int> Parameters boundingBox BoundingBox leafEnumerator TEnumerator Type Parameters TEnumerator GetOverlaps<TEnumerator>(Vector3, Vector3, ref TEnumerator) public readonly void GetOverlaps<TEnumerator>(Vector3 min, Vector3 max, ref TEnumerator leafEnumerator) where TEnumerator : IBreakableForEach<int> Parameters min Vector3 max Vector3 leafEnumerator TEnumerator Type Parameters TEnumerator GetSelfOverlaps2<TOverlapHandler>(ref TOverlapHandler) Reports all bounding box overlaps between leaves in the tree to the given TOverlapHandler. public readonly void GetSelfOverlaps2<TOverlapHandler>(ref TOverlapHandler results) where TOverlapHandler : IOverlapHandler Parameters results TOverlapHandler Handler to report results to. Type Parameters TOverlapHandler GetSelfOverlaps2<TOverlapHandler>(ref TOverlapHandler, BufferPool, IThreadDispatcher, TaskStack*, int, int) Reports all bounding box overlaps between leaves in the tree to the given TOverlapHandler. Pushes tasks into the provided BepuUtilities.TaskScheduling.TaskStack. Does not dispatch threads internally; this is intended to be used as a part of a caller-managed dispatch. public void GetSelfOverlaps2<TOverlapHandler>(ref TOverlapHandler results, BufferPool pool, IThreadDispatcher threadDispatcher, TaskStack* taskStack, int workerIndex, int targetTaskCount = -1) where TOverlapHandler : unmanaged, IThreadedOverlapHandler Parameters results TOverlapHandler Handler to report results to. pool BufferPool Pool used for ephemeral allocations. threadDispatcher IThreadDispatcher Thread dispatcher used during the overlap test. taskStack TaskStack* BepuUtilities.TaskScheduling.TaskStack that the overlap test will push tasks onto as needed. workerIndex int Index of the worker calling the function. targetTaskCount int Number of tasks the overlap testing should try to create during execution. If negative, uses BepuUtilities.IThreadDispatcher.ThreadCount. Type Parameters TOverlapHandler Remarks This does not dispatch workers on the BepuUtilities.IThreadDispatcher directly. If the overlap handler requires managed context, that should be provided by whatever dispatched the workers. GetSelfOverlaps2<TOverlapHandler>(ref TOverlapHandler, BufferPool, IThreadDispatcher, object) Reports all bounding box overlaps between leaves in the tree to the given TOverlapHandler. Uses the thread dispatcher to parallelize overlap testing. public void GetSelfOverlaps2<TOverlapHandler>(ref TOverlapHandler results, BufferPool pool, IThreadDispatcher threadDispatcher, object managedContext = null) where TOverlapHandler : unmanaged, IThreadedOverlapHandler Parameters results TOverlapHandler Handler to report results to. pool BufferPool Pool used for ephemeral allocations. threadDispatcher IThreadDispatcher Thread dispatcher used during the overlap testing. managedContext object Managed context to provide to the overlap handler, if any. Type Parameters TOverlapHandler GetSelfOverlapsBatched<TOverlapHandler>(ref TOverlapHandler, BufferPool) public void GetSelfOverlapsBatched<TOverlapHandler>(ref TOverlapHandler results, BufferPool pool) where TOverlapHandler : IOverlapHandler Parameters results TOverlapHandler pool BufferPool Type Parameters TOverlapHandler GetSelfOverlaps<TOverlapHandler>(ref TOverlapHandler) public readonly void GetSelfOverlaps<TOverlapHandler>(ref TOverlapHandler results) where TOverlapHandler : IOverlapHandler Parameters results TOverlapHandler Type Parameters TOverlapHandler GetSerializedByteCount() Gets the number of bytes required to store the tree. public readonly int GetSerializedByteCount() Returns int Number of bytes required to store the tree. Intersects(Vector3, Vector3, TreeRay*, out float) public static bool Intersects(Vector3 min, Vector3 max, TreeRay* ray, out float t) Parameters min Vector3 max Vector3 ray TreeRay* t float Returns bool MeasureCacheQuality() public readonly float MeasureCacheQuality() Returns float MeasureCacheQuality(int) public readonly float MeasureCacheQuality(int nodeIndex) Parameters nodeIndex int Returns float MeasureCostMetric() public float MeasureCostMetric() Returns float RayCast<TLeafTester>(Vector3, Vector3, ref float, ref TLeafTester, int) public readonly void RayCast<TLeafTester>(Vector3 origin, Vector3 direction, ref float maximumT, ref TLeafTester leafTester, int id = 0) where TLeafTester : IRayLeafTester Parameters origin Vector3 direction Vector3 maximumT float leafTester TLeafTester id int Type Parameters TLeafTester Refine2(int, ref int, int, int, BufferPool, IThreadDispatcher, TaskStack*, int, int, bool, bool) Incrementally refines a subset of the tree by running a binned builder over subtrees. Pushes tasks into the provided BepuUtilities.TaskScheduling.TaskStack. Does not dispatch threads internally; this is intended to be used as a part of a caller-managed dispatch. public void Refine2(int rootRefinementSize, ref int subtreeRefinementStartIndex, int subtreeRefinementCount, int subtreeRefinementSize, BufferPool pool, IThreadDispatcher threadDispatcher, TaskStack* taskStack, int workerIndex, int targetTaskCount = -1, bool deterministic = false, bool usePriorityQueue = true) Parameters rootRefinementSize int Size of the refinement run on nodes near the root. Nonpositive values will cause the root refinement to be skipped. subtreeRefinementStartIndex int Index used to distribute subtree refinements over multiple executions. subtreeRefinementCount int Number of subtree refinements to execute. subtreeRefinementSize int Target size of subtree refinements. The actual size of refinement will usually be larger or smaller. pool BufferPool Pool used for ephemeral allocations during the refinement. threadDispatcher IThreadDispatcher Thread dispatcher used during the refinement. taskStack TaskStack* BepuUtilities.TaskScheduling.TaskStack that the refine operation will push tasks onto as needed. workerIndex int Index of the worker calling the function. targetTaskCount int Number of tasks the refinement should try to create during execution. If negative, uses BepuUtilities.IThreadDispatcher.ThreadCount. deterministic bool Whether to force determinism at a slightly higher cost when using internally multithreaded execution for an individual refinement operation. If the refine is single threaded, it is already deterministic and this flag has no effect. usePriorityQueue bool True if the root refinement should use a priority queue during subtree collection to find larger nodes, false if it should try to collect a more balanced tree. Remarks Nodes will not be refit. Refine2(int, ref int, int, int, BufferPool, IThreadDispatcher, bool, bool) Incrementally refines a subset of the tree by running a binned builder over subtrees. public void Refine2(int rootRefinementSize, ref int subtreeRefinementStartIndex, int subtreeRefinementCount, int subtreeRefinementSize, BufferPool pool, IThreadDispatcher threadDispatcher, bool deterministic = false, bool usePriorityQueue = true) Parameters rootRefinementSize int Size of the refinement run on nodes near the root. Nonpositive values will cause the root refinement to be skipped. subtreeRefinementStartIndex int Index used to distribute subtree refinements over multiple executions. subtreeRefinementCount int Number of subtree refinements to execute. subtreeRefinementSize int Target size of subtree refinements. The actual size of refinement will usually be larger or smaller. pool BufferPool Pool used for ephemeral allocations during the refinement. threadDispatcher IThreadDispatcher Thread dispatcher used during the refinement. deterministic bool Whether to force determinism at a slightly higher cost when using internally multithreaded execution for an individual refinement operation. If the refine is single threaded, it is already deterministic and this flag has no effect. usePriorityQueue bool True if the root refinement should use a priority queue during subtree collection to find larger nodes, false if it should try to collect a more balanced tree. Remarks Nodes will not be refit. Refine2(int, ref int, int, int, BufferPool, bool) Incrementally refines a subset of the tree by running a binned builder over subtrees. public void Refine2(int rootRefinementSize, ref int subtreeRefinementStartIndex, int subtreeRefinementCount, int subtreeRefinementSize, BufferPool pool, bool usePriorityQueue = true) Parameters rootRefinementSize int Size of the refinement run on nodes near the root. Nonpositive values will cause the root refinement to be skipped. subtreeRefinementStartIndex int Index used to distribute subtree refinements over multiple executions. subtreeRefinementCount int Number of subtree refinements to execute. subtreeRefinementSize int Target size of subtree refinements. The actual size of refinement will usually be larger or smaller. pool BufferPool Pool used for ephemeral allocations during the refinement. usePriorityQueue bool True if the root refinement should use a priority queue during subtree collection to find larger nodes, false if it should try to collect a more balanced tree. Remarks Nodes will not be refit. Refit() Updates the bounding boxes of all internal nodes in the tree. public readonly void Refit() Refit2() Updates the bounding boxes of all internal nodes in the tree. public readonly void Refit2() Refit2(BufferPool, IThreadDispatcher) Refits all bounding boxes in the tree using multiple threads. public readonly void Refit2(BufferPool pool, IThreadDispatcher dispatcher) Parameters pool BufferPool Pool used for main thread temporary allocations during execution. dispatcher IThreadDispatcher Dispatcher used during execution. Refit2(BufferPool, IThreadDispatcher, TaskStack*, int, int) Refits all bounding boxes in the tree using multiple threads. Pushes tasks into the provided BepuUtilities.TaskScheduling.TaskStack. Does not dispatch threads internally; this is intended to be used as a part of a caller-managed dispatch. public readonly void Refit2(BufferPool pool, IThreadDispatcher dispatcher, TaskStack* taskStack, int workerIndex, int targetTaskCount = -1) Parameters pool BufferPool Pool used for allocations during execution. dispatcher IThreadDispatcher Dispatcher used during execution. taskStack TaskStack* BepuUtilities.TaskScheduling.TaskStack that the refit operation will push tasks onto as needed. workerIndex int Index of the worker calling the function. targetTaskCount int Number of tasks the refit should try to create during execution. Refit2WithCacheOptimization(BufferPool, IThreadDispatcher, TaskStack*, int, int, bool) Refits all bounding boxes in the tree using multiple threads. Reallocates the nodes and writes the refit tree into them in depth first traversal order. The tree instance is modified to point to the new nodes. Pushes tasks into the provided BepuUtilities.TaskScheduling.TaskStack. Does not dispatch threads internally; this is intended to be used as a part of a caller-managed dispatch. public void Refit2WithCacheOptimization(BufferPool pool, IThreadDispatcher dispatcher, TaskStack* taskStack, int workerIndex, int targetTaskCount = -1, bool disposeOriginalNodes = true) Parameters pool BufferPool Pool used for allocations during execution. dispatcher IThreadDispatcher Dispatcher used during execution. taskStack TaskStack* BepuUtilities.TaskScheduling.TaskStack that the refit operation will push tasks onto as needed. workerIndex int Index of the worker calling the function. targetTaskCount int Number of tasks the refit should try to create during execution. If negative, uses BepuUtilities.IThreadDispatcher.ThreadCount. disposeOriginalNodes bool Whether to dispose of the original nodes buffer. If false, it's up to the caller to dispose of it appropriately. Refit2WithCacheOptimization(BufferPool, IThreadDispatcher, bool) Refits all bounding boxes in the tree using multiple threads. Reallocates the nodes and metanodes and writes the refit tree into them in depth first traversal order. The tree instance is modified to point to the new nodes and metanodes. public void Refit2WithCacheOptimization(BufferPool pool, IThreadDispatcher dispatcher, bool disposeOriginalNodes = true) Parameters pool BufferPool Pool used for main thread temporary allocations during execution. dispatcher IThreadDispatcher Dispatcher used during execution. disposeOriginalNodes bool Whether to dispose of the original nodes buffer. If false, it's up to the caller to dispose of it appropriately. Refit2WithCacheOptimization(BufferPool, bool) Updates the bounding boxes of all internal nodes in the tree. Reallocates the nodes and metanodes and writes the refit tree into them in depth first traversal order. The tree instance is modified to point to the new nodes and metanodes. public void Refit2WithCacheOptimization(BufferPool pool, bool disposeOriginalNodes = true) Parameters pool BufferPool Pool to allocate from. If disposeOriginals is true, this must be the same pool from which the Nodes buffer was allocated from. disposeOriginalNodes bool Whether to dispose of the original nodes buffer. If false, it's up to the caller to dispose of it appropriately. Refit2WithCacheOptimization(Buffer<Node>) Updates the bounding boxes of all internal nodes in the tree. The refit is based on the provided sourceNodes, and the results are written into the tree's current Nodes, Metanodes, and Leaves buffers. The nodes and metanodes will be in depth traversal order. The input source buffer is not modified. public void Refit2WithCacheOptimization(Buffer<Node> sourceNodes) Parameters sourceNodes Buffer<Node> Nodes to base the refit on. Refit2WithCacheOptimization(Buffer<Node>, BufferPool, IThreadDispatcher, TaskStack*, int, int) Updates the bounding boxes of all internal nodes in the tree using multiple threads. The refit is based on the provided sourceNodes, and the results are written into the tree's current Nodes, Metanodes, and Leaves buffers. The nodes and metanodes will be in depth traversal order. The input source buffer is not modified. Pushes tasks into the provided BepuUtilities.TaskScheduling.TaskStack. Does not dispatch threads internally; this is intended to be used as a part of a caller-managed dispatch. public void Refit2WithCacheOptimization(Buffer<Node> sourceNodes, BufferPool pool, IThreadDispatcher dispatcher, TaskStack* taskStack, int workerIndex, int targetTaskCount = -1) Parameters sourceNodes Buffer<Node> Nodes to base the refit on. pool BufferPool Pool used for allocations during execution. dispatcher IThreadDispatcher Dispatcher used during execution. taskStack TaskStack* BepuUtilities.TaskScheduling.TaskStack that the refit operation will push tasks onto as needed. workerIndex int Index of the worker calling the function. targetTaskCount int Number of tasks the refit should try to create during execution. If negative, uses BepuUtilities.IThreadDispatcher.ThreadCount. RefitAndRefine(BufferPool, int, float) public void RefitAndRefine(BufferPool pool, int frameIndex, float refineAggressivenessScale = 1) Parameters pool BufferPool frameIndex int refineAggressivenessScale float RefitForNodeBoundsChange(int) Refits the bounding box of every parent of the node recursively to the root. public readonly void RefitForNodeBoundsChange(int nodeIndex) Parameters nodeIndex int Node to propagate a node change for. RemoveAt(int) Removes a leaf at an index. If the index is not at the end of the leaf list, the last leaf is swapped into the removed location. public int RemoveAt(int leafIndex) Parameters leafIndex int Index of the leaf to remove. Returns int Former index of the leaf that was moved into the removed leaf's slot, if any. If leafIndex pointed at the last slot in the list, then this returns -1 since no leaf was moved. Resize(BufferPool, int) Resizes the buffers backing the tree's nodes and leaves. Will not shrink the buffers below the size needed by the currently resident nodes and leaves. public void Resize(BufferPool pool, int targetLeafSlotCount) Parameters pool BufferPool Pool from which to take and return resources. targetLeafSlotCount int The desired number of available leaf slots. Serialize(Span<byte>) Writes a tree into a byte buffer. public readonly void Serialize(Span<byte> bytes) Parameters bytes Span<byte> Buffer to hold the tree's data. SweepBuild(BufferPool, Buffer<BoundingBox>) public void SweepBuild(BufferPool pool, Buffer<BoundingBox> leafBounds) Parameters pool BufferPool leafBounds Buffer<BoundingBox> Sweep<TLeafTester>(in BoundingBox, Vector3, float, ref TLeafTester) public readonly void Sweep<TLeafTester>(in BoundingBox boundingBox, Vector3 direction, float maximumT, ref TLeafTester sweepTester) where TLeafTester : ISweepLeafTester Parameters boundingBox BoundingBox direction Vector3 maximumT float sweepTester TLeafTester Type Parameters TLeafTester Sweep<TLeafTester>(Vector3, Vector3, Vector3, float, ref TLeafTester) public readonly void Sweep<TLeafTester>(Vector3 min, Vector3 max, Vector3 direction, float maximumT, ref TLeafTester sweepTester) where TLeafTester : ISweepLeafTester Parameters min Vector3 max Vector3 direction Vector3 maximumT float sweepTester TLeafTester Type Parameters TLeafTester UpdateBounds(int, Vector3, Vector3) Applies updated bounds to the given leaf index in the tree, refitting the tree to match. public readonly void UpdateBounds(int leafIndex, Vector3 min, Vector3 max) Parameters leafIndex int Index of the leaf in the tree to update. min Vector3 New minimum bounds for the leaf. max Vector3 New maximum bounds for the leaf. Validate() public readonly void Validate()"
  },
  "api/BepuPhysics.Trees.TreeRay.html": {
    "href": "api/BepuPhysics.Trees.TreeRay.html",
    "title": "Struct TreeRay | Bepu API",
    "keywords": "Struct TreeRay Namespace BepuPhysics.Trees Assembly BepuPhysics.dll Ray representation designed for quicker intersection against axis aligned bounding boxes. public struct TreeRay Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields InverseDirection public Vector3 InverseDirection Field Value Vector3 MaximumT public float MaximumT Field Value float OriginOverDirection public Vector3 OriginOverDirection Field Value Vector3 Methods CreateFrom(Vector3, Vector3, float, out TreeRay) public static void CreateFrom(Vector3 origin, Vector3 direction, float maximumT, out TreeRay treeRay) Parameters origin Vector3 direction Vector3 maximumT float treeRay TreeRay CreateFrom(Vector3, Vector3, float, int, out RayData, out TreeRay) public static void CreateFrom(Vector3 origin, Vector3 direction, float maximumT, int id, out RayData rayData, out TreeRay treeRay) Parameters origin Vector3 direction Vector3 maximumT float id int rayData RayData treeRay TreeRay"
  },
  "api/BepuPhysics.Trees.html": {
    "href": "api/BepuPhysics.Trees.html",
    "title": "Namespace BepuPhysics.Trees | Bepu API",
    "keywords": "Namespace BepuPhysics.Trees Classes Tree.MultithreadedIntertreeTest<TOverlapHandler> Tree.MultithreadedSelfTest<TOverlapHandler> Tree.RefitAndRefineMultithreadedContext Caches input and output for the multithreaded execution of a tree's refit and refinement operations. Structs BinnedResources Leaf Pointer to a leaf's tree location. Metanode Metadata associated with a 2-child tree node. Node 2-wide tree node. NodeChild RayBatcher Reusable structure for testing large numbers of rays against trees. RayData RaySource SubtreeHeapEntry Tree Tree.NodeTimes TreeRay Ray representation designed for quicker intersection against axis aligned bounding boxes. Interfaces IBatchedRayLeafTester IOverlapHandler Overlap callback for tree overlap queries. IRayLeafTester IRaySource ISweepLeafTester IThreadedOverlapHandler Overlap callback for tree overlap queries. Used in multithreaded contexts."
  },
  "api/BepuPhysics.html": {
    "href": "api/BepuPhysics.html",
    "title": "Namespace BepuPhysics | Bepu API",
    "keywords": "Namespace BepuPhysics Classes BatchCompressor Handles the movement of constraints from higher indexed batches into lower indexed batches to avoid accumulating a bunch of unnecessary ConstraintBatches. Bodies Collection of all allocated bodies. BoundingBoxHelpers CollidableProperty<T> Convenience collection that stores extra properties about bodies and statics, indexed by the body or static handle. DefaultTimestepper Updates the simulation in the order of: sleeper -> predict body bounding boxes -> collision detection -> substepping solve -> data structure optimization. Each substep of the solve simulates and integrates a sub-timestep of length dt/substepCount. DefaultTypes Helper class to register the default types within a simulation instance. Helpers Shared miscellaneous helper functions. InvasiveHashDiagnostics Helper diagnostics class for monitoring internal state determinism across runs. Typically used by inserting tests into engine internals. IslandAwakener Provides functionality for efficiently waking up sleeping bodies. IslandSleeper PoseIntegration Provides helper functions for integrating body poses. PoseIntegrator<TCallbacks> Handles body integration work that isn't bundled into the solver's execution. Predicts bounding boxes, integrates velocity and poses for unconstrained bodies, and does final post-substepping pose integration for constrained bodies. Simulation Orchestrates the bookkeeping and execution of a full dynamic simulation. Solver Holds and solves constraints between bodies in a simulation. Solver<TIntegrationCallbacks> Handles integration-aware substepped solving. Statics Collection of allocated statics. Structs ActiveConstraintBodyHandleCollector Collects body handles associated with an active constraint as integers. ActiveConstraintBodyIndexCollector Collects body indices associated with an active constraint. Encoded metadata is stripped. ActiveConstraintDynamicBodyHandleCollector Collects body handles associated with an active constraint as integers. BodyActivity Describes how a body sleeps, and its current state with respect to sleeping. BodyActivityDescription Describes the thresholds for a body going to sleep. BodyConstraintReference BodyDescription Describes a body's state. BodyDynamics Stores all body information needed by the solver together. BodyHandle Unique identifier of a body belonging to a simulation's Bodies collection. BodyInertia Stores the inertia for a body. BodyInertiaWide BodyInertias Stores the local and world views of a body's inertia, packed together for efficient access. BodyMemoryLocation Location of a body in memory. BodyReference Convenience structure for directly referring to a body's properties. BodySet Stores a group of bodies- either the set of active bodies, or the bodies involved in an inactive simulation island. BodyVelocity Linear and angular velocity for a body. BodyVelocityWide BoundingBoxBatch BoundingBoxBatcher BoundingBoxInstance BoundsContinuation ConstraintBatch Contains a set of type batches whose constraints share no body references. ConstraintHandle Unique identifier of a constraint belonging to a simulation's Solver. ConstraintLocation Location in memory where a constraint is stored. ConstraintReference Reference to a constraint's memory location in the solver. ConstraintSet FloatCollector MotionState Describes the pose and velocity of a body. PassthroughReferenceCollector Directly reports references as provided by whatever is being enumerated. For example, when used directly with the TypeProcessor's EnumerateConnectedRawBodyReferences, if the constraint is active, this will report encoded body indices. If the constraint is sleeping, this will report body handles. If used with an enumerator that does filtering, the filtered results will be reported unmodified. RigidPose Represents a rigid transformation. RigidPoseWide SequentialFallbackBatch Contains constraints that could not belong to any lower constraint batch due to their involved bodies. All of the contained constraints will be solved using a fallback solver that trades rigidity for parallelism. SimulationAllocationSizes The common set of allocation sizes for a simulation. SimulationProfiler Stores profiling information for the previous simulation execution. SolveDescription Describes how the solver should schedule substeps and velocity iterations. Solver.IntegrationWorkBlock Solver.SolverSyncStage Solver.SubstepMultithreadingContext Solver.WorkBlock Solver<TIntegrationCallbacks>.IncrementalUpdateForSubstepFilter Solver<TIntegrationCallbacks>.MainSolveFilter Static Stores data for a static collidable in the simulation. Statics can be posed and collide, but have no velocity and no dynamic behavior. StaticDescription Describes the properties of a static object. When added to a simulation, static objects can collide but have no velocity and will not move in response to forces. StaticHandle Unique identifier of a static belonging to a simulation's Statics collection. StaticReference Convenience structure for directly referring to a static's properties. StaticsShouldntAwakenBodies Awakening filter that prevents any bodies from being awoken by the static's state change. StaticsShouldntAwakenKinematics Default awakening filter that only wakes up dynamic bodies. Kinematic bodies do not respond to any kind of dynamic simulation, so they won't respond to the change in statics. Interfaces IPoseIntegrator IPoseIntegratorCallbacks Defines a type that handles callbacks for body pose integration. IRayHitHandler Defines a type capable of filtering ray test candidates and handling ray hit results. IShapeRayHitHandler IStaticChangeAwakeningFilter Defines a type that determines which bodies should be awoken in the bounding box of a static when the static's state changes. ISweepHitHandler Defines a type capable of filtering sweep candidates and handling sweep results. ITimestepper Defines a type capable of updating the simulation state for a given elapsed time. Solver<TIntegrationCallbacks>.IStageFunction Solver<TIntegrationCallbacks>.ITypeBatchSolveFilter Enums AngularIntegrationMode Defines how a pose integrator should handle angular velocity integration. HashDiagnosticType Hardcoded hash types used by invasive hash diagnostics. Solver.SolverStageType Delegates Solver.SubstepEvent Delegate type of solver substep begin/end events. SubstepVelocityIterationScheduler Callback executed to determine how many velocity iterations should be used for a given substep. TimestepperStageHandler Delegate used by ITimesteppers for their stage callbacks."
  },
  "changelog.html": {
    "href": "changelog.html",
    "title": "2.4 | Bepu Docs",
    "keywords": "2.4 At a high level, 2.4 was a solver revamp. Data layout and access patterns were significantly changed and dispatch logic was reworked. Substepping is massively cheaper now, and even simulations without any need of substepping will still benefit significantly. Whole frame speedups in excess of 2x were not uncommon in benchmarks. Scenes that were especially difficult for the solver in 2.3 were observed to be over 3.5x faster in 2.4. API Breaking Changes The library now depends on .NET 6. Simulation.Create no longer requires an ITimestepper, though one can still be provided. PositionFirstTimestepper and PositionLastTimestepper no longer exist; the only built-in ITimestepper implementation is the DefaultTimestepper. This is a result of 2.4 moving entirely to an embedded substepping solver. Simulation.Create now takes a SolveDescription. It can be used to configure the number of substeps, velocity iterations, and synchronized batches. There exist helper implicit casts; for example, passing an integer will simply use the value as the number of substeps, with the velocity iteration count set to 1 and FallbackBatchThreshold set to the default. Solver.IterationCount property renamed to Solver.VelocityIterationCount. See the substepping documentation for more information. IPoseIntegratorCallbacks.IntegrateVelocity now exposes multiple lanes of bodies in SIMD vectors, rather than a single body at a time. It also exposes two new properties, IntegrateVelocityForKinematics and AllowSubstepsForUnconstrainedBodies. If IntegrateVelocityForKinematics is false, then IntegrateVelocity will not include any kinematic bodies in active lanes. This is convenient when applying gravity; if only dynamics are ever invoked, then there's no need to check kinematicity prior to applying gravity. If AllowSubstepsForUnconstrainedBodies is true, then bodies with no constraints will have their velocities and poses integrated for every substep; if false, they will only be integrated a single time for the full frame duration. All constrained bodies are substepped if the solver is substepped. The vectorized nature of this callback is probably going to be annoying (and/or confusing) for a lot of people; sorry about that. Maintaining a scalar callback added too much overhead. You can build one on top, though! When constructing a collidable description, the overload that takes a speculative margin now means the maximum speculative margin. 2.4 uses adaptive speculative margins that can shrink or expand according to velocity. You will usually see the same behavior, just cheaper. If you want to match the old behavior as much as possible, set both the minimum and maximum bounds to the same value. Leaving speculative margins bounds at [0, float.MaxValue] is a good default now. Note that there are some new implicit casts relevant to BodyDescription creation that can make things shorter, including just passing a shape index directly which defaults to passive continuity with [0, float.MaxValue] adaptive speculative margin. See continuous collision detection documentation for more information. Statics no longer have any configurable speculative margin settings and do not take a CollidableDescription in their constructor. They still have a Continuity field if a static should a static need continuous collision detection to be enabled. All information related to a static is now in one spot, stored in the Statics.StaticsBuffer. ContinuousDetectionSettings renamed to ContinuousDetection. INarrowPhaseCallbacks.AllowContactGeneration now exposes ref float speculativeMargin. Most use cases can safely ignore this completely, but if you find yourself wanting fine grained control over the speculative margin, that's now exposed. IConvexShape.ComputeInertia now returns instead of using an out parameter. Similar changes applied to things like Mesh.ComputeClosedInertia and Mesh.ComputeOpenInertia. Some callbacks that previously had struct generic constraints now require unmanaged, like INarrowPhaseCallbacks.ConfigureContactManifold. BodyOptimizer/ConstraintOptimizer stages no longer exist, and their profiler entries have been removed. Solver.ApplyDescription no longer requires a ref parameter. BodyInertias and BodyVelocities renamed to BodyInertiaWide and BodyVelocityWide to match naming convention of other wide types. IThreadDispatcher now takes an additional maximumWorkerCount parameter. Specifying a maximum worker count lower than the IThreadDispatcher.ThreadCount may allow the implementation to do less work. In practice, the BepuUtilities.ThreadDispatcher uses this to significantly reduce dispatch overhead for low job count use cases. All body state used by the solver now bundled together into BodySet.SolverStates. Includes pose, velocity, and inertia. Constraint type batches no longer have a 'projection' buffer; anything loaded from it is now recalculated on the fly. RawBuffer removed. Usages replaced with Buffer<byte>. Other Changes Added CenterDistanceLimit! Useful for clothy stuff. Added AngularAxisGearMotor; transforms angular motion with a multiplier, somewhat like a gear ratio. RigidPose, BodyVelocity, CollidableDescription, and BodyActivityDescription all now have helper implicit casts to optionally make configuration a little less syntax-noisy. You can now get a BodyReference or StaticReference from their respective collections by using Simulation.Bodies[BodyHandle] and Simulation.Statics[StaticHandle]. The presence of a kinematic body in a constraint batch will no longer block another constraint attached to that kinematic body from being added to the constraint batch. The velocity of kinematics in constraint batches are treated as read-only. This will improve performance on simulations where a kinematic body has a ton of constraints associated with it. Broad phase dispatches combined. The long-waiting broad phase revamp is still waiting; this just reduces dispatch related overhead slightly. Code paths dependent on trigonometric approximations have had their accuracy improved by a few orders of magnitude. AngularHinge, TwistServo, QuaternionWide.GetAxisAngleFromQuaternion, and orientation integration are all improved. The improvement in orientation integration in particular helps avoid contact drift and helps integration with angular momentum conservation. Constraints in the fallback batch now have sequentialized execution, rather than using a jacobi solver. This improves simulation quality in pathological cases where a single dynamic body is associated with tons of constraints, but that situation is still best avoided. Anything that ends up in the fallback batch will cost more by virtue of being executed sequentially. More information and potential future improvements here: Fallback batch improvements  Issue #162  bepu/bepuphysics2 (github.com). Contact constraints now solve friction last. In simulations that don't let the solver reach an equilibrium solution, you might notice that an unstable stack of bodies exhibits more tangential jitter and less penetration jitter than it used to. In a simulation that allows enough time to solve the constraints, there should be no visible difference. (This change was motivated by the fact that penetration has a corrective feedback loop via depth, while friction is open ended. Giving friction the final word slightly reduces drift.) VolumeConstraint had a warmstarting jacobian bug; it's fixed. Should be higher quality (and stiffer, if configured to be stiff). Hinge and SwivelHinge never made use of accumulated impulses, oops. Should be higher quality (and stiffer, if configured to be stiff). SwivelHinge no longer has a unguarded NaNsplode codepath. Fixed a bug in AngularMotor that used the wrong inertia. Guarded against a sphere-cylinder division by zero. Fixed a capsule-cylinder determinism bug. Fixed a triangle-cylinder determinism bug. Fixed capsule-cylinder contact generation bug. Fixed cylinder-cylinder contact generation bug. Box-box now has a bundle early out. All triangle-involving collision pairs now consistent in triangle degeneracy testing. All triangle-involving collision pairs now handle collisions with normals pointing nearly perpendicular to the triangle plane much more gracefully. Fixed a bunch of other tiny weird triangle collision bugs too. MeshReduction revamped a bit. It should catch more boundary bumps, and it no longer tries to do a quadratically catastrophic operation when the number of triangles being considered is large. At a certain (extreme) point, it now simply doesn't bother with boundary smoothing at all. BufferPool now allocates blocks from native memory pools rather than the managed heap."
  },
  "index.html": {
    "href": "index.html",
    "title": "bepuphysics docs! | Bepu Docs",
    "keywords": "bepuphysics docs! There are conceptual and API docs! See Getting Started for an introduction to the library. The BepuPhysics and BepuUtilities libraries target .NET 8 and should work on any supported platform. The physics engine heavily uses System.Numerics.Vectors types, so to get good performance, you'll need a compiler which can consume those types (like RyuJIT). The demos application, Demos.sln, uses DX11 by default. There is also a Demos.GL.sln that uses OpenGL and should run on other platforms. The demos can be run from the command line (in the repo root directory) with dotnet run --project Demos/Demos.csproj -c Release or dotnet run --project Demos.GL/Demos.csproj -c Release. To build the source, the easiest option is a recent version of Visual Studio with the .NET desktop development workload installed. Demos.sln references all relevant projects. For more information, see Building."
  },
  "roadmap.html": {
    "href": "roadmap.html",
    "title": "Roadmap | Bepu Docs",
    "keywords": "Roadmap This is a high level plan for future development. All dates and features are extremely speculative, and any specific detail on this roadmap is almost certainly wrong. Treat it as a snapshot of vibes unless noted otherwise. For a more detailed breakdown, check the issues page. Notably, I now have a \"full time job\" doing \"important things\" like some kind of weirdo, so I've given up on trying to guess when these things will actually be done. Think of this roughly as a priority queue. Near term 2.5 should be releasing relatively soon. It already includes a bunch of miscellaneous improvements, plus notable transformative improvements to tree building and refinement. The broad phase is a lot faster. The only significant work remaining in 2.5 is to improve thread load balancing in the broad phase for smaller simulations. Medium term The timing on these features are uncertain, but they're relatively low hanging fruit and I would like to get to them eventually. Super secret special sauce solver changes that may or may not actually work at all. But if they do work, they'll be great! Look into simplifying layouts with the latest generation of solver for usability and sleeper efficiency reasons. More bandwidth optimizations in the solver for broad simulations: https://github.com/bepu/bepuphysics2/issues/193 Catch up with 512 bit instructions and improvements to vectorization. Low hanging fruit in the API; e.g. allow normal delegates or function pointers on functions which currently require reified generics. (This would be a strictly opt-in cost; they'd be implemented through the reified generics API.) Mesh/compound intersection optimization, especially in pairs with higher angular velocity. Narrow phase flush improvements: https://github.com/bepu/bepuphysics2/issues/205 Sleeper improvements. Applies to actual sleep/wake and candidacy analysis. One exemplar: island management scales poorly in the limit (https://github.com/bepu/bepuphysics2/issues/284) ARM specialized paths: https://github.com/bepu/bepuphysics2/issues/184 Convex hull test performance improvements. Scalar-style API for lower pain contact and boolean queries. Ray cast optimization, particularly with large batches of rays. Convex hull tooling improvements, like in-library simplification utilities. Try for partial cross platform determinism by reimplementing some platform-dependent functionality in software. High precision body and static poses, plus associated broad phase changes, for worlds exceeding 32 bit floating point precision. This isn't actually too difficult, but it would come with tradeoffs. See https://github.com/bepu/bepuphysics2/issues/13. 2.4's revamp of the solver and body data layouts intentionally left the door open for higher precision poses. Long term These features are even more speculative. Generalized boundary smoothing to support non-mesh compounds. Would help avoid annoying hitches when scooting around complex geometry composed of a bunch of convex hulls or other non-triangle convexes. Buoyancy. In particular, a form of buoyancy that supports deterministic animated (nonplanar) surfaces. It would almost certainly still be a heightmap, but the goal would be to support synchronized multiplayer boats or similar use cases. Ideally, it would also allow for some approximate handling of concavity. Hollowed concave shapes would displace the appropriate amount of water, including handling of the case where a boat capsizes and the internal volume fills with water (though likely in a pretty hacky way). Would likely be easy to extend this to simple heightmap fluid simulation if the determinism requirement is relaxed."
  }
}